[{"categories":["Python"],"content":"“Hunt the Wumpus” 是什么？ 引用wiki百科： Hunt the Wumpus是Gregory Yob于 1973 年开发的一款基于文本的 冒险游戏。在游戏中，玩家在一系列连接的洞穴中穿行，这些洞穴排列为十二面体的顶点，他们狩猎一个名叫 Wumpus 的怪物。 在回合制游戏中有玩家试图避免致命的无底洞和“超级蝙蝠”，将移动他们周围的洞穴系统; 目标是通过洞穴发射他们的“弯曲箭”之一以杀死Wumpus。 ","date":"2021-12-07","objectID":"/20211207-wumpus/:1:0","tags":["python","算法","游戏"],"title":"使用简单算法两小时实现猎杀乌姆帕斯（Hunt the Wumpus）Python小游戏","uri":"/20211207-wumpus/"},{"categories":["Python"],"content":"我们的目标 原著较为复杂，这里我们作出如下简化： 原著十二面体可以展开为拥有20个顶点（洞穴）的地图。我们简化为更简单的 N*N 矩形地图。每个点代表一个洞穴。暂定为 5 x 5 共25个洞穴。 每个洞穴（点）上下左右四通（非八达）🤪 仅拥有一颗箭，即只有一次命中机会。如果错过未能将怪兽消灭即失败。 如果不慎跌入怪兽洞也算失败。😏 该地图不会出现 无底洞， 超级蝙蝠 等其它元素。😝 隐藏信息，怪兽的洞穴是不可见的，当接近怪兽洞穴一个格子的距离时，会提示“你嗅到了乌姆帕斯的气息”。只有当胜利或失败时才显示。 ","date":"2021-12-07","objectID":"/20211207-wumpus/:2:0","tags":["python","算法","游戏"],"title":"使用简单算法两小时实现猎杀乌姆帕斯（Hunt the Wumpus）Python小游戏","uri":"/20211207-wumpus/"},{"categories":["Python"],"content":"成品展示 麻雀虽小，但五脏俱全呵！首先看一下最终实现的效果，多图杀猫～ 由于判断失误，直接进入怪物洞穴导致失败的情况： 由于只有一只箭，射箭方向错误导致怪物存活而失败的情况： 依靠聪明才智，成功战胜怪物，胜利的结局✌️ ","date":"2021-12-07","objectID":"/20211207-wumpus/:3:0","tags":["python","算法","游戏"],"title":"使用简单算法两小时实现猎杀乌姆帕斯（Hunt the Wumpus）Python小游戏","uri":"/20211207-wumpus/"},{"categories":["Python"],"content":"关键技术 ","date":"2021-12-07","objectID":"/20211207-wumpus/:4:0","tags":["python","算法","游戏"],"title":"使用简单算法两小时实现猎杀乌姆帕斯（Hunt the Wumpus）Python小游戏","uri":"/20211207-wumpus/"},{"categories":["Python"],"content":"1.欢迎界面与开始菜单 这当然是最简单的部分啦，使用字符串输出print一段欢迎信息或游戏帮助信息。 然后接收用户的选择input,并根据不同的条件作出判断if def menu(): print(\"===欢迎进入乌姆帕斯的世界===\") ch = input(\"1. 开始\\n2. 退出\\n-\u003e\") if ch == \"1\": begin() if ch == \"2\": print(\"好吧， 下次再见👋\") ","date":"2021-12-07","objectID":"/20211207-wumpus/:4:1","tags":["python","算法","游戏"],"title":"使用简单算法两小时实现猎杀乌姆帕斯（Hunt the Wumpus）Python小游戏","uri":"/20211207-wumpus/"},{"categories":["Python"],"content":"2. 地图的生成。 地图当然是最重要的一部分，实现的方式有很多种，这里使用最简单最容易理解的列表嵌套（二维数组）。 def create_map(x=5, y=5): # 生成地图 yj = [] for _ in range(y): xi = [] for _ in range(x): xi.append(SPACE) yj.append(xi) wumpas_local, player_local = create_player_local(x, y) yj[wumpas_local[0]][wumpas_local[1]] = WUMPUS yj[player_local[0]][player_local[1]] = PLAYER global p_local p_local = [player_local[0], player_local[1]] return yj 玩家和怪物的坐标即二维数组的下标，使用随机数生成。这里可要注意咯！ 玩家和怪物的随机坐标可能会重合呦！避免随机数重复的方法由很多种，这里使用递归算法生成唯一的坐标。首先随机生成两个坐标，如果坐标相同则再次调用生成坐标的函数，直到生成两个不同的坐标。 def random_local(x, y) -\u003e tuple: \"\"\"随机生成坐标\"\"\" return random.randint(0, x - 1), random.randint(0, y - 1) def create_player_local(x, y) -\u003e tuple: \"\"\"生成怪物和玩家的唯一坐标 wumpas_local 怪物坐标 player_local 玩家坐标 \"\"\" wumpas_local = random_local(x, y) player_local = random_local(x, y) if wumpas_local == player_local: wumpas_local, player_local = create_player_local(x, y) if wumpas_local != player_local: return (wumpas_local, player_local) ","date":"2021-12-07","objectID":"/20211207-wumpus/:4:2","tags":["python","算法","游戏"],"title":"使用简单算法两小时实现猎杀乌姆帕斯（Hunt the Wumpus）Python小游戏","uri":"/20211207-wumpus/"},{"categories":["Python"],"content":"3. 地图的显示 地图已经生成啦，显示就很简单啦！只需根据输赢的状态对地图的字符串做简单的替换即可。 胜利的字符效果 失败的字符效果 ","date":"2021-12-07","objectID":"/20211207-wumpus/:4:3","tags":["python","算法","游戏"],"title":"使用简单算法两小时实现猎杀乌姆帕斯（Hunt the Wumpus）Python小游戏","uri":"/20211207-wumpus/"},{"categories":["Python"],"content":"4. 位移，气息与射箭 玩家的位移，乌姆帕斯的气息与射箭逻辑都是相同的。本质就是对格子四个方向的坐标处理（气息需要处理周边八个格子）。 哈，只用到了二以内的加减法（加一，减一），简单吧？ 啥？ 已经被整晕了？快拿个纸笔画一画～。 def smell(x, y) -\u003e bool: \"\"\"判断附近是否有怪物\"\"\" x1 = MAP_X - 1 if p_local[0] == 0 else p_local[0] - 1 x2 = 0 if p_local[0] == MAP_X - 1 else p_local[0] + 1 y1 = MAP_Y - 1 if p_local[1] == 0 else p_local[1] - 1 y2 = 0 if p_local[1] == MAP_Y - 1 else p_local[1] + 1 round = [(x1, y), (x2, y), (x, y1), (x, y2), (x1, y1), (x1, y2), (x2, y1), (x2, y2)] for r in round: if MAP[r[0]][r[1]] == WUMPUS: return True return False ","date":"2021-12-07","objectID":"/20211207-wumpus/:4:4","tags":["python","算法","游戏"],"title":"使用简单算法两小时实现猎杀乌姆帕斯（Hunt the Wumpus）Python小游戏","uri":"/20211207-wumpus/"},{"categories":["Python"],"content":"5. 大圆满 对啦，整个游戏其实就是一个状态机，总共有胜利，失败 ，游戏中三种状态。那么我们可以使用一个 while 语句，搞起一个事件循环 。就可以一直愉快滴玩耍啦！开心不开心？ 虽然该篇程序没有复杂的算法，但使用简单的顺序，判断，循环 语句和一丢丢递归算法就可实现稍稍复杂的小游戏。 正所谓：大道至简 重剑无锋 大巧不工 ","date":"2021-12-07","objectID":"/20211207-wumpus/:4:5","tags":["python","算法","游戏"],"title":"使用简单算法两小时实现猎杀乌姆帕斯（Hunt the Wumpus）Python小游戏","uri":"/20211207-wumpus/"},{"categories":["Python"],"content":"思考 这个游戏还有很多可以扩展的内容，下面留下几个思考题，让游戏更好玩吧～ 随机坐标去重还有哪些方式可以实现？ 加入 无底洞和 超级蝙蝠 元素。 加入游戏积分，游戏计时 与 游戏存档功能。 源码见： https://github.com/spaceack/Hunt-the-Wumpus.git 或关注公众号【编程之舞】回复wumpus领取。 ","date":"2021-12-07","objectID":"/20211207-wumpus/:4:6","tags":["python","算法","游戏"],"title":"使用简单算法两小时实现猎杀乌姆帕斯（Hunt the Wumpus）Python小游戏","uri":"/20211207-wumpus/"},{"categories":["消息队列"],"content":"实现起来就是 消息 带 状态 和 版本号 字段。 更新时用 版本号 做乐观锁。操作逻辑就是个状态机。 UPDATE mq SET mq.status=new_status mq.version = mq.version + 1 WHERE mq.version = old_version ","date":"2021-09-29","objectID":"/20210929-%E4%BD%BF%E7%94%A8mysql%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:0:0","tags":["MQ","mysql"],"title":"使用Mysql实现消息队列","uri":"/20210929-%E4%BD%BF%E7%94%A8mysql%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["消息队列"],"content":"实现 ","date":"2021-09-29","objectID":"/20210929-%E4%BD%BF%E7%94%A8mysql%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:0","tags":["MQ","mysql"],"title":"使用Mysql实现消息队列","uri":"/20210929-%E4%BD%BF%E7%94%A8mysql%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["消息队列"],"content":"mysql mq 表结构设计 CREATETABLE`mq`(`id`bigint(20)unsignedNOTNULLAUTO_INCREMENT,`msg`varchar(1024)DEFAULTNULL,`status`varchar(100)DEFAULT'ready',`version`bigint(20)unsignedDEFAULT0,PRIMARYKEY(`id`))ENGINE=InnoDBAUTO_INCREMENT=10DEFAULTCHARSET=utf8mb4; ","date":"2021-09-29","objectID":"/20210929-%E4%BD%BF%E7%94%A8mysql%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:1","tags":["MQ","mysql"],"title":"使用Mysql实现消息队列","uri":"/20210929-%E4%BD%BF%E7%94%A8mysql%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["消息队列"],"content":"生产者 测试，向队列插入两条消息。 insertintomq(msg)values('第一条消息 hello world! 1024');insertintomq(msg)values('第二条消息 欢迎访问 https://spaceack.com'); ","date":"2021-09-29","objectID":"/20210929-%E4%BD%BF%E7%94%A8mysql%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:2","tags":["MQ","mysql"],"title":"使用Mysql实现消息队列","uri":"/20210929-%E4%BD%BF%E7%94%A8mysql%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["消息队列"],"content":"消费者 获取队列中的消息， 此时不会改变队列（mq表）中的数据。 select*frommqwherestatus='ready'limit1; 消息确认 updatemqsetmq.status='ack',mq.version=mq.version+1WHEREmq.version={query_version}andid={query_id} 确认后的状态： 再次获取数据仅能获取第二条数据。 这样的一个好处就是消息都是可见的。 可以直接查数据库。 不用加悲观锁，因为update成功后就带锁。其它同版本的更新都会失败。 还有个好处就是减少组件依赖。 简单的服务数据库就能搞定。 不用再起个rabbitmq服务啥的。 节约运维成本。 版本号 另一个小作用：InnoDB如果更新语句没有改变任何字段值时，影响行数会返回0.那么是没找到记录还是没改变值的0呢？前者是bug， 后者是正常情况但区分不了。加版本号后每次修改+1，影响行数一定不为0。 隐藏福利：生产者自动批量测试脚本： import random import subprocess def runcmd(command): ret = subprocess.run(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE,encoding=\"utf-8\",timeout=1) if ret.returncode == 0: # print(\"success:\",ret, ret.stdout) return ret.stdout else: print(\"error:\",ret) def producer(): sql = \"\\\"insert into mq(msg) values('%s');\\\"\" % (str(random.randint(1,99999))) cmd = \"\"\"mysql -uroot -ppassword test -e %s\"\"\" % (sql) runcmd(cmd) ","date":"2021-09-29","objectID":"/20210929-%E4%BD%BF%E7%94%A8mysql%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:3","tags":["MQ","mysql"],"title":"使用Mysql实现消息队列","uri":"/20210929-%E4%BD%BF%E7%94%A8mysql%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["数据分析","数据可视化"],"content":"长文预警 首先，这是一篇面向新人的教程导向的分析文章，（by the way其实我也是新手，从比赛开始才学的Pandas库，这也是我的一篇学习笔记），所以会包含很多函数的基础用法，解题思路等等, 流程会比较详细。 其次，本文在官方教程基础上会加入创新内容，但是绝不会为了用而用某种新方法，一定本着分析数据有所帮助的原则和对数据敬畏的态度来做。 再者，为了更方便学习，请点击右上角蓝色的 Star 和 Fork 按钮。 [数据集下载: ](!https://tianchi.aliyun.com/competition/entrance/531837/introduction?spm=5176.12281973.1005.3.11ae1f540dSho6) https://tianchi.aliyun.com/competition/entrance/531837/introduction?spm=5176.12281973.1005.3.11ae1f540dSho6 # 导入相关处理包 import pandas as pd # 加入下面这条语句可以在 JupyterLab 上渲染画布（ JupyterLab 是天池实验室的一部分） %matplotlib inline ","date":"2021-01-01","objectID":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/:0:0","tags":["python","数据分析","pandas","桑基图"],"title":"天池大数据竞赛 Spaceack带你利用Pandas，趋势图与桑基图分析美国选民候选人喜好度","uri":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/"},{"categories":["数据分析","数据可视化"],"content":"数据预处理 数据预处理部分包含 数据导入，数据探索，数据整合，格式转换等多个步骤。这些步骤可穿插执行。 这里第一步就是数据导入。 Pandas 提供的 IO 工具组支持多种数据格式类型，包括基础的 CSV，JSON，SQL 格式。 这里用到 read_csv 方法 此方法第一个参数为文件路径, 这里对应着天池实验室挂载的数据，因为在 download 同一目录下, 所以直接写文件名即可。 第二个参数 sep 为分隔符，用于将每行分解为若干列。默认是,逗号。 第三个参数 names 为列名列表，当文件不包含列名时使用，列名列表中不允许有重复值。 扩展：若我们要分析文件中包含列名呢？有个 header 参数可以使用，当列名是首行时，设置 header=0。举一反三，有时候文件首行是文件的标题，第二行才是列名，那么设置 header=1 即可。 将委员会和候选人一一对应，通过CAND_ID关联两个表 由于候选人和委员会的联系表中无候选人姓名，只有候选人ID（CAND_ID），所以需要通过CAND_ID 从候选人表中获取到候选人姓名，最终得到候选人与委员会联系表 ccl。 # 读取候选人信息，由于原始数据没有表头，需要添加表头 candidates = pd.read_csv(\"weball20.txt\", sep = '|',names=['CAND_ID','CAND_NAME','CAND_ICI','PTY_CD','CAND_PTY_AFFILIATION','TTL_RECEIPTS', 'TRANS_FROM_AUTH','TTL_DISB','TRANS_TO_AUTH','COH_BOP','COH_COP','CAND_CONTRIB', 'CAND_LOANS','OTHER_LOANS','CAND_LOAN_REPAY','OTHER_LOAN_REPAY','DEBTS_OWED_BY', 'TTL_INDIV_CONTRIB','CAND_OFFICE_ST','CAND_OFFICE_DISTRICT','SPEC_ELECTION','PRIM_ELECTION','RUN_ELECTION' ,'GEN_ELECTION','GEN_ELECTION_PRECENT','OTHER_POL_CMTE_CONTRIB','POL_PTY_CONTRIB', 'CVG_END_DT','INDIV_REFUNDS','CMTE_REFUNDS']) # 读取候选人和委员会的联系信息 ccl = pd.read_csv(\"ccl.txt\", sep = '|',names=['CAND_ID','CAND_ELECTION_YR','FEC_ELECTION_YR','CMTE_ID','CMTE_TP','CMTE_DSGN','LINKAGE_ID']) ","date":"2021-01-01","objectID":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/:1:0","tags":["python","数据分析","pandas","桑基图"],"title":"天池大数据竞赛 Spaceack带你利用Pandas，趋势图与桑基图分析美国选民候选人喜好度","uri":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/"},{"categories":["数据分析","数据可视化"],"content":"数据整合 我们现在已导入 candidates 候选人信息表，ccl 候选人与委员会关联表两张表。均为 DataFrame 类型。 聪明的你会发现，两个表的表头都包含 CAND_ID 这个字段，那么这两张表会根据这个字段有所联系。那么我们可以用 merge 这个神奇的方法合并两张表。 merge 方法有几个重要的参数如下： left ： 在这里就是我们要合并左边的 ccl 表。 right ： 在这里就是我们要合并右边的 candidates 表。 how ： 这是个带有默认参数的隐藏参数，默认为 inner （内连接），学过 SQL 的同学都懂得～ 肯定还会包含 outer（外链接）、left（左连接）、right（右连接） on ：这个参数用来连接列名，若没有其它连接项，默认会把左右两个表头的交集字段作为连接字段。下面的代码是省略的写法，也可以这样表示 ccl = pd.merge(ccl, candidates, on=\"CAND_ID\", how=\"inner\") left_on ：用来指定左侧作为连接的表头。 right_on：用来指定右侧作为连接的表头， 下面的代码是省略的写法，也可以这样表示 ccl = pd.merge(ccl, candidates, left_on=\"CAND_ID\", right_on=\"CAND_ID\", how=\"inner\") # 关联两个表数据 ccl = pd.merge(ccl, candidates) # 提取出所需要的列 ccl = pd.DataFrame(ccl, columns=[ 'CMTE_ID','CAND_ID', 'CAND_NAME','CAND_PTY_AFFILIATION']) # 读取个人捐赠数据，由于原始数据没有表头，需要添加表头 # 提示：读取本文件大概需要5-10s itcont = pd.read_csv('itcont_2020_20200722_20200820.txt', sep='|',names=['CMTE_ID','AMNDT_IND','RPT_TP','TRANSACTION_PGI','IMAGE_NUM','TRANSACTION_TP','ENTITY_TP','NAME','CITY','STATE','ZIP_CODE','EMPLOYER','OCCUPATION','TRANSACTION_DT','TRANSACTION_AMT','OTHER_ID','TRAN_ID','FILE_NUM','MEMO_CD','MEMO_TEXT','SUB_ID'],low_memory=False) # 将候选人与委员会关系表ccl和个人捐赠数据表itcont合并，通过 CMTE_ID c_itcont = pd.merge(ccl, itcont) ","date":"2021-01-01","objectID":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/:2:0","tags":["python","数据分析","pandas","桑基图"],"title":"天池大数据竞赛 Spaceack带你利用Pandas，趋势图与桑基图分析美国选民候选人喜好度","uri":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/"},{"categories":["数据分析","数据可视化"],"content":"数据探索 # 查看目前数据前6行, 若省略行数，默认显示5行 c_itcont.head(6) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } CMTE_ID CAND_ID CAND_NAME CAND_PTY_AFFILIATION AMNDT_IND RPT_TP TRANSACTION_PGI IMAGE_NUM TRANSACTION_TP ENTITY_TP ... EMPLOYER OCCUPATION TRANSACTION_DT TRANSACTION_AMT OTHER_ID TRAN_ID FILE_NUM MEMO_CD MEMO_TEXT SUB_ID 0 C00698084 H0AZ02182 MORGAN, JOSEPH DAVID REP A Q3 P2020 202010069285031369 15 IND ... RETIRED RETIRED 7242020 100 NaN SA11AI.4909 1444070 NaN NaN 4100820201856947991 1 C00698084 H0AZ02182 MORGAN, JOSEPH DAVID REP A Q3 P2020 202010069285031369 15 IND ... VA HOSPITAL LAB TECH 7242020 40 NaN SA11AI.4908 1444070 NaN NaN 4100820201856947993 2 C00698084 H0AZ02182 MORGAN, JOSEPH DAVID REP A Q3 P2020 202010069285031370 15 IND ... VA HOSPITAL LAB TECH 7312020 40 NaN SA11AI.4916 1444070 NaN NaN 4100820201856947994 3 C00725697 H0AZ03461 WOOD, DANIEL REP A Q3 G2020 202010079285052516 15 IND ... POWERS-LEAVITT INSURANCE AGENT 8102020 300 NaN SA11AI.4683 1444556 NaN NaN 4100920201857257629 4 C00725697 H0AZ03461 WOOD, DANIEL REP A Q3 G2020 202010079285052518 15 IND ... UNEMPLOYED NaN 8072020 500 NaN SA11AI.4612 1444556 NaN NaN 4100920201857257635 5 C00725697 H0AZ03461 WOOD, DANIEL REP A Q3 G2020 202010079285052519 15 IND ... SELF-EMPLOYED DVM 7312020 500 NaN SA11AI.4593 1444556 NaN NaN 4100920201857257636 6 rows × 24 columns # 查看目前数据后3行, 若省略行数，默认显示5行 c_itcont.head(n=3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } CMTE_ID CAND_ID CAND_NAME CAND_PTY_AFFILIATION AMNDT_IND RPT_TP TRANSACTION_PGI IMAGE_NUM TRANSACTION_TP ENTITY_TP ... EMPLOYER OCCUPATION TRANSACTION_DT TRANSACTION_AMT OTHER_ID TRAN_ID FILE_NUM MEMO_CD MEMO_TEXT SUB_ID 0 C00698084 H0AZ02182 MORGAN, JOSEPH DAVID REP A Q3 P2020 202010069285031369 15 IND ... RETIRED RETIRED 7242020 100 NaN SA11AI.4909 1444070 NaN NaN 4100820201856947991 1 C00698084 H0AZ02182 MORGAN, JOSEPH DAVID REP A Q3 P2020 202010069285031369 15 IND ... VA HOSPITAL LAB TECH 7242020 40 NaN SA11AI.4908 1444070 NaN NaN 4100820201856947993 2 C00698084 H0AZ02182 MORGAN, JOSEPH DAVID REP A Q3 P2020 202010069285031370 15 IND ... VA HOSPITAL LAB TECH 7312020 40 NaN SA11AI.4916 1444070 NaN NaN 4100820201856947994 3 rows × 24 columns # 查看数据规模 多少行 多少列 c_itcont.shape (756205, 24) # 查看整体数据信息，包括每个字段的名称、非空数量、字段的数据类型 c_itcont.info() \u003cclass 'pandas.core.frame.DataFrame'\u003e Int64Index: 756205 entries, 0 to 756204 Data columns (total 24 columns): CMTE_ID 756205 non-null object CAND_ID 756205 non-null object CAND_NAME 756205 non-null object CAND_PTY_AFFILIATION 756205 non-null object AMNDT_IND 756205 non-null object RPT_TP 756205 non-null object TRANSACTION_PGI 756205 non-null object IMAGE_NUM 756205 non-null int64 TRANSACTION_TP 756205 non-null object ENTITY_TP 756205 non-null object NAME 756205 non-null object CITY 756159 non-null object STATE 756160 non-null object ZIP_CODE 756092 non-null object EMPLOYER 737413 non-null object OCCUPATION 741294 non-null object TRANSACTION_DT 756205 non-null int64 TRANSACTION_AMT 756205 non-null int64 OTHER_ID 647200 non-null object TRAN_ID 756205 non-null object FILE_NUM 756205 non-null int64 MEMO_CD 220 non-null object MEMO_TEXT 655693 non-null object SUB_ID 756205 non-null int64 dtypes: int64(5), object(19) memory usage: 144.2+ MB # 查看数据表中数据类型的列的数据分布情况 c_itcont.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } IMAGE_NUM TRANSACTION_DT TRANSACTION_AMT FILE_NUM SUB_ID count 7.562050e+05 7.562050e+05 7.562050e+05 7.562050e+05 7.562050e+05 mean 2.020090e+17 7.887799e+06 1.504307e+02 1.439133e+06 4.091288e+18 std 4.071886e+11 3.857874e+05 2.320452e+03 2.325325e+03 4.642365e+15 min 2.020072e+17 7.222020e+06 -5.600000e+03 1.427865e+06 4.072420e+18 25% 2.020092e+17","date":"2021-01-01","objectID":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/:2:1","tags":["python","数据分析","pandas","桑基图"],"title":"天池大数据竞赛 Spaceack带你利用Pandas，趋势图与桑基图分析美国选民候选人喜好度","uri":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/"},{"categories":["数据分析","数据可视化"],"content":"格式转换 #空值处理，统一填充 NOT PROVIDED c_itcont['STATE'].fillna('NOT PROVIDED',inplace=True) c_itcont['EMPLOYER'].fillna('NOT PROVIDED',inplace=True) c_itcont['OCCUPATION'].fillna('NOT PROVIDED',inplace=True) # 对日期TRANSACTION_DT列进行处理 c_itcont['TRANSACTION_DT'] = c_itcont['TRANSACTION_DT'] .astype(str) # 将日期格式改为年月日 7242020 c_itcont['TRANSACTION_DT'] = [i[3:7]+i[0]+i[1:3] for i in c_itcont['TRANSACTION_DT'] ] ","date":"2021-01-01","objectID":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/:2:2","tags":["python","数据分析","pandas","桑基图"],"title":"天池大数据竞赛 Spaceack带你利用Pandas，趋势图与桑基图分析美国选民候选人喜好度","uri":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/"},{"categories":["数据分析","数据可视化"],"content":"绘制收到捐赠额最多的两位候选人的总捐赠额变化趋势图 # 计算每个总统候选人所获得的捐款总额，然后排序，取前二位 c_itcont.groupby(\"CAND_NAME\").sum().sort_values(\"TRANSACTION_AMT\",ascending=False).head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } IMAGE_NUM TRANSACTION_AMT FILE_NUM SUB_ID CAND_NAME BIDEN, JOSEPH R JR 1.025834e+23 68111142.0 7.307496e+11 2.077270e+24 TRUMP, DONALD J. 1.181873e+22 16594982.0 8.417584e+10 2.396038e+23 # 提取需要的数据列 c_itcont0 = pd.DataFrame(c_itcont, columns=[ 'CAND_NAME', 'TRANSACTION_AMT', 'TRANSACTION_DT']) # 已知所获得的捐款总额前两位的总统候选人分别是'BIDEN, JOSEPH R JR', 'TRUMP, DONALD J.'， 筛选出来 c_itcont1 = c_itcont0[c_itcont0['CAND_NAME'].isin(['BIDEN, JOSEPH R JR', 'TRUMP, DONALD J.'])] # 因为同一天会有多笔捐款入帐，需要做分组求和 c_itcont2 = c_itcont1.groupby(['CAND_NAME', 'TRANSACTION_DT']).sum() # 因为我们要看总额的趋势图，所以要做累加 c_itcont3 = c_itcont2.groupby(['CAND_NAME', ]).cumsum() # 现在很快可以达到预期目标了 c_itcont3 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } TRANSACTION_AMT CAND_NAME TRANSACTION_DT BIDEN, JOSEPH R JR 2020722 888622 2020723 1852227 2020724 3024292 2020725 3943847 2020726 5052629 2020727 6150050 2020728 7625248 2020729 8900851 2020730 9964382 2020731 12305972 2020801 13391021 2020802 14208260 2020803 15063070 2020804 16138452 2020805 17317433 2020806 18293448 2020807 19246279 2020808 20152637 2020809 20996972 2020810 22015682 2020811 26905056 2020812 32932121 2020813 38604052 2020814 41666574 2020815 44125928 2020816 46254874 2020817 49826137 2020818 53584270 2020819 58989963 2020820 68111142 TRUMP, DONALD J. 2020722 330603 2020723 554920 2020724 828209 2020725 1035861 2020726 1529042 2020727 2044076 2020728 2499171 2020729 3216022 2020730 4346359 2020731 6338855 2020801 6688166 2020802 6925401 2020803 7273299 2020804 7862177 2020805 8175442 2020806 8501605 2020807 8899471 2020808 9124955 2020809 9404411 2020810 10286254 2020811 10856855 2020812 11540551 2020813 12298919 2020814 12717476 2020815 13483142 2020816 13812398 2020817 14453930 2020818 15086445 2020819 15665254 2020820 16594982 # 整理下排列索引，这里用到了索引和列标题转换与转置操作 c_itcont4 = c_itcont3.unstack().T c_itcont4 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } CAND_NAME BIDEN, JOSEPH R JR TRUMP, DONALD J. TRANSACTION_DT TRANSACTION_AMT 2020722 888622 330603 2020723 1852227 554920 2020724 3024292 828209 2020725 3943847 1035861 2020726 5052629 1529042 2020727 6150050 2044076 2020728 7625248 2499171 2020729 8900851 3216022 2020730 9964382 4346359 2020731 12305972 6338855 2020801 13391021 6688166 2020802 14208260 6925401 2020803 15063070 7273299 2020804 16138452 7862177 2020805 17317433 8175442 2020806 18293448 8501605 2020807 19246279 8899471 2020808 20152637 9124955 2020809 20996972 9404411 2020810 22015682 10286254 2020811 26905056 10856855 2020812 32932121 11540551 2020813 38604052 12298919 2020814 41666574 12717476 2020815 44125928 13483142 2020816 46254874 13812398 2020817 49826137 14453930 2020818 53584270 15086445 2020819 58989963 15665254 2020820 68111142 16594982 绘制收到捐赠额最多的两位候选人的总捐赠额变化趋势图 这里使用 plot 方法绘制趋势图，（由于天池实验室环境不是最新的库，兼容问题会报警告，但是不影响出图。 我在其它环境测试没问题，图的横坐标会有日期显示的。） # grid参数 用来显示后面的辅助网格线， rot 使横坐标的日期以45度排列， 不会导致产生字符过长导致叠加的问题。（由于天池实验室环境不是最新的库，兼容问题会报警告，横坐标的日期标注无法显示。） c_itcont4.plot(grid=True, rot=45) ","date":"2021-01-01","objectID":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/:3:0","tags":["python","数据分析","pandas","桑基图"],"title":"天池大数据竞赛 Spaceack带你利用Pandas，趋势图与桑基图分析美国选民候选人喜好度","uri":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/"},{"categories":["数据分析","数据可视化"],"content":"结论 由趋势图可以看出，在7月22日至8月20日期间，拜登收到的捐款总额明显高于特朗普。且在8月份有更为显著的变化。 ","date":"2021-01-01","objectID":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/:3:1","tags":["python","数据分析","pandas","桑基图"],"title":"天池大数据竞赛 Spaceack带你利用Pandas，趋势图与桑基图分析美国选民候选人喜好度","uri":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/"},{"categories":["数据分析","数据可视化"],"content":"使用桑基图分析美国各州对党派的贡献度 桑基图（Sankey），即桑基能量分流图，是一种高级可视化图形。常用于金融等数据的可视化分析。最明显的特征就是，始末端的分支宽度总和相等，即所有主支宽度的总和应与所有分出去的分支宽度的总和相等，保持能量的平衡。 一个州的捐款额可能会流向不同的党派，用桑基图表示的效果就非常好。可以很清楚看出某个党派的贡献流向。 这里要用到第三方库 pyecharts，用来画桑吉图比较方便，还支持交互式操作（鼠标悬停某条能量线高亮并显示金额数量），首先安装第三方库 !pip install pyecharts --user Looking in indexes: https://mirrors.aliyun.com/pypi/simple Requirement already satisfied: pyecharts in /data/nas/workspace/envs/python3.6/site-packages (1.9.0) Requirement already satisfied: prettytable in /data/nas/workspace/envs/python3.6/site-packages (from pyecharts) (1.0.1) Requirement already satisfied: simplejson in /data/nas/workspace/envs/python3.6/site-packages (from pyecharts) (3.17.2) Requirement already satisfied: jinja2 in /opt/conda/lib/python3.6/site-packages (from pyecharts) (2.11.2) Requirement already satisfied: setuptools in /opt/conda/lib/python3.6/site-packages (from prettytable-\u003epyecharts) (49.6.0) Requirement already satisfied: wcwidth in /opt/conda/lib/python3.6/site-packages (from prettytable-\u003epyecharts) (0.2.5) Requirement already satisfied: MarkupSafe\u003e=0.23 in /opt/conda/lib/python3.6/site-packages (from jinja2-\u003epyecharts) (1.1.1) # 提取需要的数据列 c_itcont5 = pd.DataFrame(c_itcont, columns=[ 'STATE', 'TRANSACTION_AMT', 'CAND_PTY_AFFILIATION']) # 提取党派集合 c_itcont_CAND_PTY_AFFILIATION = pd.DataFrame(c_itcont5,columns=['CAND_PTY_AFFILIATION']) cgc = c_itcont_CAND_PTY_AFFILIATION.groupby('CAND_PTY_AFFILIATION').count() node2 = list(cgc.index) node2 ['BDY', 'CON', 'DEM', 'DFL', 'GRE', 'IND', 'LIB', 'NON', 'NPA', 'OTH', 'REP', 'UNK'] # 提取州集合 c_itcont_STATE = pd.DataFrame(c_itcont5,columns=['STATE']) sgc = c_itcont_STATE.groupby('STATE').count() node1 = list(sgc.index) # 为方便阅读， 引入汉化字典 scp = {'AA': '美洲军', 'AE': '军事地区', 'AK': '阿拉斯加州', 'AL': '阿拉巴马州', 'AP': '太平洋军事机构', 'AR': '阿肯色州', 'AS': '美属萨摩亚群岛', 'AZ': '阿利桑那州', 'CA': '加利福尼亚州', 'CO': '科罗拉多州', 'CT': '康涅狄格州', 'DC': '华盛顿DC', 'DE': '特拉华州', 'FL': '佛罗里达州', 'FM': 'FM联邦', 'GA': '乔治亚州', 'GU': '关岛', 'HI': '夏威夷州', 'IA': '爱荷华州', 'ID': '爱达荷州', 'IL': '伊利诺斯州', 'IN': '印第安纳州', 'KS': '堪萨斯州', 'KY': 'KY', 'LA': '路易斯安那州', 'MA': '马萨诸塞州', 'MD': '马里兰州', 'ME': '缅因州', 'MI': '密歇根州', 'MN': '明尼苏达州', 'MO': '密苏里州', 'MP': 'MP', 'MS': '密西西比州', 'MT': '蒙大拿州', 'NC': '北卡罗来纳州', 'ND': '北达科他州', 'NE': '内布拉斯加州', 'NH': '新罕布什尔州', 'NJ': '新泽西州', 'NM': '新墨西哥州', 'NOT PROVIDED': 'NOT PROVIDED', 'NV': '内华达州', 'NY': '纽约州', 'OH': '俄亥俄州', 'OK': 'OK', 'OR': '俄勒冈州', 'PA': '宾夕法尼亚州', 'PR': 'PR', 'PW': 'PW', 'RI': '罗得岛州', 'SC': '南卡罗来纳州', 'SD': '南达科他州', 'TN': '田纳西州', 'TX': '得克萨斯州', 'UT': '犹他州', 'VA': '弗吉尼亚州', 'VI': 'VI', 'VT': '佛蒙特州', 'WA': '华盛顿州', 'WI': '威斯康辛州', 'WV': '西弗吉尼亚州', 'WY': '怀俄明州', 'ZZ': 'ZZ'} # 将集合加入到节点列表，nodes需要把桑基图中出现的名称全部设置进去，并且要保证links中的名称与name相同 nodes = [] for n in node1: nodes.append({'name': scp[n]}) for n in node2: nodes.append({'name': n}) # 做分组聚合 cgs = c_itcont5.groupby(['STATE','CAND_PTY_AFFILIATION']).sum() # 将聚合结果加入到链接列表， links代表节点关系，source表示起点，target表示终点，需要将节点关系全部输入进去，value表示节点长度 links = [] for row in cgs.iterrows(): links.append({'source': scp[row[0][0]], 'target': row[0][1], 'value': int(row[1][0])}) from pyecharts import options as opts from pyecharts.charts import Page, Sankey sankey = Sankey(init_opts=opts.InitOpts(width=\"1024\", height=\"768\")) #可以设置大小和图标名称 sankey.add( '各州捐款额流向图', #名称 nodes, #输入节点，如果导入json数据，nodes=json['nodes] links, #输入关系,nodes=json['links'] linestyle_opt=opts.LineStyleOpts(opacity=0.3, curve=0.5, color=\"source\", width=10), label_opts=opts.LabelOpts(position=\"right\", is_show=True, color='red'), node_gap=1 ) sankey.render() # 生成的桑基图可通过下方目录查看 '/data/nas/workspace/jupyter/download/render.html' ","date":"2021-01-01","objectID":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/:4:0","tags":["python","数据分析","pandas","桑基图"],"title":"天池大数据竞赛 Spaceack带你利用Pandas，趋势图与桑基图分析美国选民候选人喜好度","uri":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/"},{"categories":["数据分析","数据可视化"],"content":"结论 由各州全款额流向图可以非常快速的得知：加利福尼亚州，纽约州，马萨诸塞州在7月22日至8月20日是对民主党贡献最多的三大州。 佛罗里达州和德克萨斯州对两大党的贡献几乎相同，但更倾向于共和党，也是对共和党贡献较大的两个州。 桑基图会包含很多数据元素，通过桑基图可以探索更多的数据，例如去除两大党的情况和仅比较两大党的情况等等。 ","date":"2021-01-01","objectID":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/:4:1","tags":["python","数据分析","pandas","桑基图"],"title":"天池大数据竞赛 Spaceack带你利用Pandas，趋势图与桑基图分析美国选民候选人喜好度","uri":"/20210101-%E5%A4%A9%E6%B1%A0%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B-%E8%B6%8B%E5%8A%BF%E5%9B%BE%E4%B8%8E%E6%A1%91%E5%9F%BA%E5%9B%BE%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E9%80%89%E6%B0%91%E5%80%99%E9%80%89%E4%BA%BA%E5%96%9C%E5%A5%BD%E5%BA%A6/"},{"categories":["Python","算法","数据可视化"],"content":"今日正值中秋节，是中国民间的传统节日。中秋节自古便有祭月、赏月、吃月饼、玩花灯、赏桂花、饮桂花酒等民俗，流传至今，经久不息。 通过参加 画月饼过云上中秋 Python编程活动以此纪念 完整代码和环境见 Github matplotlib-draw-mooncake , 码字不易，假使该篇文章对您有所帮助，欢迎Star，以资鼓励。 ","date":"2020-10-01","objectID":"/20201001-python%E5%88%A9%E7%94%A8matplotlib%E4%B8%87%E8%8A%B1%E5%B0%BA%E7%94%BB%E6%9C%88%E9%A5%BC/:0:0","tags":["python","matplotlib","hypotrochoid","内旋轮线","题解","艺术"],"title":"Python利用matplotlib万花尺画月饼","uri":"/20201001-python%E5%88%A9%E7%94%A8matplotlib%E4%B8%87%E8%8A%B1%E5%B0%BA%E7%94%BB%E6%9C%88%E9%A5%BC/"},{"categories":["Python","算法","数据可视化"],"content":"绘制原理 利用数学解析几何中的内旋轮线（hypotrochoid），内旋轮线是追踪附着在围绕半径为 R 的固定的圆内侧滚转的半径为 r 的圆上的一个点得到的转迹线，这个点到内部滚动的圆的中心的距离是d。 繁花曲线规（万花尺，万花规）也是应用之一，大小齿轮的齿数之比，约为最简分数时，其分母就是小齿轮的自转数，分母与分子之和就是图案中的花瓣数。而分子就是小齿轮沿着大齿轮的公转数。所以，只要掌握这个最简分数，就能知道画出来的图案大概是什么形状的。总而言之，选择不同的齿轮与不同的孔，就可画出细腻、动人的各种曲线，例如玫瑰线、内摆线等等。 理论上通过玄学调参可以生成无数种图形可能。 示例如下： ","date":"2020-10-01","objectID":"/20201001-python%E5%88%A9%E7%94%A8matplotlib%E4%B8%87%E8%8A%B1%E5%B0%BA%E7%94%BB%E6%9C%88%E9%A5%BC/:1:0","tags":["python","matplotlib","hypotrochoid","内旋轮线","题解","艺术"],"title":"Python利用matplotlib万花尺画月饼","uri":"/20201001-python%E5%88%A9%E7%94%A8matplotlib%E4%B8%87%E8%8A%B1%E5%B0%BA%E7%94%BB%E6%9C%88%E9%A5%BC/"},{"categories":["Python","算法","数据可视化"],"content":"基本步骤 1、首先我们需要导入画图和数据计算的相关库。 import numpy as np from numpy import sin, cos from matplotlib import pyplot as plt from matplotlib.font_manager import FontProperties 2、为了在图片上显示中文，需要先加载Alibaba-PuHuiTi-Medium字体。 wget http://tianchi-media.oss-cn-beijing.aliyuncs.com/DSW/Python/miniproject/01_draw_moon_cake/Alibaba-PuHuiTi-Medium.ttf 3、这里是核心方法，根据数学中内旋轮线（hypotrochoid）参数方程，利用lambd函数生成坐标点： x = lambda d,r,R,theta: (R-r)*np.cos(theta) + d*np.cos(((R-r)/r)*theta) y = lambda d,r,R,theta: (R-r)*np.sin(theta) - d*np.sin(((R-r)/r)*theta) 4、接下来我们要画摆线，摆线是月饼边缘的花纹，首先添加相关参数，参数说明见注释： 这个参数是核心，理论上通过玄学调参可以生成无数种可能。可以尝试发挥。例如用for循环遍历 生成渐变动画～ # 转数-内圆旋转次数 revs = 30 # 迭代次数， 即沿绘制路径获取的点。 Niter = 9999 thetas = np.linspace(0,revs*2*np.pi,num=Niter) d = 2 # 距离 r = 11 # 小圆半径 R = 12 # 大圆半径 5、生成摆线花纹, 可通过color和linewidth参数调整颜色和线宽。 plt.plot(x(d, r, R, thetas), y(d, r, R, thetas), color='orange', linewidth = '4') 6、然后我们再画一个圆，这个圆是月饼的主体部分。 # 画个圆 length = 2.6 theta = np.linspace(0, 2 * np.pi, 100) x = length * cos(theta) y = length * sin(theta) plt.plot(x, y, color='orange', linewidth = '5') plt.axis('equal') 7.绘制文字，使用fontproperties参数可以使用上面下载的中文字体，因为代码不多，所以把剩余所有代码都写在这里： import numpy as np from numpy import sin, cos from matplotlib import pyplot as plt from matplotlib.font_manager import FontProperties x = lambda d,r,R,theta: (R-r)*np.cos(theta) + d*np.cos(((R-r)/r)*theta) y = lambda d,r,R,theta: (R-r)*np.sin(theta) - d*np.sin(((R-r)/r)*theta) # 转数-内圆旋转次数 revs = 30 # 迭代次数， 即沿绘制路径获取的点。 Niter = 9999 thetas = np.linspace(0,revs*2*np.pi,num=Niter) d = 2 # 距离 r = 11 # 小圆半径 R = 12 # 大圆半径 plt.plot(x(d, r, R, thetas), y(d, r, R, thetas), color='orange', linewidth = '4') length = 2.6 # 画个圆 theta = np.linspace(0, 2 * np.pi, 100) x = length * cos(theta) y = length * sin(theta) plt.plot(x, y, color='orange', linewidth = '5') plt.axis('equal') plt.axis('off') # 隐藏坐标系 font_set = FontProperties(fname=r\"Alibaba-PuHuiTi-Medium.ttf\", size=12) plt.text(-1.2, -1, '中秋\\n快乐', bbox=dict(boxstyle='circle', fc=\"w\", ec='orange', linewidth=4), fontproperties=font_set, fontsize=40, color='orange') ##ec为线条颜色，color为字体颜色,可以自由替换 plt.text(-3, -4, 'Python画月饼，Spaceack与您千里共禅娟', fontproperties=font_set, fontsize=20, color='#aa4a30') plt.show() ","date":"2020-10-01","objectID":"/20201001-python%E5%88%A9%E7%94%A8matplotlib%E4%B8%87%E8%8A%B1%E5%B0%BA%E7%94%BB%E6%9C%88%E9%A5%BC/:2:0","tags":["python","matplotlib","hypotrochoid","内旋轮线","题解","艺术"],"title":"Python利用matplotlib万花尺画月饼","uri":"/20201001-python%E5%88%A9%E7%94%A8matplotlib%E4%B8%87%E8%8A%B1%E5%B0%BA%E7%94%BB%E6%9C%88%E9%A5%BC/"},{"categories":["Python","算法","数据可视化"],"content":"图形预览 异形月饼： 弦月饼 魔法月饼 花环月饼 太阳月饼 改良月饼 向日葵月饼 丝绒月饼 我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=vehbofwukikz ","date":"2020-10-01","objectID":"/20201001-python%E5%88%A9%E7%94%A8matplotlib%E4%B8%87%E8%8A%B1%E5%B0%BA%E7%94%BB%E6%9C%88%E9%A5%BC/:3:0","tags":["python","matplotlib","hypotrochoid","内旋轮线","题解","艺术"],"title":"Python利用matplotlib万花尺画月饼","uri":"/20201001-python%E5%88%A9%E7%94%A8matplotlib%E4%B8%87%E8%8A%B1%E5%B0%BA%E7%94%BB%E6%9C%88%E9%A5%BC/"},{"categories":["数据库","分布式"],"content":"介绍 etcd 是一个分布式、可靠的键值存储数据库，用于收集分布式系统中最关键的数据。是k8s的组件之一，使用Raft一致性算法，为分布式系统而生。常用做服务发现和配置共享等应用场景。 可以使用protobuf定义的接口来进行开发，这里使用更易测试验证的第三方python库etcd3举例。 这里需要注意的一点是：“ raft算法写入时需要半数以上的节点写入成功才返回，宕机节点不超过半数则数据不丢失。” 即： 3个节点的集群，1个节点宕机无妨。但两个节点宕机后，即使另一个节点存活也无法读取数据！。四个节点集群也是两个节点宕机后，无法工作。5个节点则允许两个节点宕机。满足公式quorum=(n+1)/2。所以建议奇数的集群节点。因为奇数和偶数的可靠性一样，单可以节省1个节点的资源。 ","date":"2021-05-27","objectID":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/:1:0","tags":["etcd","Docker","docker-compose","python"],"title":"搭建etcd分布式kv数据库集群并使用python操作","uri":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/"},{"categories":["数据库","分布式"],"content":"下载与安装 etcd 下载 etcd v3.4 文档 ","date":"2021-05-27","objectID":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/:2:0","tags":["etcd","Docker","docker-compose","python"],"title":"搭建etcd分布式kv数据库集群并使用python操作","uri":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/"},{"categories":["数据库","分布式"],"content":"简单测试 # 运行 ./etcd # etcd put 命令用于设置给定 key 的值。如果 key 已经存储其他值， put 就覆写旧值. ./etcdctl put greeting \"Hello, etcd\" # 通过key获取value ./etcdctl get greeting # 删除 kv ./etcdctl del greeting ","date":"2021-05-27","objectID":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/:2:1","tags":["etcd","Docker","docker-compose","python"],"title":"搭建etcd分布式kv数据库集群并使用python操作","uri":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/"},{"categories":["数据库","分布式"],"content":"使用docker-compose组建4节点集群。 docker-compose.yaml version:'2'networks:byfn:services:etcd1:image:quay.io/coreos/etcdcontainer_name:etcd1command:etcd -name etcd1 -advertise-client-urls http://0.0.0.0:2379 -listen-client-urls http://0.0.0.0:2379 -listen-peer-urls http://0.0.0.0:2380 -initial-cluster-token etcd-cluster -initial-cluster \"etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380,etcd4=http://etcd4:2380\" -initial-cluster-state newports:- 2385:2379- 2380networks:- byfnetcd2:image:quay.io/coreos/etcdcontainer_name:etcd2command:etcd -name etcd2 -advertise-client-urls http://0.0.0.0:2379 -listen-client-urls http://0.0.0.0:2379 -listen-peer-urls http://0.0.0.0:2380 -initial-cluster-token etcd-cluster -initial-cluster \"etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380,etcd4=http://etcd4:2380\" -initial-cluster-state newports:- 2386:2379- 2380networks:- byfnetcd3:image:quay.io/coreos/etcdcontainer_name:etcd3command:etcd -name etcd3 -advertise-client-urls http://0.0.0.0:2379 -listen-client-urls http://0.0.0.0:2379 -listen-peer-urls http://0.0.0.0:2380 -initial-cluster-token etcd-cluster -initial-cluster \"etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380,etcd4=http://etcd4:2380\" -initial-cluster-state newports:- 2387:2379- 2380networks:- byfnetcd4:image:quay.io/coreos/etcdcontainer_name:etcd4command:etcd -name etcd4 -advertise-client-urls http://0.0.0.0:2379 -listen-client-urls http://0.0.0.0:2379 -listen-peer-urls http://0.0.0.0:2380 -initial-cluster-token etcd-cluster -initial-cluster \"etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380,etcd4=http://etcd4:2380\" -initial-cluster-state newports:- 2388:2379- 2380networks:- byfn 运行 docker-compose up 即可 ","date":"2021-05-27","objectID":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/:2:2","tags":["etcd","Docker","docker-compose","python"],"title":"搭建etcd分布式kv数据库集群并使用python操作","uri":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/"},{"categories":["数据库","分布式"],"content":"使用虚拟机组建4节点集群。 4个虚拟机分别运行以下命令： # 虚拟机1 192.168.0.156 ./etcd --name infra0 --initial-advertise-peer-urls http://192.168.0.156:2380 \\ --listen-peer-urls http://192.168.0.156:2380 \\ --listen-client-urls http://192.168.0.156:2379,http://127.0.0.1:2379 \\ --advertise-client-urls http://192.168.0.156:2379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster infra0=http://192.168.0.156:2380,infra1=http://192.168.0.157:2380,infra2=http://192.168.0.158:2380,infra3=http://192.168.0.159:2380 \\ --initial-cluster-state new # 虚拟机2 192.168.0.157 ./etcd --name infra1 --initial-advertise-peer-urls http://192.168.0.157:2380 \\ --listen-peer-urls http://192.168.0.157:2380 \\ --listen-client-urls http://192.168.0.157:2379,http://127.0.0.1:2379 \\ --advertise-client-urls http://192.168.0.157:2379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster infra0=http://192.168.0.156:2380,infra1=http://192.168.0.157:2380,infra2=http://192.168.0.158:2380,infra3=http://192.168.0.159:2380 \\ --initial-cluster-state new # 虚拟机3 192.168.0.158 etcd --name infra2 --initial-advertise-peer-urls http://192.168.0.158:2380 \\ --listen-peer-urls http://192.168.0.158:2380 \\ --listen-client-urls http://192.168.0.158:2379,http://127.0.0.1:2379 \\ --advertise-client-urls http://192.168.0.158:2379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster infra0=http://192.168.0.156:2380,infra1=http://192.168.0.157:2380,infra2=http://192.168.0.158:2380,infra3=http://192.168.0.159:2380 \\ --initial-cluster-state new # 虚拟机4 192.168.0.159 etcd --name infra3 --initial-advertise-peer-urls http://192.168.0.159:2380 \\ --listen-peer-urls http://192.168.0.159:2380 \\ --listen-client-urls http://192.168.0.159:2379,http://127.0.0.1:2379 \\ --advertise-client-urls http://192.168.0.159:2379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster infra0=http://192.168.0.156:2380,infra1=http://192.168.0.157:2380,infra2=http://192.168.0.158:2380,infra3=http://192.168.0.159:2380 \\ --initial-cluster-state new ","date":"2021-05-27","objectID":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/:2:3","tags":["etcd","Docker","docker-compose","python"],"title":"搭建etcd分布式kv数据库集群并使用python操作","uri":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/"},{"categories":["数据库","分布式"],"content":"python etcd3 库测试 安装 pip3 install etcd3 etcd3文档 import etcd3 # 建立连接 etcd = etcd3.client(host='127.0.0.1', port=2379) # 添加 kv result = etcd.put('greeting', 'hello, world!') \"\"\" header { cluster_id: 14841639068965178418 member_id: 10276657743932975437 revision: 16 raft_term: 5 } \"\"\" # 根据 key 获得 value result = etcd.get('greeting') # 不存在 (None, None); 存在(b'hello, world!', \u003cetcd3.client.KVMetadata object at 0x7ffbf072de80\u003e) rv = result[0].decode() if result[0] else result[0] # 取解析后的值 # 删除某个 key result = etcd.delete('greeting') # 成功删除 True， 不存在，删除失败 False # 返回满足前缀 key 的 value objs = etcd.get_prefix(\"server1\") result = [obj[0].decode() if obj[0] else obj[0] for obj in objs] # 获取所有的 key的 value objs = etcd.get_all() result = [obj[0].decode() if obj[0] else obj[0] for obj in objs] ","date":"2021-05-27","objectID":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/:3:0","tags":["etcd","Docker","docker-compose","python"],"title":"搭建etcd分布式kv数据库集群并使用python操作","uri":"/20210527-%E6%90%AD%E5%BB%BAetcd%E5%88%86%E5%B8%83%E5%BC%8Fkv%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%B9%B6%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"MariaDB双主模式测试 ","date":"2021-02-22","objectID":"/20210222-%E4%BD%BF%E7%94%A8docker%E6%A8%A1%E6%8B%9F%E5%8F%8C%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95mysql%E5%8F%8C%E6%9C%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E5%A4%87/:1:0","tags":["MariaDB","mysql","Docker","docker-compose"],"title":"使用docker模拟双机环境测试mysql双机互为主备","uri":"/20210222-%E4%BD%BF%E7%94%A8docker%E6%A8%A1%E6%8B%9F%E5%8F%8C%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95mysql%E5%8F%8C%E6%9C%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E5%A4%87/"},{"categories":["数据库"],"content":"1. 环境准备 创建目录 mkdir conf conf2 data data2 log log2 创建 MariaDB 配置文件 touch conf/my.cnf conf2/my.cnf conf/my.cnf文件 # The MariaDB configuration file # # The MariaDB/MySQL tools read configuration files in the following order: # 0. \"/etc/mysql/my.cnf\" symlinks to this file, reason why all the rest is read. # 1. \"/etc/mysql/mariadb.cnf\" (this file) to set global defaults, # 2. \"/etc/mysql/conf.d/*.cnf\" to set global options. # 3. \"/etc/mysql/mariadb.conf.d/*.cnf\" to set MariaDB-only options. # 4. \"~/.my.cnf\" to set user-specific options. # # If the same option is defined multiple times, the last one will apply. # # One can use all long options that the program supports. # Run program with --help to get a list of available options and with # --print-defaults to see which it would actually understand and use. # # If you are new to MariaDB, check out https://mariadb.com/kb/en/basic-mariadb-articles/ # # This group is read both by the client and the server # use it for options that affect everything # [client-server] # Port or socket location where to connect # port = 3306 socket = /run/mysqld/mysqld.sock # Import all .cnf files from configuration directory !includedir /etc/mysql/conf.d/ !includedir /etc/mysql/mariadb.conf.d/ [mysqld] server-id=1 log-bin=mysql-bin binlog_format = mixed binlog-do-db=event_analysis binlog-ignore-db =mysql binlog-ignore-db =information_schema binlog-ignore-db =performance_schema replicate-do-db=event_analysis replicate-ignore-db=mysql replicate-ignore-db=information_schema replicate-ignore-db=performance_schema read-only=0 relay_log=mysqld-relay-bin log-slave-updates=ON auto-increment-increment = 2 auto-increment-offset = 1 conf/my.cnf文件 # The MariaDB configuration file # # The MariaDB/MySQL tools read configuration files in the following order: # 0. \"/etc/mysql/my.cnf\" symlinks to this file, reason why all the rest is read. # 1. \"/etc/mysql/mariadb.cnf\" (this file) to set global defaults, # 2. \"/etc/mysql/conf.d/*.cnf\" to set global options. # 3. \"/etc/mysql/mariadb.conf.d/*.cnf\" to set MariaDB-only options. # 4. \"~/.my.cnf\" to set user-specific options. # # If the same option is defined multiple times, the last one will apply. # # One can use all long options that the program supports. # Run program with --help to get a list of available options and with # --print-defaults to see which it would actually understand and use. # # If you are new to MariaDB, check out https://mariadb.com/kb/en/basic-mariadb-articles/ # # This group is read both by the client and the server # use it for options that affect everything # [client-server] # Port or socket location where to connect # port = 3306 socket = /run/mysqld/mysqld.sock # Import all .cnf files from configuration directory !includedir /etc/mysql/conf.d/ !includedir /etc/mysql/mariadb.conf.d/ [mysqld] server-id=2 log-bin=mysql-bin binlog_format = mixed binlog-do-db=event_analysis binlog-ignore-db =mysql binlog-ignore-db =information_schema binlog-ignore-db =performance_schema replicate-do-db=event_analysis replicate-ignore-db=mysql replicate-ignore-db=information_schema replicate-ignore-db=performance_schema read-only=0 relay_log=mysqld-relay-bin log-slave-updates=ON auto-increment-increment = 2 auto-increment-offset = 1 使用 docker 启动两个 MariaDB 容器 bak1 和 bak2 。使用 docker-compose up 启动容器。 version:'2'services:\"mariadb\":image:mariadb:10.5.5container_name:\"bak1\"restart:alwaysenvironment:MYSQL_USER:\"root\"MYSQL_PASSWORD:\"123456\"MYSQL_ROOT_PASSWORD:\"123456\"TZ:\"Asia/Shanghai\"ports:- \"3307:3306\"volumes:- ./data:/var/lib/mysql- ./log:/var/log/mysql- ./conf/my.cnf:/etc/mysql/my.cnfnetworks:mysql_bak_net:\"mariadb2\":image:mariadb:10.5.5container_name:\"bak2\"restart:alwaysenvironment:MYSQL_USER:\"root\"MYSQL_PASSWORD:\"123456\"MYSQL_ROOT_PASSWORD:\"123456\"TZ:\"Asia/Shanghai\"ports:- \"3308:3306\"volumes:- ./data2:/var/lib/mysql- ./log2:/var/log/mysql- ./conf2/my.cnf:/etc/mysql/my.cnfnetworks:mysql_bak_net:networks:mysql_bak_net: ","date":"2021-02-22","objectID":"/20210222-%E4%BD%BF%E7%94%A8docker%E6%A8%A1%E6%8B%9F%E5%8F%8C%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95mysql%E5%8F%8C%E6%9C%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E5%A4%87/:1:1","tags":["MariaDB","mysql","Docker","docker-compose"],"title":"使用docker模拟双机环境测试mysql双机互为主备","uri":"/20210222-%E4%BD%BF%E7%94%A8docker%E6%A8%A1%E6%8B%9F%E5%8F%8C%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95mysql%E5%8F%8C%E6%9C%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E5%A4%87/"},{"categories":["数据库"],"content":"2. 操作步骤 容器名 bak1 bak2 ip 172.24.0.3 172.24.0.2 user root root password 123456 123456 server-id 1 2 进入容器 docker exec -it bak1 bash docker exec -it bak2 bash 进入sql mysql -u root -p mysql -u root -p 查看master状态 show master status\\G; File: mysql-bin.000003 Position: 328 Binlog_Do_DB: event_analysis Binlog_Ignore_DB: mysql,information_schema,performance_schema show master status\\G; File: mysql-bin.000003 Position: 328 Binlog_Do_DB: event_analysis Binlog_Ignore_DB: mysql,information_schema,performance_schema 主从复制 CHANGE MASTER TO MASTER_HOST=‘172.24.0.2’, MASTER_USER=‘root’, MASTER_PASSWORD=‘123456’, MASTER_LOG_FILE=‘mysql-bin.000003’, MASTER_LOG_POS=328; CHANGE MASTER TO MASTER_HOST=‘172.24.0.3’, MASTER_USER=‘root’, MASTER_PASSWORD=‘123456’, MASTER_LOG_FILE=‘mysql-bin.000003’, MASTER_LOG_POS=328; 查看slave状态 show slave status\\G; show slave status\\G; 重启MariaDB 查看slave状态 show slave status\\G; show slave status\\G; 验证 在bak1中创建表，更新数据，bak2也会更新。 在bak2中创建表，更新数据，bak1也会更新。 ","date":"2021-02-22","objectID":"/20210222-%E4%BD%BF%E7%94%A8docker%E6%A8%A1%E6%8B%9F%E5%8F%8C%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95mysql%E5%8F%8C%E6%9C%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E5%A4%87/:2:0","tags":["MariaDB","mysql","Docker","docker-compose"],"title":"使用docker模拟双机环境测试mysql双机互为主备","uri":"/20210222-%E4%BD%BF%E7%94%A8docker%E6%A8%A1%E6%8B%9F%E5%8F%8C%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95mysql%E5%8F%8C%E6%9C%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E5%A4%87/"},{"categories":["生活"],"content":"自惜别年终，相约从容，庆元夜之火红，守佳节之欢融。 奈何疫情冲冲，来势汹汹，似山海之相隔，如日月之无穷。 纵牵念之深重，为时势之摆弄。 然风起纸鸢，牵牵不断，且思且盼，情意绵绵。 今困于孤岛，无缘相见，仍遥寄惦念，千里婵娟。 愿危局之和缓，期苍生之平安。 待春花烂漫，举国言欢，定不负诺言，携手并肩。 赏旧时之河山，复一往之缱绻。 ","date":"2020-02-19","objectID":"/20200219-%E6%83%85%E4%BA%BA%E8%8A%82%E9%81%A5%E5%AF%84/:0:0","tags":["poem","情感","love"],"title":"情人节遥寄","uri":"/20200219-%E6%83%85%E4%BA%BA%E8%8A%82%E9%81%A5%E5%AF%84/"},{"categories":["生活"],"content":"靠近爱人 我想你，当阳光洒落海面，如同你在我心中激起涟漪。 我想你，当月光映入清泉，如同你在我脑海留下足迹。 我看到你， 当朦胧的尘埃飞舞在遥远的山脊， 当流浪的行人徘徊于小桥的沉寂。 我听到你， 当巨浪翻腾发出声声喘息， 当夜幕低垂山林归于静寂。 我就在你身边， 即使相隔万水千山， 你依旧与我相伴。 日升月落，群星闪烁。 望余生悠长，携手而过。 ","date":"2020-02-14","objectID":"/20200214-%E9%9D%A0%E8%BF%91%E7%88%B1%E4%BA%BA/:0:0","tags":["poem","love","情感","为你读诗"],"title":"靠近爱人","uri":"/20200214-%E9%9D%A0%E8%BF%91%E7%88%B1%E4%BA%BA/"},{"categories":["生活"],"content":"牵起你的手， 我们十指相扣。 看着你涨红的脸庞， 我没有言由。 牵着你的手， 我们在林荫道下漫游。 望着你忽闪波动的目光， 我的灵在颤抖。 牵着你的手， 我知道你在我的身后。 突然一个转身， 去吻着你的双眸。 丸子， 在未来的二百个年头， 请让我牵着你的手， 给你我的温柔。 ","date":"2019-11-05","objectID":"/20191105-%E7%89%B5%E7%9D%80%E4%BD%A0%E7%9A%84%E6%89%8B/:0:0","tags":["poem","情感","love"],"title":"牵着你的手","uri":"/20191105-%E7%89%B5%E7%9D%80%E4%BD%A0%E7%9A%84%E6%89%8B/"},{"categories":["生活"],"content":"回眸相识，似轻舟之聚于江洋，飞鸟之遇于穹苍。 若非缘起一方，则无来日悠长。 至于相知，则并肩携手，逍遥同游。 惠风和畅，尤见山水青秀， 烈日灼心，愈闻草木清幽。 一饮一食，皆怡然同乐， 一嘻一笑，俱互为应和。 而至絮语依依，难诉分离。 然阡陌相隔，无以常伴，又案牍劳形，须臾言欢。 常自梦萦魂牵，神思惦念。 惦君身之平安无恙，念万千思绪，无从传递，故暂遣书信，简以寄之。 值七夕良辰，愿两情缱绻，岁月长安。 ","date":"2019-08-07","objectID":"/20190807-%E4%B8%83%E5%A4%95%E7%9A%84%E7%A4%BC%E7%89%A9/:0:0","tags":["poem","情感","love"],"title":"七夕收到的礼物","uri":"/20190807-%E4%B8%83%E5%A4%95%E7%9A%84%E7%A4%BC%E7%89%A9/"},{"categories":["生活"],"content":"我如何爱你？我细数心迹。 我爱你直至灵魂边际，如同寻求梦幻的恩典，存在的意义。 我爱你直至日常所需，无可代替，如同暖阳星光，照亮天地。 我爱你以自由，如同为正义战斗。 我爱你以纯粹，如同为赞扬垂首。 我爱你，以我童年的信念，与旧时苦难里不曾颓唐的热情守候。 我爱你，以我误以为早已消逝的虔诚。 我爱你， 以我的呼吸，我的欢笑，我的泪水，以及我生命的全部意义。 如果可以，即使死亡带来分离，我的爱永不言弃。 ","date":"2019-07-16","objectID":"/20190716-%E6%88%91%E5%A6%82%E4%BD%95%E7%88%B1%E4%BD%A0/:0:0","tags":["poem","love","情感","为你读诗"],"title":"我如何爱你","uri":"/20190716-%E6%88%91%E5%A6%82%E4%BD%95%E7%88%B1%E4%BD%A0/"},{"categories":["生活"],"content":"如果没有你, 我的灵魂漫无目的。 如果没有你, 我的情感无处传递。 我将是， 一张僵硬枯槁的脸庞， 一颗停止跳动的心脏， 一丝丧失了温度的微弱火光。 若你是我眼中泪滴, 未免受分离，我将永不哭泣。 若金色阳光敛去锋芒，只需你微笑模样，我的世界依旧明亮。 若我陷入情网，我愿被锁在你的心上， 你的臂膀,你的脸庞,你包含深情的目光， 你的一切,让我的心辗转彷徨。 所以， 若我陷入情网， 你就是那根根丝线，绕我心房。 ","date":"2019-06-14","objectID":"/20190614-%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E4%BD%A0/:0:0","tags":["poem","love","情感","为你读诗"],"title":"如果没有你","uri":"/20190614-%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E4%BD%A0/"},{"categories":["Python"],"content":"赛题介绍 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/:1:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-10仿射加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战介绍 仿射密码结合了移位密码和乘数密码的特点，是一种替换密码。它是利用加密函数一个字母对一个字母的加密。加密函数是 y=ax+b(mod m) ，且 a,b∈Zm （a、b 的值在 m 范围内），且 a、m 互质。 m 是字符集的大小，例如以 26 个字母作为编码，则 m=26 时，a 只能是 1、3、5、7、9、11、15、17、19、21、23、25 其中之一，b 为 0-25 之间的一个值，包括 0 和 25。 当 m=26 时字母与数字对照表如下： a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 例如明文为：welcome 参数取值：m = 26，a = 5，b = 8 加密如下： 明文 w e l c o m e x 22 4 11 2 14 12 4 y=5x+8 118 28 63 18 78 68 28 y mod 26 14 2 11 18 0 16 2 密文 o c l s a q c ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/:1:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-10仿射加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战目标 补充文件 affine.py 下 affine_encryption(text) 函数中的 TODO 部分，使其实现我们需要的功能： 输入一段文本，使用 y=5x+8(mod 26) 函数加密，并将密文返回。 只对输入文本中的半角英文字符加密，其它内容保持不变。 将文本中的半角英文字母全部转换为小写，再进行加密计算，返回的密文中半角字母应全部是小写。 如果输入的文本中没有内容，则返回 None 。 def affine_encryption(text: str) -\u003e str: \"\"\"TODO \"\"\" encryption_text : str = '' return encryption_text ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/:1:2","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-10仿射加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战要求 题目需使用 Python3 完成，不能使用标准库和第三方库。 函数传入的 text 为字符串类型，可能为空、 None 等值。 不得修改文件路径、文件名 affine.py 以及函数名 affine_encryption(text) 。 请只保留文件 affine.py 及文件中函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3 affine.py 命令调用 Python3。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/:1:3","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-10仿射加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"参考样例 # 样例 1 text = \"welcome\"; encryption_text = \"oclsaqc\" # 样例 2 text = \"welcome 你好\"; encryption_text = \"oclsaqc 你好\" # 样例 3 text = \" welcome\"; encryption_text = \" oclsaqc\" # 样例 4 text = \" Ｑｒwe\"; encryption_text = \"Ｑｒoc\" # 样例 5 text = None; encryption_text = None 注意：最终实现效果以完全满足要求为准，而不是仅满足如上样例。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/:1:4","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-10仿射加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"题解 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/:2:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-10仿射加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"解题思路 要注意对传入参数类型与长度检查。 使用index获取字母的下标，以对应字母对照表 最后使用join方法将列表拼接为字符串返回即可。 def affine_encryption(text: str) -\u003e str: \"\"\"TODO \"\"\" def c(x): y = 5 * x + 8 return y % 26 upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" low = \"abcdefghijklmnopqrstuvwxyz\" lower_text = [] if not isinstance(text, str): return None if text == \"\" or text == None: return None for t in text: if t in upper: num = c(low.index(t.lower())) lower_text.append(low[num]) else: if t in low: num = c(low.index(t)) lower_text.append(low[num]) else: lower_text.append(t) encryption_text : str = ''.join(lower_text) return encryption_text 题目来源：蓝桥 仿射加密 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/:2:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-10仿射加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA10%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"赛题介绍 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/:1:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-09凯撒加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战介绍 恺撒密码也称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。采用的是替换方法对信息中的英文字符循环替换为字母表序列中该字符后面或前面的第 N 个字符。例如当 N = 2 时，所有的字母 A 都会被替换成 C，B 替换成 D，以此类推。即字母表的对照关系如下： 原文：ABCDEFGHIJKLMNOPQRSTUVWXYZ 密文：CDEFGHIJKLMNOPQRSTUVWXYZAB ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/:1:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-09凯撒加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战目标 补充文件 caesar_cipher.py 下 caesar_encryption(text) 函数中的 TODO 部分，使其实现我们需要的功能： 输入一段字符串，将字符串中所有英文字符向后偏移 2 位。 只对半角英文字符进行转换，其它内容保持不变。 字符大小写保持不变，例如 A 转换后为 C，b 转换后为 d。 def caesar_encryption(text: str) -\u003e str: \"\"\"TODO \"\"\" encryption_text : str = '' return encryption_text ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/:1:2","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-09凯撒加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战要求 题目需使用 Python3 完成，不能使用标准库和第三方库。 函数传入 text 为字符串类型，可能为空、 None 等值。 不得修改文件路径、文件名 caesar_cipher.py 以及函数名 caesar_encryption(text) 。 请只保留文件 caesar_cipher.py 及文件中函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3 caesar_cipher.py 命令调用 Python3。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/:1:3","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-09凯撒加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"参考样例 # 样例 1 text = \"python\"; encryption_text = \"ravjqp\" # 样例 2 text = \"pyThon\"; encryption_text = \"raVjqp\" # 样例 3 text = \"Python31\"; encryption_text = \"Ravjqp31\" # 样例 4 text = \"Python 您好！\"; encryption_text = \"Ravjqp 您好！\" # 样例 5 text = None; encryption_text = None 注意：最终实现效果以完全满足要求为准，而不是仅满足如上样例。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/:1:4","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-09凯撒加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"题解 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/:2:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-09凯撒加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"解题思路 要注意对传入参数类型与长度检查。 因为字母有序，使用chr和ord对字符移位操作。 最后使用join方法将列表拼接为字符串返回即可。 def caesar_encryption(text: str) -\u003e str: \"\"\"TODO \"\"\" result = [] upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" low = \"abcdefghijklmnopqrstuvwxyz\" if not isinstance(text, str): return None if text == \"\" or text == None: return None for t in text: if t in upper: if t == 'Y': result.append('A') elif t == 'Z': result.append('B') else: result.append(chr(ord(t)+2)) elif t in low: if t == 'y': result.append('a') elif t == 'z': result.append('b') else: result.append(chr(ord(t)+2)) else: result.append(t) encryption_text : str = ''.join(result) return encryption_text 题目来源：蓝桥 凯撒加密 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/:2:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-09凯撒加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA09%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"赛题介绍 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/:1:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-08列置换加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战介绍 列置换加密是明文以每行固定字数（key 的字母种类数，一般情况下 key 会选择字母不重复的单词）一行一行写下，如果最后一行字数小于每行的固定字数，则使用特殊符号补充，这样就形成了一个矩阵。然后依照 key 的字母顺序对矩阵列的位置进行调整，最后再将排列好的列依次读取，得到密文。例如： 明文： welcometolq key： qiao 补充字符： , 首先确定 qiao 有 4 个字母，长度为 4。然后按照 26 个英文字母的顺序对 qiao 进行编号，越靠前的字母编号越小，可以得到的编号依次是 4-2-1-3。 然后对明文分行。每行 4 （key 的长度）个字母，则可以写成 4 列： 1 2 3 4 w e l c o m e t o l q , 由于最后一行缺一个字母，就使用补充字符填充。 最后根据 key 的编号顺序对矩阵的列顺序调整，就有： 4 2 1 3 c e w l t m o e , l o q 然后一列一列地依次读取内容，就得到密文：ct,emlwooleq 解密的方式和加密时的顺序相反，通过字母总数和 key 的长度获得列数，其次根据列数将密文一列一列地展开，然后通过 key 的编号顺序调整列位置，最后一行一行读取内容就可以得到明文。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/:1:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-08列置换加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战目标 补充文件 column_permutation.py 下 column_permutation_encryption(text) 函数中的 TODO 部分，使其实现我们需要的功能： 输入一段文本，使用 key： qiao 和补充字符： , （英文逗号）对内容进行列置换加密，并将密文返回。 如果输入的文本中没有内容，则返回 None 。 def column_permutation_encryption(text: str) -\u003e str: \"\"\"TODO \"\"\" encryption_text : str = '' return encryption_text ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/:1:2","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-08列置换加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战要求 题目需使用 Python3 完成，不能使用标准库和第三方库。 函数传入的 text 为字符串类型，可能为空、 None 等值。 不得修改文件路径、文件名 column_permutation.py 以及函数名 column_permutation_encryption(text) 。 请只保留文件 column_permutation.py 及文件中函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3 column_permutation.py 命令调用 Python3。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/:1:3","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-08列置换加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"参考样例 # 样例 1 text = \"welcometolq\"; encryption_text = \"ct,emlwooleq\" # 样例 2 text = \"welcometolq \"; encryption_text = \"ct emlwooleq\" # 样例 3 text = \"w\"; encryption_text = \",,w,\" # 样例 4 text = None; encryption_text = None 注意：最终实现效果以完全满足要求为准，而不是仅满足如上样例。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/:1:4","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-08列置换加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"题解 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/:2:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-08列置换加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"解题思路 简单的模拟题 要注意对传入参数类型与长度检查。 使用ljust方法补全 , 号 最后使用join方法将列表拼接为字符串返回即可。 def column_permutation_encryption(text: str) -\u003e str: \"\"\"TODO \"\"\" if not isinstance(text, str): return None result = [] key_len = 4 text_len = len(text) if text_len \u003c= 0: return None non_blank = text.replace(' ','') if len(non_blank) == 0: return None col_index = [3, 1, 0, 2] nums = 0 if text_len % 4 == 0 else len(text) + key_len - len(text) % key_len text = text.ljust(nums,',') matrix = [text[i:i+key_len] for i in range(0,len(text), key_len)] for col in col_index: for i, _ in enumerate(matrix): result.append(matrix[i][col]) encryption_text : str = ''.join(result) return encryption_text 题目来源：蓝桥 列置换加密 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/:2:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-08列置换加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA08%E5%88%97%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"赛题介绍 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/:1:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-07明码加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战介绍 清末，电报技术进入中国。上海大北水线电报公司在 1871 年选用了六千八百九十七个汉字，代以四码数字，编写成了中国最早的电报明码本。为了传输的内容可以保密，又设计出了将明码本加密的方法，于是就有了比较复杂的密码。后来，这种加密技术被应用在军事和商业情报机构中。 加密的具体方法是：例如“布”这个字的电报电码为 1530，加密和减密的钥匙均为 9853。先用明码的四个数字分别与加密钥匙的四个数字相加，例如第一位数相加 1 + 9 = 10 ，凡 10 都作 0 ；第二位数相加 5 + 8 = 13 ，隐去 10，只作 3 ；第三位数相加 3 + 5 = 8 ；第四位数相加（如果是 0，则作 10 ） 10 + 3 = 13 ，隐去 10，只作 3 。那么“布”的明码 1530 就成了密码 0383。解密时相反，使用密码减去解密钥匙的四个数字，即可获得明码，从而找到对应的文字。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/:1:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-07明码加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战目标 补充文件 plain_code.py 下 plain_code_encryption(numb) 函数中的 TODO 部分，使其实现我们需要的功能： 输入一个 0 - 9999 （包含 0 和 9999）之间的任意数，然后加上 9853，相加之后得到一个 4 位数（str 格式）并返回。 如果传入的数字不足 4 位，则缺失位置以 0 填补。例如输入数字为 32，则需要当作 0032。 相同位置的数字进行相加，如果相加之后大于等于 10，则隐去 10，只保留个位位置的数字。 如果输入的数字不在 0 - 9999 之间，则返回 None 。 def plain_code_encryption(numb: int) -\u003e str: \"\"\"TODO \"\"\" encryption_text : str = '' return encryption_text ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/:1:2","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-07明码加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战要求 题目需使用 Python3 完成，不能使用标准库和第三方库。 函数传入 numb 为整型类型，可能为 -1、11111 等值。 不得修改文件路径、文件名 plain_code.py 以及函数名 plain_code_encryption(numb) 。 请只保留文件 plain_code.py 及文件中函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3 plain_code.py 命令调用 Python3。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/:1:3","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-07明码加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"参考样例 # 样例 1 numb = 1530; encryption_text = \"0383\" # 样例 2 numb = 0; encryption_text = \"9853\" # 样例 3 numb = 12345; encryption_text = None 注意：最终实现效果以完全满足要求为准，而不是仅满足如上样例。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/:1:4","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-07明码加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"题解 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/:2:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-07明码加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"解题思路 简单的模拟题 要注意对传入参数长度的检查。 利用模运算符进行取余运算获取余数。 最后使用join方法将列表拼接为字符串返回即可。 def plain_code_encryption(numb: int) -\u003e str: \"\"\"TODO \"\"\" result = [] crypt = \"9853\" if not 0 \u003c= int(numb) \u003c=9999: return None str_numb = str(numb) str_numb = str_numb.rjust(4,'0') for index, value in enumerate(str_numb): if (int(value) + int(crypt[index])) \u003c 10: result.append(str(int(value) + int(crypt[index]))) else: result.append(str((int(value) + int(crypt[index])) % 10)) encryption_text : str = ''.join(result) return encryption_text 题目来源：蓝桥 明码加密 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/:2:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-07明码加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA07%E6%98%8E%E7%A0%81%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"赛题介绍 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/:1:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-06姜子牙阴书加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战介绍 姜子牙阴书密码是将一封完整的书信分割成三份，然后由三个送信者各送一份，收信人收到三份书信后再合并成一封完整的情报。如此，即使某个信使被敌军抓获，敌军也不会获得完整的情报。 但是如果三个送信者被同时抓获，敌军还是可以获取完整的情报。因此在古代匮乏的条件之下，可以通过增加送信者的数量将书信分割成更多份传递，减少情报泄密的机率。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/:1:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-06姜子牙阴书加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战目标 补充文件 yin_book.py 下 yin_book_encryption(text) 函数中的 TODO 部分，使其实现我们需要的功能： 输入一段文本内容，将内容分成若干份，第一份内容字数为 1，第二份内容字数为 1 + 2，第三份内容字数为 1 + 2 + 3，第 n 份内容字数为 1 + 2 + 3 + ... + n，以此类推，至止内容被分完。最后按照划分的顺序，以列表的形式将内容返回。 如果输入的文本没有内容，则返回 None。 一个空格也占据一个文字。 def yin_book_encryption(text: str) -\u003e list: \"\"\"TODO \"\"\" encryption_text : list = [] return encryption_text ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/:1:2","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-06姜子牙阴书加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战要求 题目需使用 Python3 完成，不能使用标准库和第三方库。 函数传入的 text 为字符串类型，可能为空、 None 等值。 不得修改文件路径、文件名 yin_book.py 以及函数名 yin_book_encryption(text) 。 请只保留文件 yin_book.py 及文件中函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3 yin_book.py 命令调用 Python3。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/:1:3","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-06姜子牙阴书加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"参考样例 # 样例 1 text = \"姜子牙阴书加密\"; encryption_text = [\"姜\", \"子牙阴\", \"书加密\"] # 样例 2 text = \"姜子牙阴书 加密\"; encryption_text = [\"姜\", \"子牙阴\", \" 书加密\"] # 样例 3 text = \"None\"; encryption_text = [\"N\", \"one\"] # 样例 4 text = ''; encryption_text = None 注意：最终实现效果以完全满足要求为准，而不是仅满足如上样例。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/:1:4","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-06姜子牙阴书加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"题解 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/:2:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-06姜子牙阴书加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"解题思路 简单的模拟题 要注意对传入参数类型的检查，包括空字符串等情形。 构造等差数列子函数。 注意份数与等差数列的和的关系，及边界条件。 最后使用join方法将列表拼接为字符串返回即可。 def yin_book_encryption(text: str) -\u003e list: \"\"\"TODO \"\"\" if not isinstance(text, str): return None if text == \"\": return None encryption_text: list = [] text_len = len(text) n = 1 sum = 0 def seqsum(n): return int(n * (n+1)/2) while sum \u003c text_len: word_num = seqsum(n) start = sum n = n + 1 sum = sum + word_num encryption_text.append(text[start:sum]) return encryption_text 题目来源：蓝桥 姜子牙阴书加密 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/:2:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-06姜子牙阴书加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA06%E5%A7%9C%E5%AD%90%E7%89%99%E9%98%B4%E4%B9%A6%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"赛题介绍 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/:1:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-05棋盘加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战介绍 棋盘密码是一种坐标加密法。棋盘密码通过将 26 个字母设法变成十位数来达到加密的目的，密钥是一个 5×5 的棋盘，将 26 个英文字母填在棋盘的格子里，其中 i 和 j 在同一个方格中，这样就构造出一个完整的棋盘。每一个字母对应有横和纵两个坐标，这两个坐标的组合就是该字母的密文。如下棋盘： 1 2 3 4 5 1 a b c d 2 f g h i/j 3 l m n o 4 q r s t 5 v w x y 例如对明文 tynam 加密，t 在棋盘里对应的的坐标是 44 ，y 对应的坐标是 54 ，n 对应的坐标是 33 ，a 对应的坐标是 11 ，m 对应的坐标是 32 。那么明文 tynam 加密后就是 4454331132 。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/:1:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-05棋盘加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战目标 补充文件 polybius.py 下 polybius_encryption(text) 函数中的 TODO 部分，使其实现我们需要的功能： 输入一段字符串，将字符串中所有英文字符使用 5x5 棋盘加密。 只对半角英文字符进行转换，其它内容保持不变。 忽略英文字符大小写，例如 a 和 A 加密后都是 11。 如果字符串中有空格，请先去掉空格后再进行加密。 返回的密文中不应该存在空格。 如果文本中没有内容，则返回 None。 def polybius_encryption(text: str) -\u003e str: \"\"\"TODO \"\"\" encryption_text : str = '' return encryption_text ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/:1:2","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-05棋盘加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战要求 题目需使用 Python3 完成，不能使用标准库和第三方库。 函数传入 text 为字符串类型，可能为空、None 等值。 不得修改文件路径、文件名 polybius.py 以及函数名 polybius_encryption(text)。 请只保留文件 polybius.py 及文件中函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3 polybius.py 命令调用 Python3。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/:1:3","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-05棋盘加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"参考样例 # 样例 1 text = \"tynam\"; encryption_text = \"4454331132\" # 样例 2 text = \"tynam123\"; encryption_text = \"4454331132123\" # 样例 3 text = \"tynam 您好！\"; encryption_text = \"4454331132您好！\" # 样例 4 text = \"TYnam\"; encryption_text = \"4454331132\" # 样例 5 text = None; encryption_text = None 注意：最终实现效果以完全满足要求为准，而不是仅满足如上样例。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/:1:4","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-05棋盘加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"题解 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/:2:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-05棋盘加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"解题思路 简单的模拟题 要注意对传入参数类型的检查，包括空字符串等情形。 对大写英文字母转换为小写。 最后使用join方法将列表拼接为字符串返回即可。 def polybius_encryption(text: str) -\u003e str: \"\"\"TODO \"\"\" result = [] map = {\"a\": \"11\", \"b\": \"12\", \"c\": \"13\", \"d\": \"14\", \"e\": \"15\", \"f\": \"21\", \"g\": \"22\", \"h\": \"23\", \"i\": \"24\", \"j\": \"24\", \"k\": \"25\", \"l\": \"31\", \"m\": \"32\", \"n\": \"33\", \"o\": \"34\", \"p\": \"35\", \"q\": \"41\", \"r\": \"42\", \"s\": \"43\", \"t\": \"44\", \"u\": \"45\", \"v\": \"51\", \"w\": \"52\", \"x\": \"53\", \"y\": \"54\", \"z\": \"55\" } zimu = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" if not isinstance(text, str): return None text = text.replace(' ', '') if text == \"\": return None for t in text: if t in zimu: result.append(map[t.lower()]) else: result.append(t) encryption_text: str = ''.join(result) return encryption_text 题目来源：蓝桥 棋盘加密 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/:2:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-05棋盘加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA05%E6%A3%8B%E7%9B%98%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"赛题介绍 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/:1:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-04栅栏加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战介绍 栅栏密码是一种简单的移动字符位置的加密方法，规则简单。加密方式是将明文按照一定的字数分成多个组，取每组第一个字连起来得到密文 1，再取每组第二个字连起来得到密文 2，以此类推，最后将密文 1、密文 2…密文 N 连成整段密文。例如： 明文：这是一段栅栏加密文字 将每两个字分成一组，会得到五组内容：这是 | 一段 | 栅栏 | 加密 | 文字 提取每组中的第一个字构成第一段文字：这一栅加文 提取每组中的第二个字构成第二段文字：是段栏密字 然后将两段文字合在一起，就得到了密文：这一栅加文是段栏密字 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/:1:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-04栅栏加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战目标 补充文件 fence.py 下 fence_encryption(text) 函数中的 TODO 部分，使其实现我们需要的功能： 输入一段文本，将文本中每两个字符（字母、汉字或其它文字）为一组进行分组；然后提取每组中的第一个字构成第一段文字，第二个字构成第二段文字；最后将第二段文字写在第一段文字后面，合在一起返回。 如果文本中有空格，请先去掉空格再拆分文本。 返回的密文中不应该存在空格。 如果文本中没有内容，则返回 None。 def fence_encryption(text: str) -\u003e str: \"\"\"TODO \"\"\" encryption_text : str = '' return encryption_text ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/:1:2","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-04栅栏加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"挑战要求 题目需使用 Python3 完成，不能使用标准库和第三方库。 函数传入的 text 为字符串类型，可能为空、None 等值。 不得修改文件路径、文件名 fence.py 以及函数名 fence_encryption(text)。 请只保留文件 fence.py 及文件中函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3 fence.py 命令调用 Python3。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/:1:3","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-04栅栏加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"参考样例 # 样例 1 text = \"这是一段栅栏加密文字\"; encryption_text = \"这一栅加文是段栏密字\" # 样例 2 text = \"这是 一段栅栏 加密文字\"; encryption_text = \"这一栅加文是段栏密字\" # 样例 3 text = None; encryption_text = None 注意：最终实现效果以完全满足要求为准，而不是仅满足如上样例。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/:1:4","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-04栅栏加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"题解 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/:2:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-04栅栏加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"解题思路 简单的模拟题 要注意对传入参数类型的检查，包括空字符串等情形。 利用奇偶判断将字符分别放到两个列表中。 最后使用join方法将列表拼接为字符串返回即可。 def fence_encryption(text: str) -\u003e str: \"\"\"TODO \"\"\" f1 = [] f2 = [] if not isinstance(text, str): return None text = text.replace(' ', '') if text == \"\": return None for i, v in enumerate(text): if i % 2 == 0: f1.append(v) else: f2.append(v) encryption_text: str = ''.join(f1) + ''.join(f2) return encryption_text 题目来源：蓝桥 栅栏加密 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/:2:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-04栅栏加密 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA04%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86/"},{"categories":["Python"],"content":"赛题介绍 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/:1:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-03破解三角形密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"挑战介绍 三角形密码指的是将一串字符串按照正直角三角形的形状排列，传递的信息隐藏在每一行的最后一个字符，然后将所有的行的最后一个字符依次连接，就是需要传递的信息。 例如加密后的字符串是：我们爱的是蓝色的心桥 将加密字符串按照正直角三角形填充后如下： 我 们 爱 的 是 蓝 色 的 心 桥 提取每一行的最后一个字符，然后连起来就是：我爱蓝桥，也就是传递的信息。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/:1:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-03破解三角形密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"挑战目标 补充文件 triangle.py 下 triangle_decryption(text) 函数中的 TODO 部分，使其实现我们需要的功能： 输入一段字符串，使用正直角三角形进行破解，返回破解的内容。 如果最后一行字符串不足三角形的边长，则获取最后一个字符。例如密文“我们爱的你”，对应的明文是“我爱你”。 如果输入的字符串前后有空格，请先去掉空格再使用正直角三角形破解。字符串中间的空格不需要去掉。 如果输入的内容不是字符串或字符串为空则返回 None。 def triangle_decryption(text: str) -\u003e str: \"\"\"TODO \"\"\" decryption_text : str = '' return decryption_text ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/:1:2","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-03破解三角形密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"挑战要求 题目需使用 Python3 完成，不能使用标准库和第三方库。 函数传入 text 为字符串类型，可能为空、None 等值。 不得修改文件路径、文件名 triangle.py 以及函数名 triangle_decryption(text)。 请只保留文件 triangle.py 及文件中函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3 triangle.py 命令调用 Python3。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/:1:3","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-03破解三角形密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"参考样例 # 样例 1 text = \"我们爱的是蓝色的心桥\"; decryption_text = \"我爱蓝桥\" # 样例 2 text = \"我们爱的你\"; decryption_text = \"我爱你\" # 样例 3 text = \" 我们爱的是蓝色的心桥\"; decryption_text = \"我爱蓝桥\" # 样例 4 text = \"我 爱你\"; decryption_text = \"我爱你\" # 样例 5 text = None; decryption_text = None 注意：最终实现效果以完全满足要求为准，而不是仅满足如上样例。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/:1:4","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-03破解三角形密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"题解 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/:2:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-03破解三角形密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"解题思路 简单的模拟题 要注意对传入参数类型的检查，包括空字符串等情形。 当输入仅有一个字符的时候，原样返回即可。 需要考虑好对边界情况的判断。 最后使用join方法将列表拼接为字符串返回即可。 def triangle_decryption(text: str) -\u003e str: \"\"\"TODO \"\"\" result = [] i = 2 index = 0 if text == '' or None or not isinstance(text, str): return None text = text.strip() if len(text) == 1: return text while index \u003c len(text): result.append(text[index]) index = index + i i = i + 1 if index + 1 \u003e= len(text): result.append(text[-1]) break decryption_text: str = \"\".join(result) return decryption_text 题目来源：蓝桥破解三角形密码 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/:2:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-03破解三角形密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA03%E7%A0%B4%E8%A7%A3%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"赛题介绍 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/:1:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-02破解曾公亮密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"挑战介绍 曾公亮编撰的《武经总要》中记载了一套严谨的军事通信密码，这也是目前发现我国古代战争中最早使用的军用密码表。将战场上可能常用到的情况，用 40 个短语归纳表示，且每个短语前编有固定的数字代码，这 40 个短语及数字代码如下： 代码 短语 代码 短语 代码 短语 代码 短语 代码 短语 1 请弓 2 请箭 3 请刀 4 请甲 5 请枪旗 6 请锅幕 7 请马 8 请衣赐 9 请粮料 10 请草料 11 请车牛 12 请船 13 请攻城守县 14 请添兵 15 请移营 16 请进军 17 请退军 18 请固定 19 未见军 20 见贼 21 贼多 22 贼少 23 贼相敌 24 贼添兵 25 贼移营 26 贼进军 27 贼退军 28 贼固守 29 围得贼城 30 解围城 31 被贼围 32 贼围解 33 战不胜 34 战大胜 35 战大捷 36 将士投降 37 将士叛 38 士卒病 39 部将病 40 战小胜 然后约定某一首五言古诗作为解密的钥匙，五言古诗中 40 个字正好对应密码表中 40 种情况。 例如约定唐代王勃的《送杜少府之任蜀川》为解密的钥匙。 城阙辅三秦，风烟望五津。 与君离别意，同是宦游人。 海内存知己，天涯若比邻。 无为在歧路，儿女共沾巾。 如果军中马匹不足，需要请求马匹，那么对应密码表中的情报则是：7、请马。而《送杜少府之任蜀川》中第 7 个字是烟，将军只需要将“烟”字写到 一件普通公文书牒之中，并在字上加盖印章。朝廷收到公文书牒后通过《送杜少府之任蜀川》确认“烟”字的位置，然后查找密码表，获得相应的情报。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/:1:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-02破解曾公亮密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"挑战目标 补充文件 zeng_gongliang.py 下 zeng_gongliang_decryption(text) 函数中的 TODO 部分，使其实现我们需要的功能： 输入古诗《送杜少府之任蜀川》中任意一个字，返回曾公亮密码表中对应的短语。 如果输入的内容在古诗《送杜少府之任蜀川》的 40 个 字中查找不到，则返回 None。 其它情况全部返回 None。 def zeng_gongliang_decryption(text: str) -\u003e str: \"\"\"TODO \"\"\" key_dict = {'1':'请弓', '2':'请箭', '3':'请刀', '4':'请甲', '5':'请枪旗', '6':'请锅幕', '7':'请马', '8':'请衣赐', '9':'请粮料', '10':'请草料', '11':'请车牛', '12':'请船', '13':'请攻城守县', '14':'请添兵', '15':'请移营', '16':'请进军', '17':'请退军', '18':'请固定', '19':'未见军', '20':'见贼', '21':'贼多', '22':'贼少', '23':'贼相敌', '24':'贼添兵', '25':'贼移营', '26':'贼进军', '27':'贼退军', '28':'贼固守', '29':'围得贼城', '30':'解围城', '31':'被贼围', '32':'贼围解', '33':'战不胜', '34':'战大胜', '35':'战大捷', '36':'将士投降', '37':'将士叛', '38':'士卒病', '39':'部将病', '40':'战小胜'} decryption_text : str = '' return decryption_text ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/:1:2","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-02破解曾公亮密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"挑战要求 题目需使用 Python3 完成，不能使用标准库和第三方库。 函数传入 text 为字符串类型，可能为空、None 等值。 不得修改文件路径、文件名 zeng_gongliang.py 以及函数名 zeng_gongliang_decryption(text)。 请只保留文件 zeng_gongliang.py 及文件中函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3 zeng_gongliang.py 命令调用 Python3。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/:1:3","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-02破解曾公亮密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"参考样例 # 样例 1 text = \"烟\"; decryption_text = \"请马\" # 样例 2 text = \"城\"; decryption_text = \"请弓\" # 样例 3 text = \"请弓\"; decryption_text = None # 样例 4 text = \"城 \"; decryption_text = None # 样例 5 text = None; decryption_text = None 注意：最终实现效果以完全满足要求为准，而不是仅满足如上样例。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/:1:4","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-02破解曾公亮密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"题解 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/:2:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-02破解曾公亮密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"解题思路 主要考察字典dict结构及方法的运用 要注意对传入参数类型的检查，包括空字符串等情形。 构造索引字符串。 利用index()方法寻找某个字符的索引. 过滤不存在的键值，返回None。 最后使用get方法从字典找到对应的字符串值返回即可。 def zeng_gongliang_decryption(text: str) -\u003e str: \"\"\"TODO \"\"\" # 过滤非str类型输入 if not isinstance(text, str) or text == \"\": return None # 仅一个字符输入限制 if len(text) \u003e 1: return None # 构造数据字典 key_dict = {'1': '请弓', '2': '请箭', '3': '请刀', '4': '请甲', '5': '请枪旗', '6': '请锅幕', '7': '请马', '8': '请衣赐', '9': '请粮料', '10': '请草料', '11': '请车牛', '12': '请船', '13': '请攻城守县', '14': '请添兵', '15': '请移营', '16': '请进军', '17': '请退军', '18': '请固定', '19': '未见军', '20': '见贼', '21': '贼多', '22': '贼少', '23': '贼相敌', '24': '贼添兵', '25': '贼移营', '26': '贼进军', '27': '贼退军', '28': '贼固守', '29': '围得贼城', '30':'解围城', '31': '被贼围', '32': '贼围解', '33': '战不胜', '34': '战大胜','35': '战大捷', '36': '将士投降', '37': '将士叛', '38': '士卒病', '39': '部将病', '40': '战小胜'} poem = \"城阙辅三秦风烟望五津与君离别意同是宦游人海内存知己天涯若比邻无为在歧路儿女共沾巾\" if text in poem: num = poem.index(text) + 1 if key_dict.get(str(num)) == None: return None else: return None decryption_text: str = key_dict.get(str(num)) return decryption_text 题目来源：破解曾公亮密码 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/:2:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-02破解曾公亮密码 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA02%E7%A0%B4%E8%A7%A3%E6%9B%BE%E5%85%AC%E4%BA%AE%E5%AF%86%E7%A0%81/"},{"categories":["Python"],"content":"赛题介绍 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/:1:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-01破解藏头诗 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/"},{"categories":["Python"],"content":"挑战介绍 藏头诗是一种将需要传递的内容隐藏在每句诗的第一个字，解密时只需要提取每句诗的第一个字，然后连在一起就可以获得传递的消息。古人经常使用藏头诗，隐晦地表达自己想说的话，既有诗意，又能传递信息。 例如《水浒传》中的一诗： 芦花丛中一扁舟，俊杰俄从此地游。 义士若能知此理，反躬难逃可无忧。 提取每句诗的第一个字，连成一句话就是：芦俊义反。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/:1:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-01破解藏头诗 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/"},{"categories":["Python"],"content":"挑战目标 补充文件 acrostic_poetry.py 下 acrostic_poetry_decryption(poem) 函数中的 TODO 部分，使其实现我们需要的功能： 输入一个字符串，字符串为一首诗内容，每句诗之间使用逗号（，）或句号（。）分割。 提取每句诗的第一个字，然后从左往右依次拼接，最后将得到的字符串赋值给变量 decryption_text。 如果输入内容中有空格，请先去掉空格后再处理。 如果输入内容中没有内容，则返回 None。 www import re def acrostic_poetry_decryption(poem: str) -\u003e str: \"\"\"TODO \"\"\" decryption_text : str = '' return decryption_text ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/:1:2","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-01破解藏头诗 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/"},{"categories":["Python"],"content":"挑战要求 题目需使用 Python3 完成，除 re 库外，不能使用其它标准库和第三方库。 函数传入的 poem 为字符串类型，可能为空、None 等值。 不得修改文件路径、文件名 acrostic_poetry.py 以及函数名 acrostic_poetry_decryption(poem)。 请只保留文件 acrostic_poetry.py 及文件中函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3 acrostic_poetry.py 命令调用 Python3。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/:1:3","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-01破解藏头诗 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/"},{"categories":["Python"],"content":"参考样例 # 样例 1 poem = \"芦花丛中一扁舟，俊杰俄从此地游，义士若能知此理，反躬难逃可无忧。\"; decryption_text = \"芦俊义反\" # 样例 2 poem = \" 芦花丛中一扁舟，俊杰俄从此地游。义士 若能知此理，反躬难逃可无忧。\"; decryption_text = \"芦俊义反\" # 样例 3 poem = \"芦花丛中一扁舟，俊杰俄从此地游义士若能知此理，反躬难逃可无忧\"; decryption_text = \"芦俊反\" # 样例 4 poem = None; decryption_text = None 注意：最终实现效果以完全满足要求为准，而不是仅满足如上样例。 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/:1:4","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-01破解藏头诗 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/"},{"categories":["Python"],"content":"题解 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/:2:0","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-01破解藏头诗 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/"},{"categories":["Python"],"content":"解题思路 要注意对传入参数类型的检查，包括空字符串等情形。 考察对字符串分割的能力。若直接用字符串split()方法，需要多次操作才能完成。如果分割标识符较多，不是明智之举。这里使用正则的字符串分割方法re.split(). 正则模式中括号[]用来表示一组字符,单独列出：[，。] 匹配 ‘，或’。' 利用Python列表推导简化代码编写。分别从正则分割后的列表中提取每段的首个字。因为有空字符串，所以还要在列表推导中加个if判断。 最后使用join方法将列表拼接为字符串返回即可。 代码如下： import re def acrostic_poetry_decryption(poem: str) -\u003e str: \"\"\"TODO \"\"\" # 过滤非str类型输入 if not isinstance(poem, str): return None # 过滤空格符 poem = poem.replace(' ', '') # 过滤空字符串 if poem == \"\": return None # 利用正则以符号分组，提取每组的首个字符 result = [x[0] for x in re.split('[，。]', poem) if x] decryption_text: str = ''.join(result) return decryption_text 题目来源：破解藏头诗 ","date":"2023-02-26","objectID":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/:2:1","tags":["python","Crypto","题解","比赛"],"title":"蓝桥 卷“兔”来袭编程竞赛专场-01破解藏头诗 题解","uri":"/20230226-%E8%93%9D%E6%A1%A5%E5%8D%B7%E5%85%94%E6%9D%A5%E8%A2%AD%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E4%B8%93%E5%9C%BA01%E7%A0%B4%E8%A7%A3%E8%97%8F%E5%A4%B4%E8%AF%97/"},{"categories":["生活"],"content":"爱情漩涡 你的魅力与美丽令我深陷爱情漩涡(循环) 我对你的爱将附加到每一天！ 如果加上一个条件，那么将会直至永远 当爱情从0突破1的那一刻 我想让时间过得慢些再慢些 因为想与你一起寒来暑往看过每个日升月落 import time # 你的魅力与美丽令我深陷爱情漩涡(循环) def LoveLoop(): i = 0 LOVE = True # 如果加上一个条件，那么将会直至永远。 while LOVE: # 对你的爱将附加到每一天！ day = \"love\" print(\"Day %s: I %sYOU \" % (i, day )) # 当爱情从0突破1的那一刻 i = i + 1 # 我想让时间过得慢些再慢些 time.sleep(999) # 因为想伴你寒来暑往看过每个日升月落 if __name__ == \"__main__\": LoveLoop() ","date":"2023-02-14","objectID":"/20230214-%E7%88%B1%E6%83%85%E6%BC%A9%E6%B6%A1/:0:0","tags":["poem","情感","love"],"title":"情人节土味情话——爱情漩涡","uri":"/20230214-%E7%88%B1%E6%83%85%E6%BC%A9%E6%B6%A1/"},{"categories":["人工智能"],"content":"简介 随着社区支持的不断完善，现已支持M1 MAC 版本的 ModelScope安装。 modelscope官网，ModelScope 社区成立于 2022 年 6 月，是一个模型开源社区及创新平台，由阿里巴巴达摩院，联合 CCF开源发展委员会，共同作为项目发起方。社区联合国内 AI 领域合作伙伴与高校机构，致力于通过开放的社区合作，构建深度学习相关的模型开源，并开源相关模型服务创新技术，推动模型应用生态的繁荣发展。 ","date":"2022-12-13","objectID":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/:1:0","tags":["深度学习","python","人工智能","Pytorch","tensorflow","MacOS"],"title":"Mac M1 安装 modelscope 深度学习库","uri":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/"},{"categories":["人工智能"],"content":"基础环境 以 Mac M1 安装为例，以下是我的安装环境。 Darwin sp 22.1.0 Darwin Kernel Version 22.1.0: Sun Oct 9 20:15:09 PDT 2022; root:xnu-8792.41.9~2/RELEASE_ARM64_T6000 arm64 ","date":"2022-12-13","objectID":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/:2:0","tags":["深度学习","python","人工智能","Pytorch","tensorflow","MacOS"],"title":"Mac M1 安装 modelscope 深度学习库","uri":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/"},{"categories":["人工智能"],"content":"安装 ","date":"2022-12-13","objectID":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/:3:0","tags":["深度学习","python","人工智能","Pytorch","tensorflow","MacOS"],"title":"Mac M1 安装 modelscope 深度学习库","uri":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/"},{"categories":["人工智能"],"content":"1. 安装 M1 Mac Anaconda 根据 pytorch官网 指南安装 Anaconda # The version of Anaconda may be different depending on when you are installing` curl -O https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh sh Miniconda3-latest-MacOSX-arm64.sh # and follow the prompts. The defaults are generally good.` ","date":"2022-12-13","objectID":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/:3:1","tags":["深度学习","python","人工智能","Pytorch","tensorflow","MacOS"],"title":"Mac M1 安装 modelscope 深度学习库","uri":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/"},{"categories":["人工智能"],"content":"2. 创建conda modelscope环境 虽然目前 modelscope官网建议使用 python3.7+。 但是由于python3.7 和 python3.9可能有问题，这里选用python3.8, conda install setuptools_scm conda create -n modelscope python=3.8 conda activate modelscope ","date":"2022-12-13","objectID":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/:3:2","tags":["深度学习","python","人工智能","Pytorch","tensorflow","MacOS"],"title":"Mac M1 安装 modelscope 深度学习库","uri":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/"},{"categories":["人工智能"],"content":"3. 安装 M1 Mac Pytorch 在 modelscope 环境下执行： pip3 install torch torchvision torchaudio ","date":"2022-12-13","objectID":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/:3:3","tags":["深度学习","python","人工智能","Pytorch","tensorflow","MacOS"],"title":"Mac M1 安装 modelscope 深度学习库","uri":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/"},{"categories":["人工智能"],"content":"4. 安装 M1 Mac tensorflow 由于 ModelScope同时支持 Pytorch 和 tensorflow。 若安装官网直接进行第5步，会自动把这两个依赖装上。但在编译 grpcio 这个依赖库时会提示编译错误。 由 Grpcio fails installation for Tensorflow 2.5 on arm64 Apple Silicon得知安装M1 Mac tensorflow方法。 在 modelscope 环境下执行： GRPC_PYTHON_BUILD_SYSTEM_OPENSSL=1 GRPC_PYTHON_BUILD_SYSTEM_ZLIB=1 python -m pip install tensorflow-macos ","date":"2022-12-13","objectID":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/:3:4","tags":["深度学习","python","人工智能","Pytorch","tensorflow","MacOS"],"title":"Mac M1 安装 modelscope 深度学习库","uri":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/"},{"categories":["人工智能"],"content":"5. 安装 M1 Mac modelscope 在 modelscope 环境下执行： pip install \"modelscope[cv,nlp,multi-modal,science]\" -f https://modelscope.oss-cn-beijing.aliyuncs.com/releases/repo.html 由于对 audio不感兴趣，未测试 modelscope audio的安装。 ","date":"2022-12-13","objectID":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/:3:5","tags":["深度学习","python","人工智能","Pytorch","tensorflow","MacOS"],"title":"Mac M1 安装 modelscope 深度学习库","uri":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/"},{"categories":["人工智能"],"content":"安装验证 python -c \"from modelscope.pipelines import pipeline;print(pipeline('word-segmentation')('今天天气不错，适合 出去游玩'))\" ","date":"2022-12-13","objectID":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/:4:0","tags":["深度学习","python","人工智能","Pytorch","tensorflow","MacOS"],"title":"Mac M1 安装 modelscope 深度学习库","uri":"/20221213-macm1%E5%AE%89%E8%A3%85modelscope%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BA%93/"},{"categories":["Python"],"content":"缘起 由于新冠疫情影响，为避免户外威胁，我选择了居家以程序员的方式纪念这个端午。 虽然气温较高，疫情也得到了有效的控制，但为了他人和自身的身体健康，仍然需要在人流密集的公共场所佩戴好口罩😷。 由此，我以为粽子宝宝戴口罩😷为主题，花费4个小时（构思，素材收集，编码, 记录），制作了一个公益小游戏。科普防疫戴口罩。纪念这个端午！ ","date":"2022-06-02","objectID":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/:1:0","tags":["python","pygame","算法","游戏"],"title":"端午抗疫宣传公益小游戏-用Python为粽子宝宝戴口罩","uri":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/"},{"categories":["Python"],"content":"目标 此游戏使用Python语言，并使用Pygame游戏开发库进行制作。 游戏开始会有一个未戴口罩的粽子宝宝的形象。 粽子宝宝的口鼻处有个半透明的口罩，这个是提示我们应该戴口罩的位置。 玩家控制键盘的方向键，移动口罩。 当口罩移动到预定位置，游戏成功通关，画面出现成功通关提示！ ","date":"2022-06-02","objectID":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/:2:0","tags":["python","pygame","算法","游戏"],"title":"端午抗疫宣传公益小游戏-用Python为粽子宝宝戴口罩","uri":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/"},{"categories":["Python"],"content":"成品展示 麻雀虽小，但五脏俱全呵！首先看一下最终实现的效果，一图杀猫～ 此处有背景音乐🎵～ ","date":"2022-06-02","objectID":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/:3:0","tags":["python","pygame","算法","游戏"],"title":"端午抗疫宣传公益小游戏-用Python为粽子宝宝戴口罩","uri":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/"},{"categories":["Python"],"content":"关键技术 首先安装pygame游戏库 pip install pygame ","date":"2022-06-02","objectID":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/:4:0","tags":["python","pygame","算法","游戏"],"title":"端午抗疫宣传公益小游戏-用Python为粽子宝宝戴口罩","uri":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/"},{"categories":["Python"],"content":"素材及目录结构 仅有五个文件，包括两张图片素材，一个音乐素材，一个字体素材及源码文件。源码及素材见文末 ","date":"2022-06-02","objectID":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/:4:1","tags":["python","pygame","算法","游戏"],"title":"端午抗疫宣传公益小游戏-用Python为粽子宝宝戴口罩","uri":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/"},{"categories":["Python"],"content":"游戏对象初始化 使用Pygame框架首先要初始化pygame对象。 def init_game(caption): # 初始化pygame pygame.init() # 变量定义 size = width, height = 800, 800 # 创建一个游戏窗口 screen = pygame.display.set_mode(size, 0, 32) #设置窗口标题 pygame.display.set_caption(caption) return screen ","date":"2022-06-02","objectID":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/:4:2","tags":["python","pygame","算法","游戏"],"title":"端午抗疫宣传公益小游戏-用Python为粽子宝宝戴口罩","uri":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/"},{"categories":["Python"],"content":"背景音乐 我们可以使用load载入需要播放的音乐文件。 play方法的第一个参数loops和第二个参数start分别代表重复的次数和开始播放的位置。-1就是循环播放。 def play_music(): pygame.mixer.music.load('sp.mp3') pygame.mixer.music.play(-1, 0.0) ","date":"2022-06-02","objectID":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/:4:3","tags":["python","pygame","算法","游戏"],"title":"端午抗疫宣传公益小游戏-用Python为粽子宝宝戴口罩","uri":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/"},{"categories":["Python"],"content":"渲染图片 加载图片对象 zongzi = pygame.image.load(\"zongzi.png\") 平滑缩放图像，可以控制图片的大小。 zongzi = pygame.transform.smoothscale(zongzi, (500, 700)) 图片透明度设置 mask.set_alpha(200) 渲染图片 screen.blit(zongzi,(200,200)) ","date":"2022-06-02","objectID":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/:4:4","tags":["python","pygame","算法","游戏"],"title":"端午抗疫宣传公益小游戏-用Python为粽子宝宝戴口罩","uri":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/"},{"categories":["Python"],"content":"文字渲染 通过字体文件获得字体对象 fontObj = pygame.font.Font('Songti.ttc', 26) 配置要显示的文字 可以设置文字的内容及字体颜色。 textSurfaceObj = fontObj.render('你真棒，粽宝宝已成功佩戴好口罩！', False, (255,10,10)) ","date":"2022-06-02","objectID":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/:4:5","tags":["python","pygame","算法","游戏"],"title":"端午抗疫宣传公益小游戏-用Python为粽子宝宝戴口罩","uri":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/"},{"categories":["Python"],"content":"键盘控制 使用 pygame.KEYDOWN 获取键盘事件。 K_UP,K_DOWN,K_LEFT,K_RIGHT 分别对应键盘方向键上下左右 通过坐标的加减，来改变坐标的位置，这里以10为按键一次的移动距离。 if event.type == pygame.KEYDOWN: if event.key == pygame.K_UP: mask_y -= 10 if event.key == pygame.K_DOWN: mask_y += 10 if event.key == pygame.K_LEFT: mask_x -= 10 if event.key == pygame.K_RIGHT: mask_x += 10 ","date":"2022-06-02","objectID":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/:4:6","tags":["python","pygame","算法","游戏"],"title":"端午抗疫宣传公益小游戏-用Python为粽子宝宝戴口罩","uri":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/"},{"categories":["Python"],"content":"思考 对啦，整个游戏其实就是一个状态机，总共有开始，胜利 ，游戏中三种状态。那么我们可以使用一个 while 语句，搞起一个事件循环 。就可以一直愉快滴玩耍啦！开心不开心？ 虽然该篇程序没有复杂的算法，但使用简单的顺序，判断，循环 语句就可实现稍稍复杂的小游戏。 正所谓：大道至简 重剑无锋 大巧不工 这个游戏还有很多可以扩展的内容，下面留下几个思考题，让游戏更好玩吧～ 增加游戏难度，如何让粽子宝宝随机移动，一边移动一边尝试戴口罩？[已实现] 使用鼠标控制口罩。[已实现] 原理：实时获取鼠标光标的坐标，将图片的坐标与鼠标光标的相对位置绑定即可 # 获取光标位置 x, y = pygame.mouse.get_pos() 3. 加入计时及显示功能。 源码见： https://github.com/spaceack/spaceack_games/tree/main/mask_zongzi 或关注公众号【编程之舞】回复maskzongzi领取。 ","date":"2022-06-02","objectID":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/:5:0","tags":["python","pygame","算法","游戏"],"title":"端午抗疫宣传公益小游戏-用Python为粽子宝宝戴口罩","uri":"/20220602-%E7%AB%AF%E5%8D%88%E6%8A%97%E7%96%AB%E5%AE%A3%E4%BC%A0%E5%85%AC%E7%9B%8A%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%94%A8python%E4%B8%BA%E7%B2%BD%E5%AD%90%E5%AE%9D%E5%AE%9D%E6%88%B4%E5%8F%A3%E7%BD%A9/"},{"categories":["Linux"],"content":"BIOS Mode 将硬件资源抽象 传递给内核，引导内核。 传统 windows BIOS : legacy UEFI（Unified Extensible Firmware Interface）统一可扩展固件接口：负责加电自检（POST）等。 嵌入式：pmon u-boot 固件（firmware）嵌入在硬件设备的软件。位于特殊应用集成电路（ASIC）或可编程逻辑器件（PLD）中的闪存，EEPROM或PROM中，有的可更新。 操作系统-UEFI-固件-硬件 ","date":"2022-05-18","objectID":"/20220518-linux%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","tags":["BIOS","UEFI","GPT","MBR"],"title":"Linux 安装基础知识","uri":"/20220518-linux%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["Linux"],"content":"如何确认当前Linux系统是否是 UEFI 模式 检查 /sys/firmware/efi/ 目录是否存在 ls /sys/firmware/efi/ ","date":"2022-05-18","objectID":"/20220518-linux%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:1","tags":["BIOS","UEFI","GPT","MBR"],"title":"Linux 安装基础知识","uri":"/20220518-linux%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["Linux"],"content":"Partition Style MBR GPT ","date":"2022-05-18","objectID":"/20220518-linux%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","tags":["BIOS","UEFI","GPT","MBR"],"title":"Linux 安装基础知识","uri":"/20220518-linux%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["Linux"],"content":"如何确认当前磁盘是否是 GPT 格式 fdisk -l 检查 磁盘标签类型（Disk label type） gpt 对应 GPT， dos 对应 MBR parted -l 检查 分区表（Partition Table） gpt 对应 GPT， msdos 对应 MBR ","date":"2022-05-18","objectID":"/20220518-linux%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:1","tags":["BIOS","UEFI","GPT","MBR"],"title":"Linux 安装基础知识","uri":"/20220518-linux%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["Linux"],"content":"如果你是一个程序员，你会知道，rpm, yum, dnf这三个进程是否运行，如果运行，是否阻塞？ ","date":"2022-04-27","objectID":"/20220427-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%ADrpm%E5%92%8Cyum%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E/:0:0","tags":["dnf","yum","rpm","pid","lock"],"title":"如何准确判断rpm,yum,dnf进程是否阻塞[运行]？","uri":"/20220427-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%ADrpm%E5%92%8Cyum%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E/"},{"categories":["Linux"],"content":"简单常用但不严谨的做法 一个简单方法是通过 ps -ef | grep rpm | grep -v grep 命令来判断。 但这种方法有两个问题： 不严谨，当进程名中还有三个命令名字的某个子字符串时，就会误判。要不就是需要繁琐的规则去过滤，繁琐意味着引入更多的错误。 仅能够判断有进程在运行，但并不一定会阻塞。例如当进行到用户确认这一步时，虽然有此进程，但依然可以再开个终端安装其它程序。 ","date":"2022-04-27","objectID":"/20220427-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%ADrpm%E5%92%8Cyum%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E/:1:0","tags":["dnf","yum","rpm","pid","lock"],"title":"如何准确判断rpm,yum,dnf进程是否阻塞[运行]？","uri":"/20220427-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%ADrpm%E5%92%8Cyum%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E/"},{"categories":["Linux"],"content":"一种可行的做法的思考及验证过程 ","date":"2022-04-27","objectID":"/20220427-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%ADrpm%E5%92%8Cyum%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E/:2:0","tags":["dnf","yum","rpm","pid","lock"],"title":"如何准确判断rpm,yum,dnf进程是否阻塞[运行]？","uri":"/20220427-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%ADrpm%E5%92%8Cyum%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E/"},{"categories":["Linux"],"content":"思考 这时我们可以思考，rpm,yum,dnf安装程序本身是如何保证进程互斥的呢？ 不难发现，当我们同时开两个终端执行相同的安装命令时，会有一个终端报错Waiting for process with pid 67 to finish. 等待某个pid进程结束。 自然想到是某种锁机制在发挥作用，再联想到Linux的一切都可以是文件。那么这个锁也极有可能是个文件。 通过搜索引擎很容易发现·yum的 pid文件进程锁 的路径 /var/run/yum.pid。 ","date":"2022-04-27","objectID":"/20220427-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%ADrpm%E5%92%8Cyum%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E/:2:1","tags":["dnf","yum","rpm","pid","lock"],"title":"如何准确判断rpm,yum,dnf进程是否阻塞[运行]？","uri":"/20220427-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%ADrpm%E5%92%8Cyum%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E/"},{"categories":["Linux"],"content":"验证 验证程序 由于安装程序可能很快完成，来不及看到锁文件。所以我们可以快速实现一个简易的验证程序： 山穷水尽疑无路 但很遗憾，并没有发现这个锁程序。 不过我们想到最新系统 yum 已被 dnf 所取代。那么可能网上都是一些过时的信息。 柳暗花明又一村 这时最直接的方法当然是去撸源码咯！ git clone https://github.com/rpm-software-management/dnf.git 走起 通过pid关键字快速定位 grep -inR pid。 果然，很容易验证了我们正确的猜想 再次验证 rpm 的检验 fuser /var/lib/rpm/.rpm.lock ","date":"2022-04-27","objectID":"/20220427-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%ADrpm%E5%92%8Cyum%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E/:2:2","tags":["dnf","yum","rpm","pid","lock"],"title":"如何准确判断rpm,yum,dnf进程是否阻塞[运行]？","uri":"/20220427-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%ADrpm%E5%92%8Cyum%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E/"},{"categories":["数据库"],"content":"题目描述 表：Products +-------------+---------+ | Column Name | Type | +-------------+---------+ | product_id | int | | low_fats | enum | | recyclable | enum | +-------------+---------+ product_id 是这个表的主键。 low_fats 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品是低脂产品，'N' 表示不是低脂产品。 recyclable 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品可回收，而 'N' 表示不可回收。 写出 SQL 语句，查找既是低脂又是可回收的产品编号。 返回结果 无顺序要求 。 查询结果格式如下例所示： Products 表： +-------------+----------+------------+ | product_id | low_fats | recyclable | +-------------+----------+------------+ | 0 | Y | N | | 1 | Y | Y | | 2 | N | Y | | 3 | Y | Y | | 4 | N | N | +-------------+----------+------------+ Result 表： +-------------+ | product_id | +-------------+ | 1 | | 3 | +-------------+ 只有产品 id 为 1 和 3 的产品，既是低脂又是可回收的产品。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/recyclable-and-low-fat-products 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-04-26","objectID":"/1757-%E5%8F%AF%E5%9B%9E%E6%94%B6%E4%B8%94%E4%BD%8E%E8%84%82%E7%9A%84%E4%BA%A7%E5%93%81/:1:0","tags":["查询","leetcode"],"title":"leetcode-1757-可回收且低脂的产品","uri":"/1757-%E5%8F%AF%E5%9B%9E%E6%94%B6%E4%B8%94%E4%BD%8E%E8%84%82%E7%9A%84%E4%BA%A7%E5%93%81/"},{"categories":["数据库"],"content":"题解 非常简单的多条件查询，考察了 AND 的使用，一次通过～ SELECTproduct_idFROMProductsWHERElow_fats='Y'ANDrecyclable='Y'; ","date":"2022-04-26","objectID":"/1757-%E5%8F%AF%E5%9B%9E%E6%94%B6%E4%B8%94%E4%BD%8E%E8%84%82%E7%9A%84%E4%BA%A7%E5%93%81/:2:0","tags":["查询","leetcode"],"title":"leetcode-1757-可回收且低脂的产品","uri":"/1757-%E5%8F%AF%E5%9B%9E%E6%94%B6%E4%B8%94%E4%BD%8E%E8%84%82%E7%9A%84%E4%BA%A7%E5%93%81/"},{"categories":["数据库"],"content":"题目描述 World 表： +-------------+---------+ | Column Name | Type | +-------------+---------+ | name | varchar | | continent | varchar | | area | int | | population | int | | gdp | int | +-------------+---------+ name 是这张表的主键。 这张表的每一行提供：国家名称、所属大陆、面积、人口和 GDP 值。 如果一个国家满足下述两个条件之一，则认为该国是 大国 ： 面积至少为 300 平方公里（即，3000000 km2），或者 人口至少为 2500 万（即 25000000） 编写一个 SQL 查询以报告 大国 的国家名称、人口和面积。 按 任意顺序 返回结果表。 查询结果格式如下例所示。 示例： 输入： World 表： +-------------+-----------+---------+------------+--------------+ | name | continent | area | population | gdp | +-------------+-----------+---------+------------+--------------+ | Afghanistan | Asia | 652230 | 25500100 | 20343000000 | | Albania | Europe | 28748 | 2831741 | 12960000000 | | Algeria | Africa | 2381741 | 37100000 | 188681000000 | | Andorra | Europe | 468 | 78115 | 3712000000 | | Angola | Africa | 1246700 | 20609294 | 100990000000 | +-------------+-----------+---------+------------+--------------+ 输出： +-------------+------------+---------+ | name | population | area | +-------------+------------+---------+ | Afghanistan | 25500100 | 652230 | | Algeria | 37100000 | 2381741 | +-------------+------------+---------+ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/big-countries 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-04-26","objectID":"/595-%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6/:1:0","tags":["查询","leetcode"],"title":"leetcode-595-大的国家","uri":"/595-%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6/"},{"categories":["数据库"],"content":"题解 非常简单的多条件查询，考察了 OR 的使用，一次通过～ SELECTname,population,areaFROMWorldWHEREarea\u003e=3000000ORpopulation\u003e=25000000; ","date":"2022-04-26","objectID":"/595-%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6/:2:0","tags":["查询","leetcode"],"title":"leetcode-595-大的国家","uri":"/595-%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6/"},{"categories":["数据库"],"content":"题目描述 表: Person +-------------+---------+ | 列名 | 类型 | +-------------+---------+ | PersonId | int | | FirstName | varchar | | LastName | varchar | +-------------+---------+ personId是该表的主键列。 该表包含一些人的ID和他们的姓和名的信息。 表: Address +-------------+---------+ | 列名 | 类型 | +-------------+---------+ | AddressId | int | | PersonId | int | | City | varchar | | State | varchar | +-------------+---------+ addressId是该表的主键列。 该表的每一行都包含一个ID = PersonId的人的城市和州的信息。 编写一个SQL查询来报告 Person 表中每个人的姓、名、城市和状态。如果 personId 的地址不在 Address 表中，则报告为空 null 。 以 任意顺序 返回结果表。 查询结果格式如下所示。 示例 1: 输入: Person表: +----------+----------+-----------+ | personId | lastName | firstName | +----------+----------+-----------+ | 1 | Wang | Allen | | 2 | Alice | Bob | +----------+----------+-----------+ Address表: +-----------+----------+---------------+------------+ | addressId | personId | city | state | +-----------+----------+---------------+------------+ | 1 | 2 | New York City | New York | | 2 | 3 | Leetcode | California | +-----------+----------+---------------+------------+ 输出: +-----------+----------+---------------+----------+ | firstName | lastName | city | state | +-----------+----------+---------------+----------+ | Allen | Wang | Null | Null | | Bob | Alice | New York City | New York | +-----------+----------+---------------+----------+ 解释: 地址表中没有 personId = 1 的地址，所以它们的城市和州返回null。 addressId = 1 包含了 personId = 2 的地址信息。 ","date":"2022-04-23","objectID":"/175-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/:1:0","tags":["外连接","leetcode"],"title":"leetcode-175-组合两个表","uri":"/175-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/"},{"categories":["数据库"],"content":"题解 非常典型的左外链接查询。 selectFirstName,LastName,City,StatefromPersonleftjoinAddressonPerson.PersonId=Address.PersonId; ","date":"2022-04-23","objectID":"/175-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/:2:0","tags":["外连接","leetcode"],"title":"leetcode-175-组合两个表","uri":"/175-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/"},{"categories":["算法"],"content":"题目描述 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 ","date":"2022-04-18","objectID":"/leetcode-217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:1:0","tags":["easy","数组","哈希表","排序"],"title":"leetcode-217-存在重复元素","uri":"/leetcode-217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["算法"],"content":"示例 1: 输入: nums = [1,2,3,1] 输出: true ","date":"2022-04-18","objectID":"/leetcode-217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:2:0","tags":["easy","数组","哈希表","排序"],"title":"leetcode-217-存在重复元素","uri":"/leetcode-217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["算法"],"content":"示例 2: 输入: nums = [1,2,3,4] 输出: false ","date":"2022-04-18","objectID":"/leetcode-217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:3:0","tags":["easy","数组","哈希表","排序"],"title":"leetcode-217-存在重复元素","uri":"/leetcode-217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["算法"],"content":"示例 3: 输入: nums = [1,1,1,3,3,4,3,2,4,2] 输出: true 提示： 1 \u003c= nums.length \u003c= 10^5 -10^9 \u003c= nums[i] \u003c= 10^9 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate/ 题解1： 两种思路： 一种是排序，一种是哈希表。 首先使用python的集合（哈希）set()数据结构超级简单，秒过～。 这种需要分配额外的空间用来存放哈希表。 class Solution: def containsDuplicate(self, nums: List[int]) -\u003e bool: scaned = set() for num in nums: if num in scaned: return True else: scaned.add(num) return False ","date":"2022-04-18","objectID":"/leetcode-217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:4:0","tags":["easy","数组","哈希表","排序"],"title":"leetcode-217-存在重复元素","uri":"/leetcode-217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["方法论"],"content":"记录程序开发中的思考方法与好习惯。不仅仅适合程序开发，也适合其它需要逻辑思考的地方。 ","date":"2022-04-11","objectID":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/:0:0","tags":["概念"],"title":"程序开发的思考方法与好习惯","uri":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/"},{"categories":["方法论"],"content":"概念完整性： 软件系统中重要的一点。若对项目问题了解的不够详细进行开发，会导致不断去改代码，期望通过改代码来达到解决问题的目的。 概念不完整，即没有搞明白问题中有哪些对象，对象之间的联系。没有真正搞清楚对象及对象之间的联系。从而没有办法了解问题。在没有真正了解问题的时候，只能被动地等待问题的出现，然后去改代码，以头痛医头，脚痛医脚的方式去解决问题。 其结果就是，花费大量时间做着重复的事情，改着冗余复杂的代码。最终导致大多数项目失败或延期。 如果一个特别的需求特性影响到概念完整性，就需要果断舍弃。不要迁就所有人的要求。hold不住的。 ","date":"2022-04-11","objectID":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/:0:1","tags":["概念"],"title":"程序开发的思考方法与好习惯","uri":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/"},{"categories":["方法论"],"content":"结构化思维: 整体观念全方位的去看待问题，不仅只看表象。以自问自答的方式思考： 1. \"如果....会怎样？否则....会怎样？\" 2. \"最好情况是什么？ 最坏情况是什么？怎么办？\" 3. \"导致问题产生的根本原因是什么？ 去解决根本原因，找对方最终想要的。\" 举例: 男友加班。女友经常抱怨，生气，耍小脾气。 男生看到的表面现象：女友性格不好，不够体贴，不通情达理。 根本原因：双方缺少交流，互动。女友希望得到更多的关注。 错误的示范：你为啥不理解我呢？ 没看我忙着的么？ 正确的姿势： ","date":"2022-04-11","objectID":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/:0:2","tags":["概念"],"title":"程序开发的思考方法与好习惯","uri":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/"},{"categories":["方法论"],"content":"解决问题的两类方式： 一种问题是自己经验中已有的，从中找出一个解决方案即可，这种是最容易的。 更多的问题是在经验之外的，这时候需要知道哪里有解决问题的方法，活用搜索引擎。 ","date":"2022-04-11","objectID":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/:0:3","tags":["概念"],"title":"程序开发的思考方法与好习惯","uri":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/"},{"categories":["方法论"],"content":"学习技术的方法论 学习技术的方法论主要是建立自己的思维框架，用这个思维框架去强吃原理，才能以生有涯应对知无涯。强吃通过已有知识通过迁移学习等方式快速掌握原理类似的新知识，前期需要积累。学技术切勿背说明书，代码机制弄明白了用着就熟了。 by: Aoik-馋师 学通超过一种编程语言，了解尽可能多的编程语言及其优劣，知道解决某个问题的可能的最佳路径。注意学通和学会是两个概念。学会意味着你能够使用这门语言，会写程序，而学通则意味着更多。很多在简历中号称精通C的人不知道malloc背后都发生了什么，精通Python的人却无法用meta programming写出干净漂亮的代码。这样的精通其实也就是勉强学会。 by: 陈天 学会： 了解语言被创建之出的动机，深刻理解语言背后的思想。 掌握如何在线调试（online debugging）和事后分析（coredump analysis）。 掌握语言外延/周边的技术。如JVM之于java，OS/CPU EABI之于C。 掌握如何提升关键代码的效率，如何能够扩充语言的能力。如NIF之于Erlang。 不断地给自己增加挑战，让自己脱离舒适区域。具体方法是：用那些刚好超过自己能力的任务挑战自己，build（尝试） - measure（分析） - learn（学习总结）。然后不断重复。这是lean startup一书中建议的精益创业模式 by: 陈天 （也是leetcode刷题的套路啊！） ","date":"2022-04-11","objectID":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/:0:4","tags":["概念"],"title":"程序开发的思考方法与好习惯","uri":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/"},{"categories":["方法论"],"content":"编程的好习惯 代码不妥协，不屈服于release的压力或人情世故。code review时不仅逻辑正确，格式，算法效率也要合理。真心喜爱你所做的事情。 by: 陈天 (能做到这点真的很难啊) 不要做一只将头埋在沙子中的鸵鸟：计算机异常处理，把可能发生的问题都要考虑到。而不是视而不见。某些事情发生的几率太小了，小到不值得我们花心思去处理；或者，某些事情发生后的后果太严重了，严重到我们只能祈祷上帝它不会发生。by: 陈天 （我身边有很多优秀的人，总会把有很小可能性发生的事也考虑到，值得学习这种精神！） ","date":"2022-04-11","objectID":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/:0:5","tags":["概念"],"title":"程序开发的思考方法与好习惯","uri":"/20220411-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/"},{"categories":["基础设施"],"content":"x509: certificate signed by unknown authority docker pull 或 docker login 192.1.11.18 报错 Error response from daemon: Get \"https://192.1.11.18/v2/\": x509: certificate signed by unknown authority 解决方法： 在/etc/docker/daemon.json/daemon.json 添加 {insecure-registries\":[\"192.1.11.18\"]}, sudo systemctl restart docker MacOS Docker Desktop -\u003e Preferences -\u003e Docker Engine Configure the Docker daemon by typing a json Docker daemon configuration file. 添加 \"insecure-registries\":[\"192.1.11.18\"] { \"experimental\": false, \"builder\": { \"gc\": { \"defaultKeepStorage\": \"20GB\", \"enabled\": true } }, \"features\": { \"buildkit\": true }, \"insecure-registries\":[\"10.1.110.188\"] } ","date":"2022-04-08","objectID":"/20220405-docker%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:0:1","tags":["Docker"],"title":"Docker问题处理","uri":"/20220405-docker%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["网络"],"content":"现象 您的连接不是私密连接 攻击者可能会试图从 xxx.xxx.xx.xx 窃取您的信息（例如：密码、通讯内容或信用卡信息）。了解详情 NET::ERR_CERT_INVALID ","date":"2022-04-07","objectID":"/20220407-%E8%A7%A3%E5%86%B3chrome%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E8%BF%9E%E6%8E%A5/:1:0","tags":["浏览器"],"title":"Chrome 您的连接不是私密连接","uri":"/20220407-%E8%A7%A3%E5%86%B3chrome%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E8%BF%9E%E6%8E%A5/"},{"categories":["网络"],"content":"解决 当前页面输入 thisisunsafe 后，自动刷新。 ","date":"2022-04-07","objectID":"/20220407-%E8%A7%A3%E5%86%B3chrome%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E8%BF%9E%E6%8E%A5/:2:0","tags":["浏览器"],"title":"Chrome 您的连接不是私密连接","uri":"/20220407-%E8%A7%A3%E5%86%B3chrome%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E8%BF%9E%E6%8E%A5/"},{"categories":["Python"],"content":"《Flask Web开发实战 入门、进阶与原理解析》好书啊 ISBN: 9787111606598 ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:0:0","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"基本概念 ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:1:0","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"路由 按某路线发送，路由是一个简单的URL，它指向一个视图函数。 ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:1:1","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"注册路由 route 设置URL规则，建立URL和函数间的映射关系。这个函数被称为视图函数（view function） 代码层面是被装饰器 app.route('/') 装饰的函数。 端点默认值为视图函数的名称。通过端点（endpoint），可以通过url_for('index')获取路由的相对URL。 获取绝对URL，可以使用url_for('index', _external=True) URL（Uniform Resource Lacator，统一资源定位符） 相对URL（内部URL） 不包含域名的URL，如：/user/lucky 可以绑定多个URL 动态URL 带有默认值的URL 避免404 ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:1:2","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"flask shell 自动包含关于flask的上下文，可以直接在命令行中使用flask提供的功能 app.name 在视图函数加 app.cli.command('xxx')装饰器，可以将命令添加到命令行，方便调试。 flask xxx 执行 ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:1:3","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"MVC MVC（Model-View-Controller，模型-视图-控制器） 程序被分为三个组件： 数据处理（Model） 用户界面（View） 交互逻辑（Controller） 使用了app.route（）装饰器的函数仍被称为视图函数，同时会使用“\u003c函数名\u003e视图”（比如index视图）的形式来代指某个视图函数。 控制器 - 视图函数 视图 - 界面 模型 - SQLAlchemy ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:1:4","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"项目配置 避免硬编码（hard coded） 配置章节 app.config[‘ADMIN_NAME’] = ‘Peter’ 配置的名称必须是全大写形式，小写的变量将不会被读取。 使用update（）方法则可以一次加载多个值： app.config.update( TESTING=True, SECRET_KEY='_5#yF4Q8z\\n\\xec]/' ) 读取值 value = app.config[‘ADMIN_NAME’] ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:1:5","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"运行 flask run --host=0.0.0.0 --port=5050 ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:2:0","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"Flask 与 HTTP RFC 互联网设计文档 Request-Response-Cycle（请求-响应-周期） Request Message 报文 Response Message 报文 ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:3:0","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"URL组成 http:// 协议字符串 spaceack.com 域名 /path 资源路径 ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:3:1","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"请求报文 报文首部： 请求行（方法，URL，协议） GET /hello HTTP/1.1 报文头 （头字段）： Host: spaceack.com Connection: keep-alive User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8 报文主体 ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:3:2","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"HTTP方法 GET：获取资源 POST：创建资源 PUT：更新资源 DELETE：删除资源 HEAD：获取资源的属性，不返回资源内容 OPTIONS：询问支持的方法，不返回资源内容 请求方法详细说明： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods ","date":"2022-03-30","objectID":"/20220330-flask%E7%AC%94%E8%AE%B0/:3:3","tags":["flask","web"],"title":"Flask笔记","uri":"/20220330-flask%E7%AC%94%E8%AE%B0/"},{"categories":["MacOS"],"content":"MacOS常用技巧 ","date":"2022-02-24","objectID":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/:0:0","tags":["MacOS"],"title":"MacOS 常用技巧 Apple M1 chip（持续更新～··）","uri":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["MacOS"],"content":"快捷键 截图 Command + Shift + 5 切换输入法 中/英 切换键 复制 粘贴 Command + C Command + V 剪切 Command + X 文件剪切粘贴 选中文件 Command + C 到目标目录 Command + Option V 聚焦搜索框🔍 Command + SPACE 或 键盘功能键 F4🔍 ","date":"2022-02-24","objectID":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/:1:0","tags":["MacOS"],"title":"MacOS 常用技巧 Apple M1 chip（持续更新～··）","uri":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["MacOS"],"content":"软件清单 GIf录制 LICEcap 按键显示 keycastr brew install --cask keycastr 菜单栏堆叠显示hidden barbrew install --cask hiddenbar OpenVPN Tunnelblick Ubuntu虚拟机 Multipass 开源通用虚拟机UTM ","date":"2022-02-24","objectID":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/:2:0","tags":["MacOS"],"title":"MacOS 常用技巧 Apple M1 chip（持续更新～··）","uri":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["MacOS"],"content":"How to ","date":"2022-02-24","objectID":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/:3:0","tags":["MacOS"],"title":"MacOS 常用技巧 Apple M1 chip（持续更新～··）","uri":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["MacOS"],"content":"如何查看 Mac wifi 密码 聚焦搜索框 🔍 搜索 密钥串访问 查看网络密码～ ","date":"2022-02-24","objectID":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/:3:1","tags":["MacOS"],"title":"MacOS 常用技巧 Apple M1 chip（持续更新～··）","uri":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["MacOS"],"content":"brew # Common Lisp compiler brew install sbcl ","date":"2022-02-24","objectID":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/:4:0","tags":["MacOS"],"title":"MacOS 常用技巧 Apple M1 chip（持续更新～··）","uri":"/macos%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["消息队列"],"content":"rocketmq Apache RocketMQ开发者指南-官方 Apache RocketMQ开发者指南 rocketmq-externals ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:0:0","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"安装运行 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:1:0","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"测试环境内存占用过大的问题 现象： 内存负载高，甚至系统卡死，服务无法启动。 解决方法： 修改文件/rocketmq/bin/runbroker.sh, 将 #JAVA_OPT=\"${JAVA_OPT} -server -Xms8g -Xmx8g\" 改为 JAVA_OPT=\"${JAVA_OPT} -server -Xms256m -Xmx256m 修改文件/rocketmq/bin/runserver.sh, 将 JAVA_OPT=\"${JAVA_OPT} -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\" 改为 JAVA_OPT=\"${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:1:1","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"启动服务 cd /opt/rocketmq/bin 启动mqnamesrv nohup sh mqnamesrv \u0026 查看名字服务日志 tail -f ~/logs/rocketmqlogs/namesrv.log 启动 broker 并允许自动创建topic nohup sh mqbroker -n localhost:9876 autoCreateTopicEnable=true \u0026 查看 broker 日志tail -f ~/logs/rocketmqlogs/broker.log ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:1:2","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"停止服务 停止broker sh mqshutdown broker 停止mqnamesrv sh mqshutdown namesrv ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:1:3","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"基础概念 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:0","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"Message Model 组成 Producer 生产消息 Consumer 消费消息 Broker 存储消息 每个Broker 存储多个Topic的消息 每个Topic的消息可分片存储于不同的·Broker Message Queue 存储消息的物理地址。 每个Topic中的消息地址存储于多个·Message Queue中。 ConsumerGroup 由多个Consumer实例组成。 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:1","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"消息生产者 （Producer） 发送消息到broker,有多种发送方式： 同步发送 (需要 Brocker ack） 异步发送 (需要 Brocker ack） 顺序发送 单向发送 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:2","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"消息消费者 （Consumer） 消费消息，有多种消费方式： 拉取式消费 推动式消费 实时性较高。 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:3","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"主题（Topic） 表示一类消息的集合，消息订阅的基本单位。 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:4","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"消息（Message） 消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:5","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"标签（Tag） 为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:6","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"名字服务（Name Server） 路由消息的提供者，生产者或消费者通过名字服务路由到指定的Broker IP列表。 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:7","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"拉取式消费（Pull Consumer） 消费者从broker拉取消息，消费者可以指定拉取消息的数量，消费者可以指定拉取消息的时间间隔？ ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:8","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"推动式消费（Push Consumer） Broker 收到数据后主动推送给消费端。实时性较高。 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:9","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"生产者组（Producer Group） ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:10","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"消费者组（Consumer Group） ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:11","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"集群消费（Clusetering） 集群消费模式下,相同 Consumer Group的每个Consumer实例平均分摊消息。 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:12","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"广播消费（Broadcasting） 广播消费模式下,每个Consumer实例都消费所有Topic的消息。 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:13","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"普通顺序消息（Normal Ordered Message） 普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:14","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"严格顺序消息（Strictly Ordered Message） 严格顺序消息模式下，消费者收到的所有消息均是有顺序的。 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:2:15","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"mqadmin 命令 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:3:0","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"查看所有消费者组 ./mqadmin consumerProgress -n 127.0.0.1:9876 ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:3:1","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"GUI可视化管理控制台 rocketmq-console-ng git clone https://github.com/apache/rocketmq-externals.git git checkout origin/release-rocketmq-console-1.0.0 具体安装方式可见README.md docker pull styletang/rocketmq-console-ng sudo docker run -e \"JAVA_OPTS=-Drocketmq.namesrv.addr=127.0.0.1:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false\" -p 8080:8080 -t styletang/rocketmq-console-ng ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:4:0","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":["消息队列"],"content":"界面功能 首页/Dashboard Broker Top 10 broker的消息总数 前10名条形排名图。 Topic Top 10 每个Topic的消息总数 前10名条形排名图。 Broker 5min trend Topic 5min trend OPS NameSvrAddrList 需要监控的 rocketmq 名字服务器地址列表。 可更新。 Cluster 可查看集群状态详情。配置详情。 broker 列表 broker 名称 编号 地址 版本 生产消息TPS 消费消息TPS 昨日/今日 生产总数 昨日/今日 消费总数 Topic 新增/更新 Topic clusterName 集群名 BROKER_NAME broker 名称 topicName Topic 名称 writeQueueNums 写队列数量 readQueueNums 读队列数量 perm 读写权限 （默认为6 可读可写 4 仅读 2 仅写） 查看Topic列表（NORMAL，RETRY，DLQ 死信队列筛选） 状态 QUEUE minOffset maxOffset lastUpdateTime route consumer manage SubscriptionGroup Delay LastConsumeTime Broker Queue conusmerClient brokerOffeset consumerOffset diffTotal lastTimeStamp RESET CONSUMER OFFSET DELETE Consumer 显示订阅组 SubscriptionGroup状态。可以查看消费者是否成功订阅（在线）。 Producer Message 这个最有用了，可以查看消息的详细信息。可根据 topic, 按照时间，MESSAGE_KEY或MESSAGE ID 查找小心。有没有消费？被谁消费了？很方便查询。 Message ID Topic Tag key Storetime Message body message TrackList consumerGroup trackType (CONSUMED,UNCONSUMED,NOT_ONLINE) RESEND MESSAGE _ VIEW EXCEPTION ","date":"2022-02-15","objectID":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/:4:1","tags":["MQ","RocketMQ"],"title":"RocketMQ笔记","uri":"/20220215-rocketmq%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"阅读清单 书 书号 时间 状态 备注 《密码学与网络安全》 ISBN 7-302-11490-0/TP 7540 在读 第一次阅读 ","date":"2021-12-31","objectID":"/book/:0:1","tags":null,"title":"读书","uri":"/book/"},{"categories":["消息队列"],"content":" AMQPChannelError 异常捕获信息： (406, 'PRECONDITION_FAILED - delivery acknowledgement on channel 1 timed out. Timeout value used: 1800000 ms. This timeout value can be configured, see consumers doc guide to learn more') 其他人也与到过这个问题 按照官方文档配置超时参数后问题解决。 pika.ConnectionParameters(heartbeat=600, blocked_connection_timeout=300) DOC: heartbeat_and_blocked_timeouts ","date":"2021-08-27","objectID":"/20210827-rabbitmq-pika%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/:0:0","tags":["MQ","RabbitMQ"],"title":"RabbitMQ pika错误处理 delivery acknowledgement on channel 1 timed out","uri":"/20210827-rabbitmq-pika%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"categories":["Linux"],"content":"查看磁盘 sudo fdisk -l sudo lsblk sudo mkfs -t ext4 /dev/mmcblk1 # 格式化 sudo mount /dev/mmcblk1 /home/root/data/ ","date":"2021-07-10","objectID":"/20210710-%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/:0:1","tags":["fdisk","lsblk","mount","mkfs"],"title":"Linux 磁盘挂载","uri":"/20210710-%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/"},{"categories":["Linux"],"content":"卸载挂载 sudo umount /dev/mmcblk1 ","date":"2021-07-10","objectID":"/20210710-%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/:0:2","tags":["fdisk","lsblk","mount","mkfs"],"title":"Linux 磁盘挂载","uri":"/20210710-%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/"},{"categories":["Linux"],"content":"自动挂载 sudo blkid # 获取UUID sudo vim /etc/fstab UUID=6b7eaf8d-0b66-6e26-bdff-fa63f7dd1126 /u01 ext4 defaults 1 1 ","date":"2021-07-10","objectID":"/20210710-%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/:0:3","tags":["fdisk","lsblk","mount","mkfs"],"title":"Linux 磁盘挂载","uri":"/20210710-%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/"},{"categories":["算法"],"content":"题目 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 进阶： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 1 class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -\u003e List[int]: result = [] for i2, n2 in enumerate(nums2): for i1, n1 in enumerate(nums1): if n1 == n2: result.append(n2) nums1.pop(i1) break return result ","date":"2021-06-24","objectID":"/20210624-leetcode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-ii/:0:1","tags":["python","算法","leetcode","简单"],"title":"leetcode-350-两个数组的交集 II","uri":"/20210624-leetcode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-ii/"},{"categories":["算法"],"content":"题解2 class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -\u003e List[int]: result = [] len_num1 = len(nums1) len_num2 = len(nums2) if len_num1 \u003e= len_num2: for i2, n2 in enumerate(nums2): for i1, n1 in enumerate(nums1): if n1 == n2: result.append(n2) nums1.pop(i1) break else: for i1, n1 in enumerate(nums1): for i2, n2 in enumerate(nums2): if n1 == n2: result.append(n2) nums2.pop(i2) break return result ","date":"2021-06-24","objectID":"/20210624-leetcode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-ii/:0:2","tags":["python","算法","leetcode","简单"],"title":"leetcode-350-两个数组的交集 II","uri":"/20210624-leetcode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-ii/"},{"categories":null,"content":"2022各种活动的战利品 阿里云抱枕 x1 CSDN摆件 x1 OpenEuler 3D月球灯 x1 OpenEuler 机械伞 x1 稀土掘金 宇航员手机支架 x1 指尖陀螺 x1 小风扇 x1 阿里云抱枕阿里云抱枕 \" 阿里云抱枕 CSDN摆件CSDN摆件 \" CSDN摆件 OpenEuler 3D月球灯(暖色)OpenEuler 3D月球灯(暖色) \" OpenEuler 3D月球灯(暖色) OpenEuler 3D月球灯(冷色)OpenEuler 3D月球灯(冷色) \" OpenEuler 3D月球灯(冷色) OpenEuler 机械伞OpenEuler 机械伞 \" OpenEuler 机械伞 开关的开伞按钮很赞和透视的机械结构很赞OpenEuler 机械伞 \" 开关的开伞按钮很赞和透视的机械结构很赞 宇航员手机支架(正)宇航员手机支架(正) \" 宇航员手机支架(正) 宇航员手机支架(侧)宇航员手机支架(侧) \" 宇航员手机支架(侧) CSDN指尖陀螺CSDN指尖陀螺 \" CSDN指尖陀螺 阿里小风扇阿里小风扇 \" 阿里小风扇 ","date":"2021-04-20","objectID":"/challenge/:1:0","tags":null,"title":"项目挑战","uri":"/challenge/"},{"categories":null,"content":"蓝桥第30期楼赛-Python专题编程挑战赛 2022-02-12 收到了前十名的奖品，程序员鼠标垫一个，好开心～ 程序员（工程狮）版定制鼠标垫程序员（工程狮）版定制鼠标垫 \" 程序员（工程狮）版定制鼠标垫 ","date":"2021-04-20","objectID":"/challenge/:2:0","tags":null,"title":"项目挑战","uri":"/challenge/"},{"categories":null,"content":"阿里云天池第二届云原生编程挑战赛 2021-12-05 收到了 限量版体恤一件，开心/::D 阿里2nd云原生编程挑战赛 限量版T-SHIRT（盒）阿里2nd云原生编程挑战赛 限量版T-SHIRT（盒） \" 阿里2nd云原生编程挑战赛 限量版T-SHIRT（盒） 阿里2nd云原生编程挑战赛 限量版T-SHIRT（签）阿里2nd云原生编程挑战赛 限量版T-SHIRT（签） \" 阿里2nd云原生编程挑战赛 限量版T-SHIRT（签） 阿里2nd云原生编程挑战赛 限量版T-SHIRT（样）阿里2nd云原生编程挑战赛 限量版T-SHIRT（样） \" 阿里2nd云原生编程挑战赛 限量版T-SHIRT（样） ","date":"2021-04-20","objectID":"/challenge/:3:0","tags":null,"title":"项目挑战","uri":"/challenge/"},{"categories":null,"content":"阿里天池 《用Pandas揭秘美国选民的总统喜好》数据分析比赛 2020-12-24 收到了包揽所有奖项的奖品，好开心。 题解 战利品： 天猫精灵方糖 x1 天池古瓷杯 x1 天池xDataWhale联名T恤 x1 天猫精灵方糖x天池古瓷杯天猫精灵方糖x天池古瓷杯 \" 天猫精灵方糖x天池古瓷杯 阿里天池xDataWhale联名T恤(正)天池xDataWhale联名T恤(正) \" 阿里天池xDataWhale联名T恤(正) 阿里天池xDataWhale联名T恤(背)天池xDataWhale联名T恤(背) \" 阿里天池xDataWhale联名T恤(背) ","date":"2021-04-20","objectID":"/challenge/:4:0","tags":null,"title":"项目挑战","uri":"/challenge/"},{"categories":null,"content":"蓝桥第24期楼赛-大数据专题编程挑战赛 2020-12-17 收到了前十名的奖品。好开心，为中华之崛起而编程！ 战利品： 工程狮定制抱枕（橙） x1 写代码的老干部水杯 x1 工程狮定制抱枕-水杯（正）工程狮定制抱枕-水杯（正） \" 工程狮定制抱枕-水杯（正） 工程狮定制抱枕-水杯（背）工程狮定制抱枕-水杯（背） \" 工程狮定制抱枕-水杯（背） toptop \" top ","date":"2021-04-20","objectID":"/challenge/:5:0","tags":null,"title":"项目挑战","uri":"/challenge/"},{"categories":null,"content":"1024程序员节 2020-12-02 收到了参加阿里云天池比赛优胜奖奖品和1024程序员节的礼物，开心。 战利品： 数据英雄 主题T恤（黑） x1 PAI定制保暖杯 x1 1024 BUG FREE 帽子 x1 阿里天池 数据英雄 主题T恤(黑)数据英雄 主题T恤(黑) \" 阿里天池 数据英雄 主题T恤(黑) 阿里 PAI定制保暖杯PAI定制保暖杯 \" 阿里 PAI定制保暖杯 阿里 1024 BUG FREE 帽子1024 BUG FREE 帽子 \" 阿里 1024 BUG FREE 帽子 2020-10-26 收到了比赛的战利品，开心。 战利品： 数据英雄 主题T恤（白） x1 阿里天池 数据英雄 主题T恤(白正)数据英雄 主题T恤(白正) \" 阿里天池 数据英雄 主题T恤(白正) 阿里天池 数据英雄 主题T恤(白背)数据英雄 主题T恤(白背) \" 阿里天池 数据英雄 主题T恤(白背) ","date":"2021-04-20","objectID":"/challenge/:6:0","tags":null,"title":"项目挑战","uri":"/challenge/"},{"categories":null,"content":"蓝桥第23期楼赛-Python专题编程挑战赛 2020-09-25 收到了前三名的奖品，好开心。 战利品： 工程狮定制抱枕（蓝） x1 定制小风扇 x1 工程狮定制抱枕（蓝正）-风扇工程狮定制抱枕（蓝）-风扇 \" 工程狮定制抱枕（蓝正）-风扇 工程狮定制抱枕（蓝背）-风扇工程狮定制抱枕（蓝）-风扇 \" 工程狮定制抱枕（蓝背）-风扇 ","date":"2021-04-20","objectID":"/challenge/:7:0","tags":null,"title":"项目挑战","uri":"/challenge/"},{"categories":null,"content":"阿里天池“超级码力”编程大赛 2020-09-24 收到了优胜奖奖品，开心。 战利品： SuperCoder 主题T恤 x1 Alibaba Cloud SuperCoder 主题T恤阿里 SuperCoder 主题T恤 \" Alibaba Cloud SuperCoder 主题T恤 ","date":"2021-04-20","objectID":"/challenge/:8:0","tags":null,"title":"项目挑战","uri":"/challenge/"},{"categories":null,"content":"腾讯云开发这社区活动 战利品： 鼠年QQ公仔 x1 -- 鼠年QQ公仔(正)鼠年QQ公仔 \" 鼠年QQ公仔(正) 鼠年QQ公仔(背)鼠年QQ公仔 \" 鼠年QQ公仔(背) -- ","date":"2021-04-20","objectID":"/challenge/:9:0","tags":null,"title":"项目挑战","uri":"/challenge/"},{"categories":null,"content":"2020 GitHub Archive Program 2020-07-18 无意中参与了 GitHub北极代码项目， 喜获北极代码库贡献者徽章一枚，开心。 北极代码库贡献者徽章北极代码库贡献者徽章 \" 北极代码库贡献者徽章 ","date":"2021-04-20","objectID":"/challenge/:10:0","tags":null,"title":"项目挑战","uri":"/challenge/"},{"categories":["算法"],"content":"题目描述 有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x \u003c= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回0。 ","date":"2021-01-30","objectID":"/20210130-leetcode-1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/:1:0","tags":["python","算法","堆","leetcode","简单"],"title":"leetcode-1046-最后一块石头的重量 题解","uri":"/20210130-leetcode-1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/"},{"categories":["算法"],"content":"示例 示例 1: 输入：[2,7,4,1,8,1] 输出：1 解释： 先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]， 再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]， 接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]， 最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。 ","date":"2021-01-30","objectID":"/20210130-leetcode-1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/:2:0","tags":["python","算法","堆","leetcode","简单"],"title":"leetcode-1046-最后一块石头的重量 题解","uri":"/20210130-leetcode-1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/"},{"categories":["算法"],"content":"提示： 1 \u003c= stones.length \u003c= 30 1 \u003c= stones[i] \u003c= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/last-stone-weight/ 解题思路 题解1 苯办法， 做递归。 题解1: 执行用时：44 ms, 在所有 Python3 提交中击败了42.77%的用户 内存消耗：14.8 MB, 在所有 Python3 提交中击败了38.92%的用户 import heapq class Solution: def top_two(self, stones): result = heapq.nlargest(2, stones) return max(result), min(result) def lastStoneWeight(self, stones: List[int]) -\u003e int: if len(stones) == 0: return 0 elif len(stones) == 1: return stones[0] elif len(stones) \u003e 1: max, min = self.top_two(stones) if max == min: stones.remove(max) stones.remove(min) if len(stones) == 1: return stones[0] elif len(stones) \u003e 1: return self.lastStoneWeight(stones) elif len(stones) == 0: return 0 else: stones.append(max-min) stones.remove(max) stones.remove(min) if len(stones) == 1: return stones[0] return self.lastStoneWeight(stones) ","date":"2021-01-30","objectID":"/20210130-leetcode-1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/:3:0","tags":["python","算法","堆","leetcode","简单"],"title":"leetcode-1046-最后一块石头的重量 题解","uri":"/20210130-leetcode-1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/"},{"categories":["Linux"],"content":"举个例子，要测试的 ip+port: 192.168.0.100:8080 使用 telnet 命令 telnet 192.168.0.100 8080 连通成功： Trying 192.168.0.100... Connected to 192.168.0.100. Escape character is '^]'. Connection closed by foreign host. 连通失败： rying 192.168.0.100... telnet: Unable to connect to remote host: Connection refused 使用 nc 命令 nc -zvw3 192.168.0.100 8080 参数说明： -z: 仅扫描侦听， 不会发送数据。 -v: 输出详细信息。 -w3: 允许超时3秒~ 连通成功： Connection to 192.168.0.100 8080 port [tcp/http] succeeded! 连通失败： nc: connect to 192.168.0.100 port 8080 (tcp) failed: Connection refused 使用 nmap 命令 nmap 192.168.0.100 -p 8080 连通成功： Starting Nmap 7.80 ( https://nmap.org ) at 2021-01-21 21:30 CST Nmap scan report for 192.168.0.100 Host is up (0.00049s latency). PORT STATE SERVICE 8080/tcp open http Nmap done: 1 IP address (1 host up) scanned in 0.04 seconds 连通失败： Starting Nmap 7.80 ( https://nmap.org ) at 2021-01-21 21:30 CST Nmap scan report for 192.168.0.100 Host is up (0.00029s latency). PORT STATE SERVICE 8080/tcp closed unknown Nmap done: 1 IP address (1 host up) scanned in 0.06 seconds 欢迎访问 spaceack.com ","date":"2021-01-21","objectID":"/20210121-linux%E4%B8%8B%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AAip%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9E%E9%80%9A%E7%8A%B6%E6%80%81/:0:0","tags":["网络","Linux","telnet","nc","nmap"],"title":"Linux下检测某个ip端口的连通状态","uri":"/20210121-linux%E4%B8%8B%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AAip%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9E%E9%80%9A%E7%8A%B6%E6%80%81/"},{"categories":["Linux"],"content":"Ctrl + ~ 为 VScode 调出集成终端的快捷键。同时也是 Rime 输入法方案菜单的快捷键。VScode 的快捷键会被覆盖。 因为 rime 热键 F4 与 CTRL + ~ 作用相同， 这里去掉 CTRL + ~ 热键： sudo vim /usr/share/rime-data/default.yaml 找到 switcher 下的 - Control+grave 删除该行即可，重启或重新部署生效。 文档参考： Rime 定製指南 Rime 必知必会 欢迎访问 spaceack.com ","date":"2021-01-20","objectID":"/20210120-%E8%A7%A3%E5%86%B3vscode%E4%B8%8Elinuxrime%E4%B8%AD%E5%B7%9E%E9%9F%B5%E8%BE%93%E5%85%A5%E6%B3%95ctrl-~%E7%83%AD%E9%94%AE%E5%86%B2%E7%AA%81/:0:0","tags":["rime"],"title":"解决VScode与LinuxRime中州韵输入法CTRL+~热键冲突","uri":"/20210120-%E8%A7%A3%E5%86%B3vscode%E4%B8%8Elinuxrime%E4%B8%AD%E5%B7%9E%E9%9F%B5%E8%BE%93%E5%85%A5%E6%B3%95ctrl-~%E7%83%AD%E9%94%AE%E5%86%B2%E7%AA%81/"},{"categories":["软件工程"],"content":"环境变量的妙用 使用环境变量，可以修改一处，同时修改多个请求的功能， 比如ip变更，端口变更的等场景。 另外，在测试时，如登录后会获得 token ， 其它请求会把 token作为请求参数，那么可以把token` 作为全局变量，自动化测试。 请求地址的 host, port等 最好使用环境变量，避免重复修改。 # 示例 http://127.0.0.1:8000/api/xxx {{scheme}}://{{host}}:{{port}}/api/xxx 从接口返回的token值， 可以从 Postman 中的 Tests 设置为全局变量。 var data = JSON.parse(responseBody); //获取data对象的token值。 var token=data.token; //设置成全局变量 postman.setEnvironmentVariable(\"token\", token); 在请求 Body 体中的变量需要被双引号包裹 # 示例 { \"token\": \"{{token}}\" } 动态变化的时间参数变量，可在 Pre-request Script 中设置全局变量，再由 Body 使用。 pm.globals.unset(\"now\"); var myDate=new Date(); var year = myDate.getFullYear(); var month = myDate.getMonth() + 1; var date = myDate.getDate(); var hours = myDate.getHours(); var min = myDate.getMinutes(); var seconds = myDate.getSeconds(); hours = hours \u003c 10 ? \"0\" + hours : hours; min = min \u003c 10 ? \"0\" + min : min; seconds = seconds \u003c 10 ? \"0\" + seconds : seconds; var date = year + \"-\" + month + \"-\" + date + \" \" + hours + \":\" + min + \":\" + seconds; postman.setGlobalVariable(\"now\", date); // now值： 2020-11-18 21:00:00 ","date":"2020-11-18","objectID":"/20201118-postman%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/:0:1","tags":["postman","软件测试"],"title":"Postman使用技巧","uri":"/20201118-postman%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["软件工程"],"content":"流程图绘制 Draw.io 新建 .dio 的文件即可编辑。 ","date":"2020-11-13","objectID":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/:0:1","tags":["VScode"],"title":"VScode常用插件及配置","uri":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"categories":["软件工程"],"content":"多行编辑 Linux Shift+Ctrl+鼠标列选择 Mac Shift+option+鼠标列选择 ","date":"2020-11-13","objectID":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/:0:2","tags":["VScode"],"title":"VScode常用插件及配置","uri":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"categories":["软件工程"],"content":"TabNine 提供多种代码的自动补全 ","date":"2020-11-13","objectID":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/:0:3","tags":["VScode"],"title":"VScode常用插件及配置","uri":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"categories":["软件工程"],"content":"配置远程编辑 安装插件 remote-browser 文件→首选项→设置 搜索 remoteBrowser.connectionOptions， 编辑 setting.json 添加: #添加远程登录的主机地址、用户账号及访问的端口即可 \"remoteBrowser.connectionOptions\": { \"host\": \"10.x.x.11\", \"username\": \"admin\", \"port\": 22 }, ctrl+shift+p, 使用命令 remote-browser:Connect 链接远程。 VScode右下角将提示已远程登录成功，remote-browser:Connected 文件浏览界面 REMOTE BROWSER 查看远程目录文件。 ","date":"2020-11-13","objectID":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/:0:4","tags":["VScode"],"title":"VScode常用插件及配置","uri":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"categories":["软件工程"],"content":"代码对齐插件 Code alignment 安装插件 Code alignment 选中需要对齐的代码 F1 选择需要对齐的功能：支持等号对齐(Ctrl+ =)， 注释对齐等。 ","date":"2020-11-13","objectID":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/:0:5","tags":["VScode"],"title":"VScode常用插件及配置","uri":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"categories":["软件工程"],"content":"浏览pdf 安装插件 vscode-pdf ","date":"2020-11-13","objectID":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/:0:6","tags":["VScode"],"title":"VScode常用插件及配置","uri":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"categories":["软件工程"],"content":"中文插件 Chinese(Simplified) ","date":"2020-11-13","objectID":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/:0:7","tags":["VScode"],"title":"VScode常用插件及配置","uri":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"categories":["软件工程"],"content":"Java开发 Extension Pack for Java Spring Boot Extension Pack ","date":"2020-11-13","objectID":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/:0:8","tags":["VScode"],"title":"VScode常用插件及配置","uri":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"categories":["软件工程"],"content":"支持 .toml 文件完整特性 Even Better TOML ","date":"2020-11-13","objectID":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/:0:9","tags":["VScode"],"title":"VScode常用插件及配置","uri":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"categories":["软件工程"],"content":"更好的获得错误展示 Error Lens ","date":"2020-11-13","objectID":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/:0:10","tags":["VScode"],"title":"VScode常用插件及配置","uri":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"categories":["软件工程"],"content":"Debugger 程序 CodeLLDB ","date":"2020-11-13","objectID":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/:0:11","tags":["VScode"],"title":"VScode常用插件及配置","uri":"/20201113-vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"categories":["算法"],"content":"题目描述 Enter two strings and delete all characters in the second string from the first string String contains spaces $1\\leq len(str),len(sub) \\leq 10^5$ ","date":"2020-11-07","objectID":"/20201107-%E5%A4%A9%E6%B1%A0%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%91%A8%E8%B5%9B-characterdeletion/:1:0","tags":["python","算法","模拟","简单"],"title":"天池编程大赛周赛-Character deletion","uri":"/20201107-%E5%A4%A9%E6%B1%A0%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%91%A8%E8%B5%9B-characterdeletion/"},{"categories":["算法"],"content":"示例 示例 1: Input: str=”They are students”，sub=”aeiou” Output: ”Thy r stdnts” 来源：九章算法 链接：https://tianchi.aliyun.com/oj/141754208384739500/160296091929219251 解题思路 很简单的模拟题，由于子串可能会比较长， 直接使用 in sub 会导致超时情况， 需要先用集合操作化简。 题解1: 正确的示范 class Solution: \"\"\" @param str: The first string given @param sub: The given second string @return: Returns the deleted string \"\"\" def CharacterDeletion(self, str, sub): # write your code here result = [] sub = set(sub) for s in str: if s in sub: pass else: result.append(s) return \"\".join(result) ","date":"2020-11-07","objectID":"/20201107-%E5%A4%A9%E6%B1%A0%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%91%A8%E8%B5%9B-characterdeletion/:2:0","tags":["python","算法","模拟","简单"],"title":"天池编程大赛周赛-Character deletion","uri":"/20201107-%E5%A4%A9%E6%B1%A0%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%91%A8%E8%B5%9B-characterdeletion/"},{"categories":["算法"],"content":"题目描述 给定一个数字，在数字的任意位置插入一个5，使得插入后的这个数字最大 $$|a| \\leq 10^6$$ ","date":"2020-11-07","objectID":"/20201107-%E5%A4%A9%E6%B1%A0%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%91%A8%E8%B5%9B-%E6%8F%92%E5%85%A5%E4%BA%94/:1:0","tags":["python","算法","模拟","简单"],"title":"天池编程大赛周赛-插入五","uri":"/20201107-%E5%A4%A9%E6%B1%A0%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%91%A8%E8%B5%9B-%E6%8F%92%E5%85%A5%E4%BA%94/"},{"categories":["算法"],"content":"示例 示例 1: 输入: a = 234 输出: 5234 来源：九章算法 链接：https://tianchi.aliyun.com/oj/141758389886413149/160295184768372892 解题思路 很简单的模拟题， 但是还是要注意审题，一看到带有绝对值的取值范围，就要立刻想到负数情况。 又是第二次才AC， 有点儿遗憾。 错误的题解示范: 没有考虑到负数的情况 class Solution: \"\"\" @param a: A number @return: Returns the maximum number after insertion \"\"\" def InsertFive(self, a): # write your code here result = [] used = False for s in str(a): if 5 \u003e= int(s) and not used: result.append('5') result.append(s) used = True else: result.append(s) if not used: result.append('5') return int(\"\".join(result)) 题解1: 正确的示范 class Solution: \"\"\" @param a: A number @return: Returns the maximum number after insertion \"\"\" def InsertFive(self, a): # write your code here result = [] # 插入过5的标记 used = False # 判断正负两种情况 # 正数情况 if a \u003e=0: for s in str(a): if 5 \u003e= int(s) and not used: result.append('5') result.append(s) used = True else: result.append(s) if not used: result.append('5') return int(\"\".join(result)) # 负数情况 else: for s in str(abs(a)): if 5 \u003c int(s) and not used: result.append('5') result.append(s) used = True else: result.append(s) if not used: result.append('5') return -int(\"\".join(result)) ","date":"2020-11-07","objectID":"/20201107-%E5%A4%A9%E6%B1%A0%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%91%A8%E8%B5%9B-%E6%8F%92%E5%85%A5%E4%BA%94/:2:0","tags":["python","算法","模拟","简单"],"title":"天池编程大赛周赛-插入五","uri":"/20201107-%E5%A4%A9%E6%B1%A0%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%91%A8%E8%B5%9B-%E6%8F%92%E5%85%A5%E4%BA%94/"},{"categories":["算法"],"content":"题目描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意： 0 ≤ x, y \u003c 2^31. ","date":"2020-09-27","objectID":"/20200927-leetcode-461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/:1:0","tags":["python","算法","汉明距离","leetcode","位运算","简单"],"title":"leetcode-461-汉明距离","uri":"/20200927-leetcode-461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"},{"categories":["算法"],"content":"示例 示例 1: 输入: x = 1, y = 4 输出: 2 解释: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/hamming-distance/ 解题思路 字符串计数法 题解1: 执行用时：40 ms, 在所有 Python3 提交中击败了69.61%的用户 内存消耗：13.4 MB, 在所有 Python3 提交中击败了28.26%的用户 class Solution: def hammingDistance(self, x: int, y: int) -\u003e int: result = 0 bx = bin(x) by = bin(y) max_len = max(len(bx), len(by)) sbx = bx[2:].zfill(max_len) sby = by[2:].zfill(max_len) for _ in range(max_len): if sbx[_] != sby[_]: result = result + 1 return result 题解2: 位运算 执行用时：36 ms, 在所有 Python3 提交中击败了87.61%的用户 内存消耗：13.4 MB, 在所有 Python3 提交中击败了21.26%的用户 class Solution: def hammingDistance(self, x: int, y: int) -\u003e int: return bin(x^y).count('1') 题解3： 偶数位为0，奇数位为1 0x55555555 = 0b1010101010101010101010101010101 1和0每隔两位交替出现 0x33333333 = 0b110011001100110011001100110011 0x0f0f0f0f = 0b1111000011110000111100001111 0x00ff00ff = 0b111111110000000011111111 1和0每隔两位交替出现 0x0000ffff = 0b1111111111111111 class Solution: def hammingDistance(self, x: int, y: int) -\u003e int: z = x^y z = (z \u0026 0x55555555) + ((z \u003e\u003e 1) \u0026 0x55555555) z = (z \u0026 0x33333333) + ((z \u003e\u003e 2) \u0026 0x33333333) z = (z \u0026 0x0f0f0f0f) + ((z \u003e\u003e 4) \u0026 0x0f0f0f0f) z = (z \u0026 0x00ff00ff) + ((z \u003e\u003e 8) \u0026 0x00ff00ff) z = (z \u0026 0x0000ffff) + ((z \u003e\u003e 16) \u0026 0x0000ffff) return z ","date":"2020-09-27","objectID":"/20200927-leetcode-461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/:2:0","tags":["python","算法","汉明距离","leetcode","位运算","简单"],"title":"leetcode-461-汉明距离","uri":"/20200927-leetcode-461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"},{"categories":["Windows"],"content":" ssh 终端工具： MobaXterm Git GUI客户端工具： SourceTree ","date":"2020-09-22","objectID":"/20200922-windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/:0:0","tags":null,"title":"windows操作系统常用软件","uri":"/20200922-windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"},{"categories":["Python","算法"],"content":"题目描述 2020 年，新冠疫情肆掠全球。约翰·霍普金斯大学 跟踪了全球病例数据，包括总病例数、COVID-19 传播速度以及全球爆发情况。我们拿到了截止于某日的疫情数据，希望通过 Python 统计出我们需要的疫情指标。 ","date":"2020-09-20","objectID":"/20200920-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/:1:0","tags":["python","country-converter","中等","题解","比赛"],"title":"蓝桥楼赛第23期-新冠疫情数据统计 题解","uri":"/20200920-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/"},{"categories":["Python","算法"],"content":"目标 补充 count(data) 函数中的 TODO 部分，使其得到我们需要的结果： 整理指定 data 数据文件，以 JSON 数据返回世界各大洲的的汇总数据。 数据集中仅存在国家和地区名称，不存在大洲数据，需要自行解决。表格中的每个国家/地区都需要划分到实际所在大洲。 需要删除明显统计错误的数据（即：确诊人数、死亡人数、康复人数、现有人数不匹配），缺失人数统计数据使用 0 填充。其余情况无需处理。 def count(data): \"\"\"TODO \"\"\" results = None return results ","date":"2020-09-20","objectID":"/20200920-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/:2:0","tags":["python","country-converter","中等","题解","比赛"],"title":"蓝桥楼赛第23期-新冠疫情数据统计 题解","uri":"/20200920-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/"},{"categories":["Python","算法"],"content":"要求 题目需使用 Python 3.6 完成，可以使用标准库和第三方库。如果你的函数使用了第三方库，提交检测前，务必在线上环境中安装相应库。 使用第三方库时，必须使用 python3.6 -m pip install \u003cpackage_name\u003e 命令安装，保证相应库安装在 Python 3.6 环境中。 函数传入 data 为字符串类型，为数据文件的相对路径。 函数返回 JSON 数据（字符串类型），示例如上，无顺序要求。 需要将函数 count(data) 保存到 covid.py 文件中，并将该文件放置在 /home/shiyanlou/Code 路径下方。 covid.py 文件中仅保留函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3.6 covid.py 命令调用 Python 3.6。 ","date":"2020-09-20","objectID":"/20200920-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/:3:0","tags":["python","country-converter","中等","题解","比赛"],"title":"蓝桥楼赛第23期-新冠疫情数据统计 题解","uri":"/20200920-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/"},{"categories":["Python","算法"],"content":"提示 country-converter 库提供了转换大洲数据的方法，你可以通过官方提供的 示例学习。线上环境中安装 country-converter 的命令为：python3.6 -m pip install setuptools \u0026\u0026 python3.6 -m pip install country-converter def clean_up(folder): \"\"\"TODO \"\"\" file_list = {\"folder_name\":file_nums} return file_list ","date":"2020-09-20","objectID":"/20200920-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/:4:0","tags":["python","country-converter","中等","题解","比赛"],"title":"蓝桥楼赛第23期-新冠疫情数据统计 题解","uri":"/20200920-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/"},{"categories":["Python","算法"],"content":"示例 首先，打开终端，使用以下命令将数据文件下载至环境中： cd /home/shiyanlou/Code wget https://labfile.oss.aliyuncs.com/courses/2799/cases_country.csv cases_country.csv 部分数据截图如下，其中 ISO3 为国家/地区标准代码： count(data) 函数最终返回数据格式示例如下（数据非真实情况）： (results = { \"Confirmed\": { \"Africa\": 1203024, \"Asia\": 6420215, \"Oceania\": 25346, \"Europe\": 3311213, \"America\": 1023402, \"Others\": 13443, \"Total\": 15440234 }, \"Deaths\": { \"Africa\": 22222, \"Asia\": 133126, \"Oceania\": 556, \"Europe\": 111431, \"America\": 51155, \"Others\": 502, \"Total\": 616513 }, \"Recovered\": { \"Africa\": 130522, \"Asia\": 5163035, \"Oceania\": 21212, \"Europe\": 1112545, \"America\": 214106, \"Others\": 1424, \"Total\": 13131033 }, \"Active\": { \"Africa\": 244262, \"Asia\": 1124052, \"Oceania\": 4252, \"Europe\": 1201515, \"America\": 121345, \"Others\": 3455, \"Total\": 3612602 } }) 返回数据中，Confirmed，Deaths，Recovered，Active 分别表示：确诊人数、死亡人数、康复人数、现有人数。而 Africa，Asia，Oceania，Europe，America，Others 分别表示：非洲、亚洲、大洋洲、欧洲、美洲（北美洲和南美洲）和其他的相应人数，Others 其他为非国家/地区的数据项。Total 表示数据总和。所有数值数据为 Int 类型。 来源：蓝桥（实验楼） 链接：https://www.lanqiao.cn/challenges/50212/ 解题思路 直接使用 country-converter 库可能会超时， 而且线上环境容易忘记安装。 这里首先用 country-converter库构造一个ISO3码对应大洲的字典。把字典直接加入到代码。 ISO3_converter = {} import country_converter as coco #...此处应是一个for循环... ISO3_converter[iso3_code] = coco.convert(names=[[iso3_code]], to='converter') # ... 最后根据题意， 以json格式输出。 题解1: import csv import json ISO3_converter = {'AFG': 'Asia', 'ALB': 'Europe', 'DZA': 'Africa', 'AND': 'Europe', 'AGO': 'Africa', 'ATG': 'America', 'ARG': 'America', 'ARM': 'Asia', 'AUS': 'Oceania', 'AUT': 'Europe', 'AZE': 'Asia', 'BHS': 'America', 'BHR': 'Asia', 'BGD': 'Asia', 'BRB': 'America', 'BLR': 'Europe', 'BEL': 'Europe', 'BLZ': 'America', 'BEN': 'Africa', 'BTN': 'Asia', 'BOL': 'America', 'BIH': 'Europe', 'BWA': 'Africa', 'BRA': 'America', 'BRN': 'Asia', 'BGR': 'Europe', 'BFA': 'Africa', 'MMR': 'Asia', 'BDI': 'Africa', 'CPV': 'Africa', 'KHM': 'Asia', 'CMR': 'Africa', 'CAN': 'America', 'CAF': 'Africa', 'TCD': 'Africa', 'CHL': 'America', 'CHN': 'Asia', 'COL': 'America', 'COM': 'Africa', 'COG': 'Africa', 'COD': 'Africa', 'CRI': 'America', 'CIV': 'Africa', 'HRV': 'Europe', 'CUB': 'America', 'CYP': 'Asia', 'CZE': 'Europe', 'DNK': 'Europe', 'DJI': 'Africa', 'DMA': 'America', 'DOM': 'America', 'ECU': 'America', 'EGY': 'Africa', 'SLV': 'America', 'GNQ': 'Africa', 'ERI': 'Africa', 'EST': 'Europe', 'SWZ': 'Africa', 'ETH': 'Africa', 'FJI': 'Oceania', 'FIN': 'Europe', 'FRA': 'Europe', 'GAB': 'Africa', 'GMB': 'Africa', 'GEO': 'Asia', 'DEU': 'Europe', 'GHA': 'Africa', 'GRC': 'Europe', 'GRD': 'America', 'GTM': 'America', 'GIN': 'Africa', 'GNB': 'Africa', 'GUY': 'America', 'HTI': 'America', 'VAT': 'Europe', 'HND': 'America', 'HUN': 'Europe', 'ISL': 'Europe', 'IND': 'Asia', 'IDN': 'Asia', 'IRN': 'Asia', 'IRQ': 'Asia', 'IRL': 'Europe', 'ISR': 'Asia', 'ITA': 'Europe', 'JAM': 'America', 'JPN': 'Asia', 'JOR': 'Asia', 'KAZ': 'Asia', 'KEN': 'Africa', 'KOR': 'Asia', 'KWT': 'Asia', 'KGZ': 'Asia', 'LAO': 'Asia', 'LVA': 'Europe', 'LBN': 'Asia', 'LSO': 'Africa', 'LBR': 'Africa', 'LBY': 'Africa', 'LIE': 'Europe', 'LTU': 'Europe', 'LUX': 'Europe', 'MDG': 'Africa', 'MWI': 'Africa', 'MYS': 'Asia', 'MDV': 'Asia', 'MLI': 'Africa', 'MLT': 'Europe', 'MRT': 'Africa', 'MUS': 'Africa', 'MEX': 'America', 'MDA': 'Europe', 'MCO': 'Europe', 'MNG': 'Asia', 'MNE': 'Europe', 'MAR': 'Africa', 'MOZ': 'Africa', 'NAM': 'Africa', 'NPL': 'Asia', 'NLD': 'Europe', 'NZL': 'Oceania', 'NIC': 'America', 'NER': 'Africa', 'NGA': 'Africa', 'MKD': 'Europe', 'NOR': 'Europe', 'OMN': 'Asia', 'PAK': 'Asia', 'PAN': 'America', 'PNG': 'Oceania', 'PRY': 'America', 'PER': 'America', 'PHL': 'Asia', 'POL': 'Europe', 'PRT': 'Europe', 'QAT': 'Asia', 'ROU': 'Europe', 'RUS': 'Europe', 'RWA': 'Africa', 'KNA': 'America', 'LCA': 'America', 'VCT': 'America', 'SMR': 'Europe', 'STP': 'Africa', 'SAU': 'Asia', 'SEN': 'Africa', 'SRB': 'Europe', 'SYC': 'Africa', 'SLE': 'Africa', 'SGP': 'Asia', 'SVK': 'Europe', 'SVN': 'Europe', 'SOM': 'Africa', 'ZAF': 'Africa', 'SSD': 'Africa', 'ESP': 'Europe', 'LKA': 'Asia', 'SDN': 'Afric","date":"2020-09-20","objectID":"/20200920-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/:5:0","tags":["python","country-converter","中等","题解","比赛"],"title":"蓝桥楼赛第23期-新冠疫情数据统计 题解","uri":"/20200920-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E6%96%B0%E5%86%A0%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/"},{"categories":["算法"],"content":"题目描述 蒜头君是一个 P 社玩家，每天从计蒜客下班回家之后的第一件事情就是打开《群星》，开始继续他的第四天灾之旅。这次他把注意力集中到了银河市场里面。 银河市场里面商品的价格都通过以下公式计算： P = B * basePrice / S price = \\displaystyle \\frac{buy}{sell} * basePriceprice= sell buy ​ ∗basePrice 其中 priceprice 是某个商品现在的单位价格，sellsell 是该商品目前所有玩家在银河市场的总出售量， buy 是该商品目前所有玩家在银河市场的总购买量（buy 或 sell 为 0 的时候在公式里面均被视为 1），basePrice 是该商品的起始单位价格。 可是暗物质并不适用这条规则，因为蒜头君垄断了整个银河系的暗物质生产，并决定让暗物质的价格和合金在银河市场里面的价格挂钩，即暗物质的 单位价格 和合金 单位价格 的 比值 是一直不变的。 现在蒜头君手上有银河市场里面合金的完整交易数据、合金与暗物质各自的起始价格，现在蒜头君需要知道每一次合金交易之后暗物质当前的单价应该是多少。 输入格式 第一行有三个实数 a（为 alloy 的简写）和 dmdm（为 dark matter 的简写），为合金和暗物质的初始单位价格，和一个整数 n 表示蒜头君手上拿到的合金交易次数。 往后 n 行每一行输入一个实数 x： 如果为正数，表示这次交易是某个玩家从银河市场购买了合金，且购买的量是 x 单位。 如果为负数，表示这次交易是某个玩家向银河市场出售了合金，且出售的量是 −x 单位。 数据约定 1\\le n \\le 100001≤n≤10000，0\u003ca,dm\\le100000\u003ca,dm≤10000，0\u003c|x|\\le100000\u003c∣x∣≤10000。 输出格式 输出总共有 nn 行，每一行表示每一次合金交易之后暗物质的单价是多少，你的答案和标准答案的误差不能超过 10^{-3}10 −3 。 如果你觉得题意比较难理解，可以再认真看一看样例数据和样例解释。 ","date":"2020-09-18","objectID":"/20200918-2020%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%E9%A2%84%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BA-%E7%BE%A4%E6%98%9F/:1:0","tags":["算法","python","简单","模拟"],"title":"2020计蒜之道预赛第二场-群星","uri":"/20200918-2020%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%E9%A2%84%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BA-%E7%BE%A4%E6%98%9F/"},{"categories":["算法"],"content":"示例 示例 1: 输入 3.2 16 3 1.5 -6 16.5 输出 24.000 4.000 48.000 样例解释 银河市场建立的时候，合金和暗物质的单价分别为 3.2 和 16。 第一次交易，某个玩家从银河市场中买走了 1.5 单位合金，此时暗物质的单价为 16\\times 1.5/1= 24 16×1.5/1=24。 第二次交易，某个玩家向银河市场中出售了 6 单位合金，此时暗物质的单价为 16\\times 1.5/6= 41 6×1.5/6=4。 第三次交易，某个玩家从银河市场中买走了 16.5单位合金，此时暗物质的单价为 16\\times (1.5+16.5)/6= 48 16×(1.5+16.5)/6=48。 解题思路 很简单的模拟题， 题目描述会让人困惑， 通过样例倒是很容易理解。 题解1: a = input().split() bp = float(a[1]) num = int(a[2]) input_line = [] result = [] for x in range(int(num)): input_line.append(input()) # 处理逻辑 sell = 0.0 buy = 0.0 for index, x in enumerate(input_line): x = float(x) sell = sell if sell != 0 else 1.0 buy = buy if buy != 0 else 1.0 if x \u003e 0: buy = buy + x if buy != 1.0 else x if x \u003c 0: sell = sell + abs(x) if sell != 1.0 else abs(x) dm_price = bp * (buy / sell) result.append(dm_price) # 输出结果 for x in result: print(x) ","date":"2020-09-18","objectID":"/20200918-2020%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%E9%A2%84%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BA-%E7%BE%A4%E6%98%9F/:2:0","tags":["算法","python","简单","模拟"],"title":"2020计蒜之道预赛第二场-群星","uri":"/20200918-2020%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%E9%A2%84%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BA-%E7%BE%A4%E6%98%9F/"},{"categories":["Python","算法"],"content":"题目描述 实小楼同学平常的工作比较繁杂，经常需要处理各类文档，几天时间桌面上就累积了一堆不同类型和名称的文档，显得十分杂乱。实小楼想通过 Python 编写一个脚本，能够自动归类整理不同类型的文档。 ","date":"2020-09-17","objectID":"/20200917-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E5%B7%A5%E4%BD%9C%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%E5%BD%92%E7%B1%BB/:1:0","tags":["python","算法","os","中等","题解","比赛"],"title":"蓝桥楼赛第23期-工作文件整理归类 题解","uri":"/20200917-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E5%B7%A5%E4%BD%9C%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%E5%BD%92%E7%B1%BB/"},{"categories":["Python","算法"],"content":"目标 补充 clean_up(folder) 函数中的 TODO 部分，使其实现我们需要的功能： 归类整理指定 folder 文件夹中的不同类型文档，如上方示意图所示。 如果存在多个不同类型，但名称相同的文件，则归类为同一文件夹中， 并将此文件夹命名为与文件一致的名称。 其余名称不同，类型相同的文件，则按照文件类型归类为同一文件夹中，并将此文件夹命名为文档类型名称。 如果文件无类型后缀，则统一存放至名称为 others 的文件夹中。 整理后的文件和文件夹均存放在 folder 文件夹中，并移除原文档。 函数最终返回字典类型的 file_list，包含整理后的文件夹名称和文件夹中包含的文件数量。 ","date":"2020-09-17","objectID":"/20200917-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E5%B7%A5%E4%BD%9C%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%E5%BD%92%E7%B1%BB/:2:0","tags":["python","算法","os","中等","题解","比赛"],"title":"蓝桥楼赛第23期-工作文件整理归类 题解","uri":"/20200917-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E5%B7%A5%E4%BD%9C%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%E5%BD%92%E7%B1%BB/"},{"categories":["Python","算法"],"content":"要求 题目需使用 Python 3.6 完成，可以使用标准库，不能使用第三方库。 函数传入 folder 为字符串类型，是脚本文件和所需整理目录的相对路径。 函数返回字典，且应按不同 folder_name 中 file_nums 的数字降序排列，次数相等无先后顺序。 需要将函数 clean_up(folder) 保存到 clean_up_files.py 文件中，并将该文件放置在 /home/shiyanlou/Code 路径下方。 clean_up_files.py 文件中仅保留函数，不要添加测试或执行代码，避免检测时出错。 线上环境调试代码时，请使用 python3.6 clean_up_files.py 命令调用 Python 3.6。 ","date":"2020-09-17","objectID":"/20200917-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E5%B7%A5%E4%BD%9C%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%E5%BD%92%E7%B1%BB/:3:0","tags":["python","算法","os","中等","题解","比赛"],"title":"蓝桥楼赛第23期-工作文件整理归类 题解","uri":"/20200917-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E5%B7%A5%E4%BD%9C%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%E5%BD%92%E7%B1%BB/"},{"categories":["Python","算法"],"content":"提示 文件名中可以存在 . 符号，例如 test.a.csv，这是名为 test.a 的 .csv 文件。 def clean_up(folder): \"\"\"TODO \"\"\" file_list = {\"folder_name\":file_nums} return file_list ","date":"2020-09-17","objectID":"/20200917-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E5%B7%A5%E4%BD%9C%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%E5%BD%92%E7%B1%BB/:4:0","tags":["python","算法","os","中等","题解","比赛"],"title":"蓝桥楼赛第23期-工作文件整理归类 题解","uri":"/20200917-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E5%B7%A5%E4%BD%9C%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%E5%BD%92%E7%B1%BB/"},{"categories":["Python","算法"],"content":"示例 首先，打开终端，使用以下命令生成测试文档： mkdir test_files \u0026\u0026 cd test_files touch project_{a..e}.py \u0026\u0026 touch project_{a..c}.psd \u0026\u0026 touch doc_{1..5}.docx \u0026\u0026 touch data_{5..9}.csv \u0026\u0026 touch file_{1..3} 根据上述生成的测试文档，最终返回结果应该为： file_list = { \"csv\": 5, \"docx\": 5, \"others\": 3, \"py\": 2, \"project_b\": 2, \"project_c\": 2, \"project_a\": 2 } 整理后的目录结构为： . ├── csv │ ├── data_5.csv │ ├── data_6.csv │ ├── data_7.csv │ ├── data_8.csv │ └── data_9.csv ├── docx │ ├── doc_1.docx │ ├── doc_2.docx │ ├── doc_3.docx │ ├── doc_4.docx │ └── doc_5.docx ├── others │ ├── file_1 │ ├── file_2 │ └── file_3 ├── project_a │ ├── project_a.psd │ └── project_a.py ├── project_b │ ├── project_b.psd │ └── project_b.py ├── project_c │ ├── project_c.psd │ └── project_c.py └── py ├── project_d.py └── project_e.py 注意：最终实现效果以完全满足要求为准，而不是仅满足生成的示例测试文档。 示例 2: text = \"@实验楼@shiyanlou 我在 @ 楼赛中中奖啦\"; usernames = ['实验楼', 'shiyanlou'] 来源：蓝桥（实验楼） 链接：https://www.lanqiao.cn/challenges/50212/ 解题思路 考察os, shutil标准库的使用 题解1: import os import shutil from typing import Dict, List def clean_up(folder): \"\"\" \"\"\" # 相对路径 relative_path = folder+os.sep # 对文件名相同的文件过滤，按照\"文件名\": [完整文件名] 的键值存入字典， 最后对列表文件数大于1的文件移入新目录。 for root, dirs, files in os.walk(folder): name_to_files = {} # type: Dict[str: List[str]] # {\"文件名1\": [\"完整文件名\", \"完整文件名2\" ...]， ...} for f in files: if '.' in f: # 分离文件名，扩展名，这里获取文件名 fn = os.path.splitext(f)[0] # 存入字典 name_to_files[fn] = name_to_files[fn] + [f, ] if fn in name_to_files else [f, ] # 遍历字典，创建目录，移动文件 for key in name_to_files: if len(name_to_files[key]) \u003e 1: os.mkdir(relative_path+key) for file_name in name_to_files[key]: # 移动文件 shutil.move(relative_path+file_name, relative_path+key) # 对扩展名相同的文件过滤，按照\"文件名\": [完整文件名] 的键值存入字典， 最后对列表文件数大于1的文件移入新目录。 for root, dirs, files in os.walk(folder): extension_to_files = {} # type: Dict[str: List[str]] # {\"扩展名\": [\"完整文件名\", \"完整文件名2\" ...]， ...} for f in files: if '.' in f: # 分离文件名，扩展名，这里获取扩展名， 取出来的带有'.' ，这里用[1:]过滤 fn = os.path.splitext(f)[1][1:] extension_to_files[fn] = extension_to_files[fn] + [f, ] if fn in extension_to_files else [f, ] # 遍历字典，创建目录，移动文件 for key in extension_to_files: if len(extension_to_files[key]) \u003e 1: os.mkdir(relative_path+key) for extension_name in extension_to_files[key]: shutil.move(relative_path+extension_name, relative_path+key) # 剩下对没有扩展名的文件处理 for root, dirs, files in os.walk(folder): if files: if os.path.exists(relative_path + 'others'): pass else: os.mkdir(relative_path + 'others') for f in files: shutil.move(relative_path + f, relative_path+'others') break file_list = {} # type: Dict[str: int] folder_dirs = os.listdir(folder) # 存入目录名和对应的目录文件数 for fd in folder_dirs: file_list[fd] = len([lists for lists in os.listdir(relative_path + fd) if os.path.isfile(os.path.join(relative_path + fd, lists))]) # 按值排序 file_list = sorted(file_list.items(), key=lambda x: x[1], reverse=True) return dict(file_list) ","date":"2020-09-17","objectID":"/20200917-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E5%B7%A5%E4%BD%9C%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%E5%BD%92%E7%B1%BB/:5:0","tags":["python","算法","os","中等","题解","比赛"],"title":"蓝桥楼赛第23期-工作文件整理归类 题解","uri":"/20200917-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E5%B7%A5%E4%BD%9C%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%E5%BD%92%E7%B1%BB/"},{"categories":["Python"],"content":"题目描述 程序存放的位置 /home/shiyanlou/lab.py ； 实验类名应该为 Lab ； 实验对象中不能插入重复标签； Python 中对象引用问题，尤其如复合对象 list, dict, tuple 的引用问题； 代码中 FIXME 所在上下文存在 Bug； ","date":"2020-09-16","objectID":"/20200916-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC9%E6%9C%9F-%E4%BF%AE%E5%A4%8D%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AE%9E%E9%AA%8C%E7%B1%BB/:1:0","tags":["python","简单","题解"],"title":"蓝桥楼赛第9期-修复未正确实现的实验类 题解","uri":"/20200916-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC9%E6%9C%9F-%E4%BF%AE%E5%A4%8D%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AE%9E%E9%AA%8C%E7%B1%BB/"},{"categories":["Python"],"content":"要求 题目需使用 Python 3.6 完成，不能使用标准库 和 第三方库。 函数传入 text 为字符串类型，可能为空。 函数返回列表，且应按 text 字符串中的出现的正确用户名次数降序排列，次数相等无先后顺序，且不重复。 ","date":"2020-09-16","objectID":"/20200916-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC9%E6%9C%9F-%E4%BF%AE%E5%A4%8D%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AE%9E%E9%AA%8C%E7%B1%BB/:2:0","tags":["python","简单","题解"],"title":"蓝桥楼赛第9期-修复未正确实现的实验类 题解","uri":"/20200916-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC9%E6%9C%9F-%E4%BF%AE%E5%A4%8D%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AE%9E%E9%AA%8C%E7%B1%BB/"},{"categories":["Python"],"content":"示例 然后修复 lab.py 中已经实现的 class Lab，使其能正常工作，lab.py 部分代码如下： class Lab(object): \"\"\" 实验 \"\"\" def __init__(self, name, tags=[]): self.name = name # FIXME self._tags = tags def insert_tag(self, tag): \"\"\" 插入标签，需要检查标签是否存在 \"\"\" # FIXME self._tags.append(tag) @property def tags(self): return self._tags[:] def can_be_started(self, user): \"\"\"判断用户能否启动实验，只有登录的会员用户才能启动实验 \"\"\" # 传入的 user 为用户对象，is_authenticated 为 True 表示已登录 # FIXME if not user.is_authenticated: # 如果用户没有登陆 can = False elif user.is_member: # 如果用户是会员 can = True return can 来源：蓝桥（实验楼） 链接：https://www.lanqiao.cn/challenges/2997/ 解题思路 初始化函数： 传值：被调函数局部变量改变不会影响主调函数局部变量 传址：被调函数局部变量改变会影响主调函数局部变量 传值就是传入一个参数的值，传址就是传入一个参数的地址，也就是内存的地址（相当于指针） Python参数传递方式：传递对象引用（传值和传址的混合方式），如果是数字，字符串，元组则传值；如果是列表，字典则传址； copy使用场景：列表或字典，且内部元素为数字，字符串或元组 deepcopy使用场景：列表或字典，且内部元素包含列表或字典 题解1: import copy class Lab(object): \"\"\" 实验 \"\"\" def __init__(self, name, tags=[]): self.name = name # FIXED tags = copy.deepcopy(tags) self._tags = tags def insert_tag(self, tag): \"\"\" 插入标签，需要检查标签是否存在 \"\"\" # FIXED if tag: if tag not in self._tags: self._tags.append(tag) @property def tags(self): return self._tags[:] def can_be_started(self, user): \"\"\"判断用户能否启动实验，只有登录的会员用户才能启动实验 \"\"\" # 传入的 user 为用户对象，is_authenticated 为 True 表示已登录 # FIXED can = False if user.is_authenticated: if user.is_member: can = True return can 测试 class User(object): def __init__(self, is_authenticated, is_member): self.is_authenticated = is_authenticated self.is_member = is_member user = User(True, True) lab = Lab('LLL', ['python', 'C']) print(lab.tags) # ['python', 'C'] lab.insert_tag('C++') print(lab.tags) # ['python', 'C', 'C++'] lab.insert_tag('C') print(lab.tags) # ['python', 'C', 'C++'] c = lab.can_be_started(user) print(c) True ","date":"2020-09-16","objectID":"/20200916-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC9%E6%9C%9F-%E4%BF%AE%E5%A4%8D%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AE%9E%E9%AA%8C%E7%B1%BB/:3:0","tags":["python","简单","题解"],"title":"蓝桥楼赛第9期-修复未正确实现的实验类 题解","uri":"/20200916-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC9%E6%9C%9F-%E4%BF%AE%E5%A4%8D%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AE%9E%E9%AA%8C%E7%B1%BB/"},{"categories":["Python","算法"],"content":"题目描述 在社交和即时通讯应用中，@ 字符通常用于提醒某人。例如，你在楼赛取得了好成绩，拿了奖品，激动地发送了一条微博并 @实验楼官方微博。本次挑战中，我们希望实现一个函数，能够自动提取出任意文本内容中 @ 字符后面的用户名，这对于日常使用 Python 分析社交媒体文本内容很有帮助。 补充 after_at(text) 函数中的 TODO 部分，使其实现我们需要的功能： 返回一段指定文本 text 中任意 @ 字符后续的正确用户名。 正确的用户名由连续中文字符、下划线和英文字母组成，不包含标点符号、空格和其他特殊字符。 ","date":"2020-09-15","objectID":"/20200915-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E8%A7%A3%E6%9E%90%E7%94%A8%E6%88%B7%E5%90%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":["python","算法","数组","简单","题解","比赛"],"title":"蓝桥楼赛第23期-解析用户名字符串 题解","uri":"/20200915-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E8%A7%A3%E6%9E%90%E7%94%A8%E6%88%B7%E5%90%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python","算法"],"content":"要求 题目需使用 Python 3.6 完成，不能使用标准库 和 第三方库。 函数传入 text 为字符串类型，可能为空。 函数返回列表，且应按 text 字符串中的出现的正确用户名次数降序排列，次数相等无先后顺序，且不重复。 ","date":"2020-09-15","objectID":"/20200915-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E8%A7%A3%E6%9E%90%E7%94%A8%E6%88%B7%E5%90%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":["python","算法","数组","简单","题解","比赛"],"title":"蓝桥楼赛第23期-解析用户名字符串 题解","uri":"/20200915-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E8%A7%A3%E6%9E%90%E7%94%A8%E6%88%B7%E5%90%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python","算法"],"content":"示例 示例 1: text = \"@实验楼 @shiyanlou 我在 @ 楼赛中中奖啦\"; usernames = ['实验楼', 'shiyanlou'] 示例 2: text = \"@实验楼@shiyanlou 我在 @ 楼赛中中奖啦\"; usernames = ['实验楼', 'shiyanlou'] 示例 3: text = \"@shiyanlou @实验楼 我在 @实验楼 楼赛中中奖啦\"; usernames = ['实验楼', 'shiyanlou'] 示例 4: text = \"@!实验楼 @shiyanlou 我在楼赛中中奖啦\"; usernames = ['shiyanlou'] 示例 5: text = \"我在楼赛中中奖啦@\"; usernames = [] 来源：蓝桥（实验楼） 链接：https://www.lanqiao.cn/challenges/50212/ 解题思路 很简单的字符串模拟题。 题解1: def after_at(text): \"\"\"TODO \"\"\" usernames = [] def is_chinese(string): \"\"\" 检查整个字符串是否包含中文 :param string: 需要检查的字符串 :return: bool \"\"\" for ch in string: if u'\\u4e00' \u003c= ch \u003c= u'\\u9fff': return True return False def is_char(char): if is_chinese(char): return True elif char in (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\"): return True else: return False for index, t in enumerate(text): if t == '@': # 避免越界 if index+1 \u003c len(text): if is_char(text[index + 1]): start = index + 1 end = start # 对 @ 后的字符做判断， 截取用户名 for x in text[start:]: if is_char(x): end = end + 1 continue else: if text[start: end] not in usernames: usernames.append(text[start: end]) break return usernames ","date":"2020-09-15","objectID":"/20200915-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E8%A7%A3%E6%9E%90%E7%94%A8%E6%88%B7%E5%90%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/:3:0","tags":["python","算法","数组","简单","题解","比赛"],"title":"蓝桥楼赛第23期-解析用户名字符串 题解","uri":"/20200915-%E8%93%9D%E6%A1%A5%E6%A5%BC%E8%B5%9B%E7%AC%AC23%E6%9C%9F-%E8%A7%A3%E6%9E%90%E7%94%A8%E6%88%B7%E5%90%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["算法"],"content":"题目描述 给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 注意: 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。 ","date":"2020-09-11","objectID":"/20200911-leetcode-628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/:1:0","tags":["python","算法","数组","leetcode","简单"],"title":"leetcode-628-三个数的最大乘积","uri":"/20200911-leetcode-628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"},{"categories":["算法"],"content":"示例 示例 1: 输入: [1,2,3] 输出: 6 示例 2: 输入: [1,2,3,4] 输出: 24 示例 3: 输入: [100,-3,-2,-1,50] 输出: 600 示例 4: 输入: [-100,-3,-2,-1,50] 输出: 15000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/robot-return-to-origin 解题思路 要注意负数部分， 当全都是正数， 解为排序后最后三个数的乘积。 当包含负数时， 因为负数乘负数为正数， 最小的两个负数和最大的一个正数是最优的。 比较选出这两种情况最大的值即可。 题解1: 执行用时：48 ms, 在所有 Python3 提交中击败了95.61%的用户 内存消耗：14.8 MB, 在所有 Python3 提交中击败了98.26%的用户 from typing import List class Solution: def maximumProduct(self, nums: List[int]) -\u003e int: nums.sort() return max( nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3], ) ","date":"2020-09-11","objectID":"/20200911-leetcode-628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/:2:0","tags":["python","算法","数组","leetcode","简单"],"title":"leetcode-628-三个数的最大乘积","uri":"/20200911-leetcode-628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"},{"categories":["基础设施"],"content":" step1: 创建目录 mkdir -p /server/mariadb/{config,data,log} chmod -R 777 /server/mariadb step2: 编写docker-compose.yml version:'3.1'services:mariadb:image:mariadb:10.5.5container_name:\"mariadb1\"restart:alwaysenvironment:MYSQL_USER:\"root\"MYSQL_PASSWORD:\"123456\"MYSQL_ROOT_PASSWORD:\"123456\"TZ:\"Asia/Shanghai\"ports:- \"3306:3306\"volumes:- ./data:/var/lib/mysql- ./log:/var/log/mysql- ./conf/my.cnf:/etc/mysql/my.cnf step3: 拷贝/etc/mysql/my.cnf 到 /server/mariadb/conf/my.cnf docker exec -it mariadb1 bash 此时目录树： - server/ - mariadb/ - data/ - log/ - config/ - my.cnf - docker-compose.yml # The MariaDB configuration file # # The MariaDB/MySQL tools read configuration files in the following order: # 0. \"/etc/mysql/my.cnf\" symlinks to this file, reason why all the rest is read. # 1. \"/etc/mysql/mariadb.cnf\" (this file) to set global defaults, # 2. \"/etc/mysql/conf.d/*.cnf\" to set global options. # 3. \"/etc/mysql/mariadb.conf.d/*.cnf\" to set MariaDB-only options. # 4. \"~/.my.cnf\" to set user-specific options. # # If the same option is defined multiple times, the last one will apply. # # One can use all long options that the program supports. # Run program with --help to get a list of available options and with # --print-defaults to see which it would actually understand and use. # # If you are new to MariaDB, check out https://mariadb.com/kb/en/basic-mariadb-articles/ # # This group is read both by the client and the server # use it for options that affect everything # [client-server] # Port or socket location where to connect # port = 3306 socket = /run/mysqld/mysqld.sock # Import all .cnf files from configuration directory !includedir /etc/mysql/conf.d/ !includedir /etc/mysql/mariadb.conf.d/ step4: 运行启动 docker-compose up -d ","date":"2020-09-10","objectID":"/20200910-%E4%BD%BF%E7%94%A8docker-compose%E5%AE%89%E8%A3%85mariadb/:0:0","tags":["Docker","docker-compose","mariadb"],"title":"使用docker-compose安装mariadb","uri":"/20200910-%E4%BD%BF%E7%94%A8docker-compose%E5%AE%89%E8%A3%85mariadb/"},{"categories":["数据处理"],"content":" step1: 安装pandoc sudo apt install pandoc step2: 安装转换pdf引擎 wkhtmltopdf 下载地址 step3: 执行转换 pandoc --pdf-engine=wkhtmltopdf --metadata pagetitle=\"Spaceack的算法笔记\" 算法笔记.md -o 算法笔记.pdf ","date":"2020-09-09","objectID":"/20200909-%E4%BD%BF%E7%94%A8pandoc%E5%B0%86markdown%E8%BD%AC%E4%B8%BA%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9B%AE%E5%BD%95%E7%9A%84pdf%E6%96%87%E4%BB%B6/:0:0","tags":["tools","pandoc"],"title":"使用pandoc将markdown转为带标签目录的pdf文件","uri":"/20200909-%E4%BD%BF%E7%94%A8pandoc%E5%B0%86markdown%E8%BD%AC%E4%B8%BA%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9B%AE%E5%BD%95%E7%9A%84pdf%E6%96%87%E4%BB%B6/"},{"categories":["数据处理"],"content":"示例： ","date":"2020-09-09","objectID":"/20200909-%E4%BD%BF%E7%94%A8pandoc%E5%B0%86markdown%E8%BD%AC%E4%B8%BA%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9B%AE%E5%BD%95%E7%9A%84pdf%E6%96%87%E4%BB%B6/:1:0","tags":["tools","pandoc"],"title":"使用pandoc将markdown转为带标签目录的pdf文件","uri":"/20200909-%E4%BD%BF%E7%94%A8pandoc%E5%B0%86markdown%E8%BD%AC%E4%B8%BA%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9B%AE%E5%BD%95%E7%9A%84pdf%E6%96%87%E4%BB%B6/"},{"categories":["算法"],"content":"题目描述 给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 ","date":"2020-09-08","objectID":"/20200908-leetcode-77-%E7%BB%84%E5%90%88/:1:0","tags":["python","算法","数组","组合","leetcode","中等","itertools"],"title":"leetcode-77-组合","uri":"/20200908-leetcode-77-%E7%BB%84%E5%90%88/"},{"categories":["算法"],"content":"示例 示例 1: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/robot-return-to-origin 解题思路 虽然是中等题，但是使用python内置函数，就简单了。 组合,没有重复的情况（不放回抽样组合） 使用 itertools.combinations 方法， def combine(self, n: int, k: int) -\u003e List[List[int]]: result = [] for i in itertools.combinations(list(range(1, n+1)), k): result.append(list(i)) return result # [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] 6 其它方法： 组合,有重复的情况（放回抽样组合） 使用 itertools.combinations_with_replacement 方法， def combine(self, n: int, k: int) -\u003e List[List[int]]: result = [] for i in itertools.combinations_with_replacement(list(range(1, n+1)), k): result.append(list(i)) return result # [[1, 1], [1, 2], [1, 3], [1, 4], [2, 2], [2, 3], [2, 4], [3, 3], [3, 4], [4, 4]] 10 排列　（不放回抽样排列）使用 itertools.permutations 方法， def combine(self, n: int, k: int) -\u003e List[List[int]]: result = [] for i in itertools.permutations(list(range(1, n+1)), k): result.append(list(i)) return result # [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]] 12 笛卡尔积 （有放回抽样排列） 使用 itertools.product 方法， def combine(self, n: int, k: int) -\u003e List[List[int]]: result = [] for i in itertools.product(list(range(1, n+1)), repeat = k): result.append(list(i)) return result # [[1, 1], [1, 2], [1, 3], [1, 4], [2, 1], [2, 2], [2, 3], [2, 4], [3, 1], [3, 2], [3, 3], [3, 4], [4, 1], [4, 2], [4, 3], [4, 4]] 16 combinations和permutations返回的是对象地址, 需要将iterator 转换成list 即可 题解1: 执行用时：48 ms, 在所有 Python3 提交中击败了95.61%的用户 内存消耗：14.8 MB, 在所有 Python3 提交中击败了98.26%的用户 import itertools from typing import List class Solution: def combine(self, n: int, k: int) -\u003e List[List[int]]: result = [] for i in itertools.combinations(list(range(1, n+1)), k): result.append(list(i)) return result ","date":"2020-09-08","objectID":"/20200908-leetcode-77-%E7%BB%84%E5%90%88/:2:0","tags":["python","算法","数组","组合","leetcode","中等","itertools"],"title":"leetcode-77-组合","uri":"/20200908-leetcode-77-%E7%BB%84%E5%90%88/"},{"categories":["算法"],"content":"题目描述 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 提示： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。 你可以按任意顺序返回答案。 ","date":"2020-09-07","objectID":"/20200907-leetcode-347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/:1:0","tags":["python","算法","数组","字典","leetcode","中等"],"title":"leetcode-347-前K个高频元素","uri":"/20200907-leetcode-347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"},{"categories":["算法"],"content":"示例 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 示例 3: nums = [4,1,-1,2,-1,2,3], k = 2 输出: [-1,2] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/robot-return-to-origin 解题思路 python对字典的操作要熟练. 基本思路是先把元素和元素个数存入字典, 然后反转key-value. 因为value 有重复的情况, 所以把重复对应的key以List形式作为值. 再次就是对字典按键排序, 值列表合并, 列表二维转一维. 题解1: 执行用时：44 ms, 在所有 Python3 提交中击败了94.56%的用户 内存消耗：16.4 MB, 在所有 Python3 提交中击败了93.97%的用户 from typing import List, Dict, Iterable import operator from functools import reduce class Solution: def topKFrequent(self, nums: List[int], k: int) -\u003e List[int]: rd = {} # type: Dict[int, int] cd = {} # type: Dict[int, List[int]] # 把元素和元素个数对存入字典 for n in nums: if n not in rd: rd[n] = 1 else: rd[n] = rd[n] + 1 # 反转key-value for x in rd: if rd[x] not in cd: cd[rd[x]] = [x] else: cd.setdefault(rd[x], []).append(x) # 字典按键排序 cd_reverse = sorted(cd.keys(), reverse=True) # 值(列表)合并 rl = [cd[x] for x in cd_reverse] # type: List[List[int]] # 二维数组转一维 result = reduce(operator.add, rl) #type: List[int] return result[0:k] ","date":"2020-09-07","objectID":"/20200907-leetcode-347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/:2:0","tags":["python","算法","数组","字典","leetcode","中等"],"title":"leetcode-347-前K个高频元素","uri":"/20200907-leetcode-347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"},{"categories":["算法"],"content":"题目描述 字符串大师赐给了你一种名为\"从头到尾\"的法术，其作用如下： 对一个字符串施加一次该法术的效果是：将一个字符串的第一个字母放到该字符串的结尾。例如对串\"abcd\"施加一次法术后可以得到串\"bcda\"。 现在给你两个字符串，请你判断是否可以通过任意次（可以是0次）该法术将两个字符串变得一模一样。 1 \\leq |s1|, |s2| \\leq 200 字符串仅由小写字母构成 ","date":"2020-09-06","objectID":"/20200906-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC4%E5%9C%BA-from-start-to-end/:1:0","tags":["python","算法","数组","leetcode","简单"],"title":"超级码力初赛第四场 from start to end","uri":"/20200906-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC4%E5%9C%BA-from-start-to-end/"},{"categories":["算法"],"content":"示例 示例 1: 输入： \"abcd\" \"bcda\" 输出： true 示例 2: 输入： \"abcd\" \"abdc\" 输出： false 来源：九章算法 解题思路 简单题， 一次通过。 题解1: 执行用时：101 class Solution: \"\"\" @param s1: the string 1 @param s2: the string 2 @return: judge can s1 change to s2 \"\"\" def judge(self, s1, s2): # write your code here s1 = list(s1) s2 = list(s2) if s1 == s2: return True for _ in range(len(s1)): start = s1.pop(0) s1.append(start) if s1 == s2: return True return False ","date":"2020-09-06","objectID":"/20200906-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC4%E5%9C%BA-from-start-to-end/:2:0","tags":["python","算法","数组","leetcode","简单"],"title":"超级码力初赛第四场 from start to end","uri":"/20200906-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC4%E5%9C%BA-from-start-to-end/"},{"categories":["算法"],"content":"题目描述 定义若一个字符串的每个字符均为'1'，则该字符串称为完美字符串。给定一个只由'0’和'1’组成的字符串s和一个整数k。你可以对字符串进行任意次以下操作 选择字符串的一个区间长度不超过k的区间[l, r]，将区间内的所有'0’修改成'1'，将区间内所有的'1’修改成'0'。 你最少需要多少次操作，可以将字符串s修改成一个完美字符串 1\u003c=len(s)\u003c=100,000 1\u003c=k\u003c=100,000 ","date":"2020-09-05","objectID":"/20200905-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC3%E5%9C%BA-%E5%AE%8C%E7%BE%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":["python","算法","数组","leetcode","简单"],"title":"超级码力初赛第三场 完美字符串","uri":"/20200905-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC3%E5%9C%BA-%E5%AE%8C%E7%BE%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["算法"],"content":"示例 示例 1: 输入: s=\"10101\" k=2 输出: 2 解释: 1. 修改 [1,2] ==\u003e \"11001\" 2. 修改 [2,3] ==\u003e \"11111\" 示例 2: 输入: s=\"00000\" k=3 输出: 2 解释: 1. 修改 [0,2] ==\u003e \"11100\" 2. 修改 [3,4] ==\u003e \"11111\" 来源：九章算法 解题思路 简单的模拟，要注意边界条件，一次通过。 题解1: 执行用时：402 class Solution: \"\"\" @param s: string need to be transformed @param k: minimum char can be transformed in one operation @return: minimum times of transforming all char into '1' \"\"\" def perfectString(self, s, k): # Write your code here. result = 0 s_len = len(s) s_list = list(s) for index, s in enumerate(s_list): if s == 1: continue if s == '0': start_at = index end_at = index if end_at+1 \u003c= s_len: while s_list[end_at] == '0' and end_at - start_at \u003c k: end_at = end_at + 1 if end_at \u003e s_len -1: break for x in range(start_at, end_at): s_list[x] = '1' result = result + 1 return result ","date":"2020-09-05","objectID":"/20200905-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC3%E5%9C%BA-%E5%AE%8C%E7%BE%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":["python","算法","数组","leetcode","简单"],"title":"超级码力初赛第三场 完美字符串","uri":"/20200905-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC3%E5%9C%BA-%E5%AE%8C%E7%BE%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["算法"],"content":"题目描述 小栖有一个区间[a,b]，他准备从中取三个数，他想知道如何取才能使得它们的最小公倍数最大 请直接告诉小栖最小公倍数是多少。 1\u003c=a\u003cb\u003c=5000 b-a \u003e= 2 ","date":"2020-09-05","objectID":"/20200905-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC3%E5%9C%BA-%E6%9C%80%E5%A4%A7%E5%85%AC%E5%80%8D%E6%95%B0/:1:0","tags":["python","算法","最小公倍数","leetcode","简单"],"title":"超级码力初赛第三场 最大公倍数","uri":"/20200905-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC3%E5%9C%BA-%E6%9C%80%E5%A4%A7%E5%85%AC%E5%80%8D%E6%95%B0/"},{"categories":["算法"],"content":"示例 示例 1: 输入: a = 3, b = 6 输出: 60 样例解释: 4，5，6的最小公倍数是60 来源：九章算法 解题思路 每三个数为一组， 算出三个数的最小公倍数，加入到数组排序， 选出最大即可。 暴力枚举要避免超时。 题解1: 执行用时：56 class Solution: \"\"\" @param a: Left margin @param b: Right margin @return: return the greatest common multiple \"\"\" def greatestcommonmultiple(self, a, b): # write your code here def get_max_yinshu(x, y): while (True): if (x \u003c y): x, y = y, x if (x % y == 0): return int(y) else: temp = x % y x = y y = temp tmp = [] aim = list(range(a, b + 1)) # 避免超时 if len(aim) \u003e 6: aim = aim[-1:-6:-1] for x in range(len(aim)): for y in range(len(aim)): for z in range(len(aim)): a = aim[x] b = aim[y] c = aim[z] if a != b != c: if a\u003cb\u003cc: a_b = get_max_yinshu(a, b) a_b = int((a * b) / a_b) result = get_max_yinshu(a_b, c) result = int((a_b * c) / result) tmp.append(result) tmp.sort() return tmp[-1] ","date":"2020-09-05","objectID":"/20200905-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC3%E5%9C%BA-%E6%9C%80%E5%A4%A7%E5%85%AC%E5%80%8D%E6%95%B0/:2:0","tags":["python","算法","最小公倍数","leetcode","简单"],"title":"超级码力初赛第三场 最大公倍数","uri":"/20200905-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC3%E5%9C%BA-%E6%9C%80%E5%A4%A7%E5%85%AC%E5%80%8D%E6%95%B0/"},{"categories":["算法"],"content":"题目描述 给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 ","date":"2020-09-04","objectID":"/20200904-leetcode-414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/:1:0","tags":["python","算法","数组","模拟","leetcode","简单"],"title":"leetcode-414-第三大的数","uri":"/20200904-leetcode-414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/"},{"categories":["算法"],"content":"示例 示例 1: 输入: [3, 2, 1] 输出: 1 解释: 第三大的数是 1. 示例 2: 输入: [1, 2] 输出: 2 解释: 第三大的数不存在, 所以返回最大的数 2 . 示例 3: 输入: [2, 2, 3, 1] 输出: 1 解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。 存在两个值为2的数，它们都排第二。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/third-maximum-number/ 解题思路 题解1 首先用苯办法，定义一个最大长度为三的有序列表，依次从 nums 列表中取值，插入该有序列表。 优点是节约内存， 缺点是判断比较麻烦。 题解2 超级简洁，执行速度快。利用 python 的 heapq 模块的 nlargest() 方法。它会查找最大的n个数， 本质是堆排序。所以输出结果是无序的， 要再用 sort 进行排序。 题解1: 执行用时：80 ms, 在所有 Python3 提交中击败了21.76%的用户 内存消耗：14.4 MB, 在所有 Python3 提交中击败了92.21%的用户 from typing import List class Solution: def thirdMax(self, nums: List[int]) -\u003e int: # 默认右边最大 th = [] while nums: num = nums.pop() if num in th: continue if not th: th.append(num) if len(th) == 1: if num \u003e th[0]: th.append(num) elif num \u003c th[0]: th.insert(0, num) # 这里需要注意， 第二次因为没有continue.会执行到下面的判断，低级错误。 continue if len(th) == 2: if num \u003e th[1]: th.append(num) elif num \u003c th[0]: th.insert(0, num) elif num \u003e th[0]: th.insert(1, num) continue if len(th) == 3: if num \u003e th[2]: th.append(num) del th[0] elif num \u003c th[0]: continue elif num \u003e th[0] and num \u003c th[1]: del th[0] th.insert(0, num) elif num \u003e th[1] and num \u003c th[2]: del th[0] th.insert(1, num) continue # 这里需要注意， 第一次提交下标写的是2，没有考虑到1的情况，要用反向索引-1 return th[-1] if len(th) \u003c 3 else th[0] 题解2 执行用时：32 ms, 在所有 Python3 提交中击败了99.17%的用户 内存消耗：15.9 MB, 在所有 Python3 提交中击败了16.91%的用户 import heapq class Solution: def thirdMax(self, nums: List[int]) -\u003e int: tmp = heapq.nlargest(3, set(nums)) tmp.sort(reverse=True) return tmp[0] if len(tmp) \u003c 3 else tmp[2] ","date":"2020-09-04","objectID":"/20200904-leetcode-414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/:2:0","tags":["python","算法","数组","模拟","leetcode","简单"],"title":"leetcode-414-第三大的数","uri":"/20200904-leetcode-414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/"},{"categories":["算法"],"content":"题目描述 在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。 你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。 提示： 你可以假定时间序列数组的总长度不超过 10000。 你可以假定提莫攻击时间序列中的数字和提莫攻击的中毒持续时间都是非负整数，并且不超过 10,000,000。 ","date":"2020-09-03","objectID":"/20200903-leetcode-495-%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/:1:0","tags":["python","算法","数组","模拟","leetcode","中等"],"title":"leetcode-495-提莫攻击","uri":"/20200903-leetcode-495-%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/"},{"categories":["算法"],"content":"示例 示例 1: 输入: [1,4], 2 输出: 4 原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。 第 4 秒初，提莫再次攻击艾希，使得艾希获得另外 2 秒中毒时间。 所以最终输出 4 秒。 示例 2: 输入: [1,2], 2 输出: 3 原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。 但是第 2 秒初，提莫再次攻击了已经处于中毒状态的艾希。 由于中毒状态不可叠加，提莫在第 2 秒初的这次攻击会在第 3 秒末结束。 所以最终输出 3 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/robot-return-to-origin 解题思路 首先构造一个尽可能包含全部情况示例观察， 比如 [2,5,9,10,11,15,20], 3 然后画个数轴，在上面模拟下，观测规律即可解出。 题解1: 执行用时：328 ms, 在所有 Python3 提交中击败了64.05%的用户 内存消耗：15 MB, 在所有 Python3 提交中击败了39.77%的用户 from typing import List class Solution: def findPoisonedDuration(self, timeSeries: List[int], duration: int) -\u003e int: # 要对 timeSeries 为空的情况作判断， 因为这个没有一次通过，遗憾～ if not timeSeries: return 0 sum_time = duration len_Serie = len(timeSeries) # 一个经常使用的小技巧： 遍历从 1 开始， 下标不用 +1 ， 避免数组越界 for t in range(1, len_Serie): time_span = timeSeries[t] - timeSeries[t-1] # 最简单的情况， 两次攻击间隔大于 中毒时间， 直接累加。 if time_span \u003e= duration: sum_time = sum_time + duration # 当攻击间隔小于中毒时间，要认真思考。 else: last_time_span = duration - time_span sum_time = sum_time + duration - last_time_span return sum_time ","date":"2020-09-03","objectID":"/20200903-leetcode-495-%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/:2:0","tags":["python","算法","数组","模拟","leetcode","中等"],"title":"leetcode-495-提莫攻击","uri":"/20200903-leetcode-495-%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/"},{"categories":["算法"],"content":"题目描述 给定一个二进制数组， 计算其中最大连续1的个数。 注意： 输入的数组只包含 0 和1。 输入数组的长度是正整数，且不超过 10,000。 ","date":"2020-09-02","objectID":"/20200902-leetcode-485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/:1:0","tags":["python","算法","数组","leetcode","简单"],"title":"leetcode-485-最大连续1的个数","uri":"/20200902-leetcode-485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["算法"],"content":"示例 示例 1: 输入: [1,1,0,1,1,1] 输出: 3 解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/robot-return-to-origin 简单，一次通过。 题解1: 执行用时：496 ms, 在所有 Python3 提交中击败了21.67%的用户 内存消耗：13.9 MB, 在所有 Python3 提交中击败了45.58%的用户 class Solution: def findMaxConsecutiveOnes(self, nums) -\u003e int: sum = 0 max_sum = 0 for n in nums: if n == 1: sum = sum + 1 if n == 0: sum = 0 max_sum = sum if sum \u003e max_sum else max_sum return max_sum ","date":"2020-09-02","objectID":"/20200902-leetcode-485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/:2:0","tags":["python","算法","数组","leetcode","简单"],"title":"leetcode-485-最大连续1的个数","uri":"/20200902-leetcode-485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["算法"],"content":"题目描述 有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，…，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。 在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，…，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。 最初，除 0 号房间外的其余所有房间都被锁住。 你可以自由地在房间之间来回走动。 如果能进入每个房间返回 true，否则返回 false。 提示： 1 \u003c= rooms.length \u003c= 1000 0 \u003c= rooms[i].length \u003c= 1000 所有房间中的钥匙数量总计不超过 3000。 ","date":"2020-08-31","objectID":"/20200831-leetcode-841-%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/:1:0","tags":["python","算法","DFS","leetcode","中等"],"title":"leetcode-841-钥匙和房间","uri":"/20200831-leetcode-841-%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/"},{"categories":["算法"],"content":"示例 示例 1: 输入: [[1],[2],[3],[]] 输出: true 解释: 我们从 0 号房间开始，拿到钥匙 1。 之后我们去 1 号房间，拿到钥匙 2。 然后我们去 2 号房间，拿到钥匙 3。 最后我们去了 3 号房间。 由于我们能够进入每个房间，我们返回 true。 示例 2: 输入：[[1,3],[3,0,1],[2],[0]] 输出：false 解释：我们不能进入 2 号房间。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/robot-return-to-origin 虽然归类为中等题型，但是意外地简单。类似链式结构，房间代表链表的节点，钥匙代表指向的下一节点。 首先想到的就是递归， 构造递归函数lock, 开锁即进入房间。没去过的房间进行递归操作，否则不重复进入。 最后， 根据房间的数量和已使用钥匙集合的数量判断，若房间数大于钥匙数，则有没去过的房间， 返回False. 题解1: 执行用时：88ms,在所有Python3提交中击败了53.68%的用户 内存消耗：14.5MB,在所有Python3提交中击败了13.44%的用户 class Solution: def canVisitAllRooms(self, rooms) -\u003e bool: used_key = set() used_key.add(0) s_len = len(rooms) def lock(keys): if keys: for key in keys: if key in used_key: continue else: used_key.add(key) lock(rooms[key]) for index, room in enumerate(rooms): if room and index in used_key: lock(room) return True if s_len \u003c= len(used_key) else False ","date":"2020-08-31","objectID":"/20200831-leetcode-841-%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/:2:0","tags":["python","算法","DFS","leetcode","中等"],"title":"leetcode-841-钥匙和房间","uri":"/20200831-leetcode-841-%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/"},{"categories":["算法"],"content":"题目描述 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 ","date":"2020-08-30","objectID":"/20200830-leetcode-557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-iii/:1:0","tags":["python","算法","字符串","leetcode","简单"],"title":"leetcode-557-反转字符串中的单词 III","uri":"/20200830-leetcode-557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-iii/"},{"categories":["算法"],"content":"示例 示例 : 输入：\"Let's take LeetCode contest\" 输出：\"s'teL ekat edoCteeL tsetnoc\" 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/robot-return-to-origin 打卡水题, 很简单的字符串操作题. 题解: 执行用时：60 ms, 在所有 Python3 提交中击败了27.70%的用户 内存消耗：14.1 MB, 在所有 Python3 提交中击败了64.75%的用户 class Solution: def reverseWords(self, s: str) -\u003e str: s_list = s.split(' ') result = [] for s_key in s_list: result.append(s_key[::-1]) return \" \".join(result) ","date":"2020-08-30","objectID":"/20200830-leetcode-557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-iii/:2:0","tags":["python","算法","字符串","leetcode","简单"],"title":"leetcode-557-反转字符串中的单词 III","uri":"/20200830-leetcode-557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-iii/"},{"categories":["算法"],"content":"题目描述 小栖最近很喜欢回文串，由于小栖的幸运数字是5，他想知道形似“abcba\"的回文串在他给定的字符串中的数量 s.length \u003c= 10^6 字符串s只包含小写字母 ","date":"2020-08-30","objectID":"/20200830-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC2%E5%9C%BA-%E4%BA%94%E5%AD%97%E5%9B%9E%E6%96%87/:1:0","tags":["python","算法","字符串","简单"],"title":"超级码力初赛第二场 五字回文","uri":"/20200830-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC2%E5%9C%BA-%E4%BA%94%E5%AD%97%E5%9B%9E%E6%96%87/"},{"categories":["算法"],"content":"示例 示例1 : 输入：s = \"abcba\" 输出：1 示例2: 输入：s = \"abcbabcccb\" 输出：2 解释：形似”abcba“的字符串有”abcba“和”cbabc“ 来源：九章算法 打卡水题, 很简单的字符串操作题. 根据题意可知5位数的字符串，以中间位分割，两侧对称位置相同，且单侧与中间位置的值均不同。从第二个位置（即第一个可能为回文字符串）开始遍历即可，秒过。 题解: class Solution: \"\"\" @param s: The given string @return: return the number of Five-character palindrome \"\"\" def Fivecharacterpalindrome(self, s): # write your code here result = 0 s_len = len(s) for x in range(2, s_len-2): if s[x+1] == s[x-1] and s[x+2] == s[x-2] and s[x] != s[x+1] and s[x] != s[x+2] and s[x+1] != s[x+2]: result = result+1 return result ","date":"2020-08-30","objectID":"/20200830-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC2%E5%9C%BA-%E4%BA%94%E5%AD%97%E5%9B%9E%E6%96%87/:2:0","tags":["python","算法","字符串","简单"],"title":"超级码力初赛第二场 五字回文","uri":"/20200830-%E8%B6%85%E7%BA%A7%E7%A0%81%E5%8A%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B%E7%AC%AC2%E5%9C%BA-%E4%BA%94%E5%AD%97%E5%9B%9E%E6%96%87/"},{"categories":["算法"],"content":"题目描述 在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。 移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。 注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。 ","date":"2020-08-28","objectID":"/20200828-leetcode-657-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/:1:0","tags":["python","算法","leetcode"],"title":"leetcode-657-机器人能否返回原点","uri":"/20200828-leetcode-657-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/"},{"categories":["算法"],"content":"示例 示例 1: 输入: \"UD\" 输出: true 解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。 示例 2: 输入: \"LL\" 输出: false 解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/robot-return-to-origin 打卡水题, 很简单的模拟题. 题解1: 执行用时：96 ms, 在所有 Python3 提交中击败了13.82%的用户 内存消耗：13.8 MB, 在所有 Python3 提交中击败了49.28%的用户 class Solution: def judgeCircle(self, moves: str) -\u003e bool: action = { 'R': (1, 0), 'L': (-1, 0), 'U': (0, 1), 'D': (0, -1)} result = (0, 0) for move in moves: result = (result[0] + action[move][0], result[1] + action[move][1]) return True if result == (0, 0) else False ","date":"2020-08-28","objectID":"/20200828-leetcode-657-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/:2:0","tags":["python","算法","leetcode"],"title":"leetcode-657-机器人能否返回原点","uri":"/20200828-leetcode-657-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/"},{"categories":["算法"],"content":"题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 ","date":"2020-08-27","objectID":"/20200827-leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","tags":["python","算法","leetcode"],"title":"leetcode-1-两数之和","uri":"/20200827-leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"示例 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/robot-return-to-origin 看着题目看似还是很简单， 暴力模拟用二次循环就能做出来。 时间复杂度：O(n^2), 空间复杂度：O(1) 唯一要注意下标边界越界问题，还有考虑清楚变量什么时候要加一，啥时候要减一。 但还是小看了这题。当nums很长时就会超时。一个长度为12599的测试用例耗时8秒多，这是不能忍受的。 题解1： class Solution: def twoSum(self, nums, target: int): nums_len = len(nums) # 第一次循环 for index, item in enumerate(nums): i = 0 # 第二次循环 for _ in range(nums_len-1): subscript = index + i + 1 # 下标越界检查 if subscript \u003c nums_len: if (item+nums[subscript]) == target: return [ index, subscript] else: i = i + 1 忍不住偷瞄了下官方的题解，立即领悟了其中的奥妙： 在一次遍历的时候， target 作为被减数， 减去遍历的每一项。当判断两者的差flag存在列表nums时， 就是解出答案的时刻。 题解2-0： class Solution: def twoSum(self, nums, target: int): for index, item in enumerate(nums): flag = target - item if flag in nums: return [index, nums.index(flag)] 但是没考虑到减数和差为相同值的情况。在这个 nums = [3,2,4] target = 6 用例上栽倒了。即：要注意目标元素target - item 的值不能是nums[index]本身。在检测时打个屏蔽补丁就好了，见题解2-1。 题解2-1: 执行用时：1140 ms, 在所有 Python3 提交中击败了31.23%的用户 内存消耗：14.6 MB, 在所有 Python3 提交中击败了86.51%的用户 全程都在一个列表中完成，节省内存， 但是 python 的 in list操作时间复杂度是O（n）,有什么更快的方法呢？ class Solution: def twoSum(self, nums, target: int): for index, item in enumerate(nums): flag = target - item nums[index] = '_' # 屏蔽当前值 if flag in nums: return [index, nums.index(flag)] else: nums[index] = item 题解3: 再偷瞄一眼官方题解,遍历一遍哈希表求的题解.一边检查目标元素一边将元素插入字典真秒不可言,效率刚刚地~仅用时56ms! python 的 in dict操作时间复杂度是O（1） 执行用时：56 ms, 在所有 Python3 提交中击败了97.24%的用户 内存消耗：15 MB, 在所有 Python3 提交中击败了46.71%的用户 class Solution: def twoSum(self, nums, target: int): target_dic = {} for index, item in enumerate(nums): flag = target - item if flag in target_dic : return [target_dic[flag], index] target_dic[item] = index # 写在后面可以避免 题解2-0 发生的问题 ","date":"2020-08-27","objectID":"/20200827-leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:2:0","tags":["python","算法","leetcode"],"title":"leetcode-1-两数之和","uri":"/20200827-leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["golang"],"content":"学习资源 ","date":"2020-08-20","objectID":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["golang"],"title":"Go 学习笔记","uri":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"代理加速 Goproxy 中国 中国最可靠的 Go 模块代理。 可完美解决由于连接超时无法安装依赖库，工具库的问题。 $ go env -w GO111MODULE=on $ go env -w GOPROXY=https://goproxy.cn,direct 国外代理 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.io,direct ","date":"2020-08-20","objectID":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["golang"],"title":"Go 学习笔记","uri":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"环境变量 export GOPATH=/Users/spaceack/Documents/go ","date":"2020-08-20","objectID":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","tags":["golang"],"title":"Go 学习笔记","uri":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"1.1 Hello World gopl_hello.go package main import ( \"fmt\" ) func main() { fmt.Println(\"Hello world!\") } 运行： go run gopl_hello.go 编译：go build gopl_hello.go 代码格式化工具: gofmt 自动添加或删除import 声明：goimports Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成, 目录定义包的作用。每个源文件都以一条是package 声明语句开始，这个例子里就是package main , 表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。 main函数也很特殊，它是整个程序执行时的入口。不包含参数，不返回任何内容，在执行程序时调用。 必须告诉编译器源文件需要哪些包，这就是跟随在package声明后面的import声明扮演的角色。必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。 import声明必须跟在文件的package声明之后。 func 创建函数 Println()：此方法存在于 fmt 包中, 打印行。 查看golang版本 go version 注释 /* 块 注释 */ // 行注释 每个 Go 程序都是由包(package)组成的。 程序入口是 package main 惯例: 包名与导入路径的最后一个目录一致 打包导入: import（ \"fmt\" \"math\" ) 包被导入后，可用导出的名称调用它 首字母大写的名称是被导出的 ","date":"2020-08-20","objectID":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","tags":["golang"],"title":"Go 学习笔记","uri":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"函数 类型在变量名之后 多个参数类型一致时，可省略前面的 func add(x int, y, int) int { x + y } func add(x, y int) int { x + y } 返回值可以被命名 func bmi(weight, height float64) (bmi float64, is_normal bool) { bmi = weight / (math.Pow(height, 2)) if (18.5 \u003c bmi) \u0026\u0026 (bmi \u003c 23.9) { is_normal = true } return } var语句可以定一个变量列表 函数内可以使用简洁赋值语句声明变量:=，替代var ","date":"2020-08-20","objectID":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:4","tags":["golang"],"title":"Go 学习笔记","uri":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"基本类型 bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // uint8 的别名 rune // int32 的别名 // 代表一个Unicode码 float32 float64 complex64 complex128 package main import ( \"fmt\" \"math/cmplx\" ) var ( ToBe bool = false MaxInt uint64 = 1\u003c\u003c64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) func main() { const f = \"%T(%v)\\n\" fmt.Printf(f, ToBe, ToBe) fmt.Printf(f, MaxInt, MaxInt) fmt.Printf(f, z, z) } 使用go build test.go 编译 类型转换，需要显式转换 常量 ```const``关键字定义 ","date":"2020-08-20","objectID":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:5","tags":["golang"],"title":"Go 学习笔记","uri":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"使用iris web框架 run go mod init test main.go package main import \"github.com/kataras/iris/v12\" func main(){ app ：= iris.New() app.Get(\"/\", func(ctx iris.Context){}) app.Run(iris.Addr(:\"8080\")) } run go run main.go ","date":"2020-08-20","objectID":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["golang"],"title":"Go 学习笔记","uri":"/2020-08-20-golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Python","算法"],"content":"线性表 python的list是可变线性表。 len()是 O（1）操作 元素访问和赋值，尾端加入和尾端删除（包括尾端切片删除）都是O（1）操作。 一般位置的元素加入，切片替换，切片删除，表拼接（extend）都是O（n）操作。 pop操作默认为删除表尾元素并将其返回O（1），指定非尾端位置为O（n）时间复杂度。 lst.clear()清除表lst所有元素O（1）操作。两种实现方式： a. 元素记数值（表长度）设置为0。实现简单，操作效率高，但不能真正释放占用的存储。若表很长，执行操作后表内没有元素，但仍会占用原有大块内存。 b. 另分配一个空表用的存储区，原存储区直接丢弃。若表又一次增大，会频繁更换存储区。 lst.reverse()修改表lst自身，元素顺序倒置O（n） def reverse(self): elems = self.elements i, j = 0, len(elems) - 1 while i \u003c j： elems[i], elems[j] = elems[j], elems[i] i, j = i+1, j-1 sort排序， 最好的排序算法的平均和最坏情况时间复杂度都是O（nlogn） 最重要特点（优势）是O（1）时间定位元素访问，许多简单操作效率较高。 缺陷是加入/删除操作的效率问题，插入删除可能要移动很多元素，操作代价高。 只有特殊的尾端插入/删除操作具有O(1)时间复杂度。但插入操作受元素存储区固定大小限制。通过加倍存储区扩充策略（初始分配为空，第一次增长到4个单元，增长率为1.125倍。1.保证O（1）的append,2.防止过多的空闲单元。），尾端插入可达到O（1）。 ## 链接表 ### 条件 1. 能够找到表中的首元素。 2. 从任一元素出发，可以找到下一个元素。 ### 单链表 - 定义 ```python class LNode: def __init__(self, elem, next_= None): self.elem = elem self.next = next_ ","date":"2020-08-10","objectID":"/20200810-python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:0","tags":["线性表","栈"],"title":"Python数据结构与算法","uri":"/20200810-python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["Python","算法"],"content":"栈 栈（stack）又名堆栈，是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。 允许进行插入和删除操作的一段称为栈顶（top）,另一端称为栈底（bottom） 栈底固定，栈顶浮动。 栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH）， 删除则称为退栈（POP）。 后进先出（LIFO，Last In First Out）, 后进先出表。 进栈和退栈时间复杂度都为O（1） class Stack(Object): def __init__(self, limit=10): \"\"\" 创建空栈 \"\"\" self.stack = [] # 存放元素 self.limit = limit # 栈容量限制 def push(self, data): \"\"\" 将元素data加入栈，也常称为压入或推入 \"\"\" # 判断栈是否溢出 if len(self.stack) \u003e= self.limit: raise IndexError('超出栈的最大容量！') self.stack.append(data) def pop(self): \"\"\" 删除栈里最后压入的元素并将其返回，常称为弹出。 \"\"\" if self.stack: return self.stack.pop() else: rasie IndexError('pop from an empty stack') def top(self): \"\"\" 取得栈里最后压入的（最上面的）元素，不删除。 \"\"\" if self.stack: return self.stack[-1] def is_empty(self): \"\"\" 判断栈是否为空， 空时返回True, 否则返回 False \"\"\" return not bool(self.stack) def size(self): \"\"\" 取得栈中的元素个数 \"\"\" return len(self.stack) ","date":"2020-08-10","objectID":"/20200810-python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:0","tags":["线性表","栈"],"title":"Python数据结构与算法","uri":"/20200810-python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["Python","算法"],"content":"应用：括号匹配 \"\"\" 使用一个堆栈检查括号字符串是否平衡 有效括号字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 举例： ((())): True ((()): False (())): False \"\"\" import stack st = stack.Stack() input_str = \"(()\" for s in input_str: if st.top() == s: st.pop() else: st.push(s) result = True if st.is_empty() else False print(result) ","date":"2020-08-10","objectID":"/20200810-python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:1","tags":["线性表","栈"],"title":"Python数据结构与算法","uri":"/20200810-python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["数据库"],"content":"安装 # 启动mysql sudo systemctl start mysql # 查看mysql 状态 sudo systemctl status mysql # 查看mysql 配置 vim /etc/mysql/mariadb.conf.d/50-server.cnf # 查看系统中的mysql进程 ps -aux | grep \"mysql\" ps -ef | grep mysql # 杀掉mysql进程 提示 bash: kill: (4385) - Operation not permitted， 因为没有权限，要使用sudo sudo kill -15 问题：访问数据库报错 ERROR 1524 (HY000): Plugin ‘unix_socket’ is not loaded 解决：在配置文件[mysqld] 下增加 plugin-load-add = auth_socket.so， 重启服务。 ","date":"2020-08-01","objectID":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["mysql"],"title":"Mysql 常用命令","uri":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["数据库"],"content":"安全管理 ","date":"2020-08-01","objectID":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["mysql"],"title":"Mysql 常用命令","uri":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["数据库"],"content":"管理用户 查看用户 USE mysql; SELECT user FROM user; 创建用户 spaceack, 密码为 password123 CREATE USER spaceack IDENTIFIED BY 'password123'; 为用户授予数据库权限 grant all privileges on `数据库名`.* to '用户名'@'localhost'; flush privileges; ","date":"2020-08-01","objectID":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:1","tags":["mysql"],"title":"Mysql 常用命令","uri":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["数据库"],"content":"命令 连接数据库管理系统 mysql -u root -p -h localhost -P 3306 查看所有数据库 SHOW DATABASES; 使用数据库 USE mysql; 查看数据库中的所有表列表 SHOW TABLES; 显示表列 SHOW COLUMNS FROM help_keyword; +-----------------+------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-----------------+------------------+------+-----+---------+-------+ | help_keyword_id | int(10) unsigned | NO | PRI | NULL | | | name | char(64) | NO | UNI | NULL | | +-----------------+------------------+------+-----+---------+-------+ DESCRIBE help_keyword; DESC help_keyword; 显示建库语句 SHOW CREATE DATABASE mysql; 显示建表语句 SHOW CREATE TABLE help_keyword; 显示用户安全权限 SHOW GRANTS 显示服务器状态： SHOW STATUS; +--------------------------------------------------------+--------------------------------------------------+ | Variable_name | Value | +--------------------------------------------------------+--------------------------------------------------+ | Aborted_clients | 46 | | Aborted_connects | 1 | | Aborted_connects_preauth | 0 | | Access_denied_errors | 0 | | Acl_column_grants | 0 | | Acl_database_grants | 1 | | Acl_function_grants | 0 | | Acl_procedure_grants | 0 | | Acl_package_spec_grants | 0 | | Acl_package_body_grants | 0 | | Acl_proxy_users | 1 | | Acl_role_grants | 0 | | Acl_roles | 0 | | Acl_table_grants | 2 | | Acl_users | 4 | | Aria_pagecache_blocks_not_flushed | 0 | | Aria_pagecache_blocks_unused | 15634 | | Aria_pagecache_blocks_used | 16 | | Aria_pagecache_read_requests | 8513 | | Aria_pagecache_reads | 671 | | Aria_pagecache_write_requests | 1306 | | Aria_pagecache_writes | 1306 | | Aria_transaction_log_syncs | 1 | | Binlog_commits | 0 | | Binlog_group_commits | 0 | | Binlog_group_commit_trigger_count | 0 | | Binlog_group_commit_trigger_lock_wait | 0 | | Binlog_group_commit_trigger_timeout | 0 | | Binlog_snapshot_file | | | Binlog_snapshot_position | 0 | | Binlog_bytes_written | 0 | | Binlog_cache_disk_use | 0 | | Binlog_cache_use | 0 | | Binlog_stmt_cache_disk_use | 0 | | Binlog_stmt_cache_use | 0 | | Busy_time | 0.000000 | | Bytes_received | 1118 | | Bytes_sent | 28819 | | Column_compressions | 0 | | Column_decompressions | 0 | | Com_admin_commands | 0 | | Com_alter_db | 0 | | Com_alter_db_upgrade | 0 | | Com_alter_event | 0 | | Com_alter_function | 0 | | Com_alter_procedure | 0 | | Com_alter_server | 0 | | Com_alter_sequence | 0 | | Com_alter_table | 0 | | Com_alter_tablespace | 0 | | Com_alter_user | 0 | | Com_analyze | 0 | | Com_assign_to_keycache | 0 | | Com_backup | 0 | | Com_backup_lock | 0 | | Com_begin | 0 | | Com_binlog | 0 | | Com_call_procedure | 0 | | Com_change_db | 1 | | Com_change_master | 0 | | Com_check | 0 | | Com_checksum | 0 | | Com_commit | 0 | | Com_compound_sql | 0 | | Com_create_db | 0 | | Com_create_event | 0 | | Com_create_function | 0 | | Com_create_index | 0 | | Com_create_package | 0 | | Com_create_package_body | 0 | | Com_create_procedure | 0 | | Com_create_role | 0 | | Com_create_sequence | 0 | | Com_create_server | 0 | | Com_create_table | 0 | | Com_create_temporary_table | 0 | | Com_create_trigger | 0 | | Com_create_udf | 0 | | Com_create_user | 0 | | Com_create_view | 0 | | Com_dealloc_sql | 0 | | Com_delete | 0 | | Com_delete_multi | 0 | | Com_do | 0 | | Com_drop_db | 0 | | Com_drop_event | 0 | | Com_drop_function | 0 | | Com_drop_index | 0 | | Com_drop_procedure | 0 | | Com_drop_package | 0 | | Com_drop_package_body | 0 | | Com_drop_role | 0 | | Com_drop_server | 0 | | Com_drop_sequence | 0 | | Com_drop_table | 0 | | Com_drop_temporary_table | 0 | | Com_drop_trigger | 0 | | Com_drop_user | 0 | | Com_drop_view | 0 | | Com_empty_query | 0 | | Com_execute_immediate | 0 | | Com_execute_sql | 0 | | Com_flush | 0 | | Com_get_diagnostics | 0 | | Com_grant | 0 | | Com_grant_role | 0 | | Com_ha_close | 0 | | Com_ha_open | 0 | | Com_ha_read | 0 | | Com_help | 0 | | Com_insert | 0 | | Com_insert_select | 0 | | Com_install_plugin | 0 | | Com_kill | 0 | | Com_load | 0 | | Com_lock_tables | 0 | | Com_multi | 0 | | Com_optimize | 0 | ","date":"2020-08-01","objectID":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["mysql"],"title":"Mysql 常用命令","uri":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["数据库"],"content":"备份 ","date":"2020-08-01","objectID":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":["mysql"],"title":"Mysql 常用命令","uri":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["数据库"],"content":"Mysql备份类型 按照备份时对数据库的影响分为 Hot backup（热备）：也叫在线备份。指在数据库运行中直接备份，对正在运行的数据库没有任何影响。 Cold backup（冷备）：也叫离线备份。指在数据库停止的情况下备份。 Warm backup（温备）：在数据库运行时备份，会加一个全局锁以保证数据的一致性，会对当前数据库的操作有影响。 按照备份后的文件内容分为 逻辑备份：指备份后的文件内容是可读的，通常为文本文件，内容一般是SQL语句或表内的实际数据（mysqldump和select * into outfile），一般适用于数据库的升级和迁移，还原时间较长。适用于中小型数据库，效率相对较低。 裸文件备份：也叫物理备份。拷贝数据库的物理文件，数据库既可以处于运行状态（mysqlhotcopy、ibbackup、xtrabackup一类工具），也可以处于停止状态，还原时间较短。，适用于大型数据库环境，但不能恢复到异构环境中，如windows。 导出表：直接将表导入到文本文件中。 按照备份数据库的内容分为 完全备份：对数据库进行完整的备份。 增量备份：在上一次完整备份的基础上，对更新的数据进行备份（xtrabackup） 日志备份：二进制日志备份，主从同步。 ","date":"2020-08-01","objectID":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:1","tags":["mysql"],"title":"Mysql 常用命令","uri":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["数据库"],"content":"工具： mysqldump, 是逻辑备份工具，支持MyISAM和InnoDB引擎。数据库运行时，MyISAM，Aria引擎只支持温备，InnoDB支持热备和温备。单线程备份恢复较慢。 Xtrabackup(innobackupex工具)， 备份mysql大数据； InnoDB支持，增量备份；MyISAM温备，不支持增量。属于物理备份，速度快； lvm-snapshot, 先请求全局锁，再创建快照，后释放全局锁;备份和恢复速度快。 可以使用MySQL的 BACKUP TABLE 或 SELECT INTO OUTFILE 转储所 有数据到某个外部文件。这两条语句都接受将要创建的系统文件 名,此系统文件必须不存在,否则会出错。数据可以用 RESTORE TABLE 来复原。 ","date":"2020-08-01","objectID":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:2","tags":["mysql"],"title":"Mysql 常用命令","uri":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["数据库"],"content":"示例 备份数据库 /usr/bin/mysqldump --routines -h127.0.0.1 -uroot -ppassword --add-drop-table --disable-keys --extended-insert --single-transaction database_name \u003e database_name_date.sql 恢复备份 mysql -uroot -ppassword -Ddatabase_name \u003c database_name_date.sql 备份包含 blob 类型字段的表 需要添加 –hex-blob 参数 mysqldump --no-defaults --hex-blob -h127.0.0.1 -R -uroot -p --databases test_db --table test_table \u003e test_table_backup.sql 备份恢复 sudo mysql -u root -p --database=test_db \u003c test_table_backup.sql ","date":"2020-08-01","objectID":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:3","tags":["mysql"],"title":"Mysql 常用命令","uri":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["数据库"],"content":"概念术语表 SQL (Structured Query Language) 结构化查询语言: database 数据库 DBMS 数据库管理系统 table 表： 某种特定类型数据的结构化清单。 schema 模式： 关于数据库和表的布局及特性信息。 column 列： datatype 数据类型： row 行/record 记录： primary key 主键：一列(或一组列),其值能够唯一区分表中每个行。 应该总是定义主键 主键的最好习惯： 不更新主键列中的值; 不重用主键列的值; 不在主键列中使用可能会更改的值。 ","date":"2020-08-01","objectID":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:5:0","tags":["mysql"],"title":"Mysql 常用命令","uri":"/20200803-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["数据库"],"content":"配置开机启动 转载： redis设置开机自启 sudo vim /etc/systemd/system/redis.service sudo chmod 777 redis.service [Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/opt/redis-6.0.5/src/redis-server /opt/redis-6.0.5/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target 1. 先关闭redis-server systemctl stop redis.service 2. 开启redis-server systemctl start redis.service 3. 开启成功，将服务加入开机自启 systemctl enable redis.service 4. 重启 shutdown -r now 5. 查看服务运行状态 systemctl status redis.service 4、配置描述： Description:描述服务 After:描述服务类别 [Service]服务运行参数的设置 Type=forking是后台运行的形式 ExecStart为服务的具体运行命令 ExecReload为重启命令 ExecStop为停止命令 PrivateTmp=True表示给服务分配独立的临时空间 注意：[Service]的启动、重启、停止命令全部要求使用绝对路径 [Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3 # 查看redis 是否启动成功 netstat -lntp | grep 6379 ","date":"2020-08-01","objectID":"/20200801-redis/:0:1","tags":["redis"],"title":"Redis实战读书笔记","uri":"/20200801-redis/"},{"categories":["数据库"],"content":"命令速查 查看数据库数量 CONFIG GET databases 选择数据库 SELECT 1 ","date":"2020-08-01","objectID":"/20200801-redis/:1:0","tags":["redis"],"title":"Redis实战读书笔记","uri":"/20200801-redis/"},{"categories":["数据库"],"content":"数据结构 value 的五种结构 字符串 STRING 列表 LIST 集合 SET 散列 HASH 有序集合 ZSET ","date":"2020-08-01","objectID":"/20200801-redis/:2:0","tags":["redis"],"title":"Redis实战读书笔记","uri":"/20200801-redis/"},{"categories":["数据库"],"content":"概念术语表 tracker 追踪器 schema 模式 schema-less 无模式 prototype 原型 persistence 持久化 client-side sharding 客户端分片 non-relational database 非关系数据库 key 键 value 值 mapping 映射 primary database 主数据库 auxiliary database 辅助数据库 primary storage 主存储 secondary storage 二级存储 bulk operation 批量操作 master/slave replication stored procedure 存储过程 spatial index 空间索引 point-in-time dump 按时间点转储 failover 故障转移 aggregates 聚合 atomic 原子的 parser 分析器 optimizer 优化器 task queue 任务队列 distribute 分发 ","date":"2020-08-01","objectID":"/20200801-redis/:3:0","tags":["redis"],"title":"Redis实战读书笔记","uri":"/20200801-redis/"},{"categories":["算法"],"content":"题目描述 输入两个整数 a,b输出它们的和。 ","date":"2020-07-28","objectID":"/20200728-p1001-a-b-problem/:0:1","tags":["easy","python","Golang","Java"],"title":"P1001 A+B Problem","uri":"/20200728-p1001-a-b-problem/"},{"categories":["算法"],"content":"输入格式 两个整数以空格分开。 ","date":"2020-07-28","objectID":"/20200728-p1001-a-b-problem/:0:2","tags":["easy","python","Golang","Java"],"title":"P1001 A+B Problem","uri":"/20200728-p1001-a-b-problem/"},{"categories":["算法"],"content":"输出格式 一个整数。 ","date":"2020-07-28","objectID":"/20200728-p1001-a-b-problem/:0:3","tags":["easy","python","Golang","Java"],"title":"P1001 A+B Problem","uri":"/20200728-p1001-a-b-problem/"},{"categories":["算法"],"content":"输入输出样例 输入 #1 20 30 输出 #1 50 # 80ms / 3.16MB / 45B Python 3 print(sum([int(x) for x in input().split()])) /* 22ms / 6.92MB / 128B Go */ package main import ( \"fmt\" ) var ( a int64 b int64 ) func main() { fmt.Scanf(\"%d%d\", \u0026a, \u0026b) fmt.Printf(\"%d\", a+b) } /* 514ms / 11.43MB / 232B Java 8 */ import java.util.*; public class Main { public static void main(String[] args) { Scanner cin=new Scanner(System.in); int a = cin.nextInt(); int b = cin.nextInt(); System.out.println(a+b); } } ","date":"2020-07-28","objectID":"/20200728-p1001-a-b-problem/:0:4","tags":["easy","python","Golang","Java"],"title":"P1001 A+B Problem","uri":"/20200728-p1001-a-b-problem/"},{"categories":["Vim"],"content":"介绍 ","date":"2020-07-21","objectID":"/20200721-vim%E9%85%8D%E7%BD%AE/:1:0","tags":["Vim"],"title":"Vim配置","uri":"/20200721-vim%E9%85%8D%E7%BD%AE/"},{"categories":["Vim"],"content":"安装Vundle插件管理器 git clone --depth=1 https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim git clone --depth=1 https://github.com/preservim/nerdtree.git ~/.vim/bundle/nerdtree git clone --depth=1 https://github.com/Xuyuanp/nerdtree-git-plugin.git ~/.vim/bundle/nerdtree-git-plugin 更新配置文件 vim ~/.vimrc set nocompatible \" be iMproved, required filetype off \" required \" set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() Plugin 'scrooloose/nerdtree' Plugin 'Xuyuanp/nerdtree-git-plugin' call vundle#end() \" 显示行号 set nu \" tabs键四空格 set ts=4 \" 代码高亮 syntax enable \" 启用鼠标 \" set mouse=a \" set selection=exclusive \" set selectmode=mouse,key \"显示状态栏 set laststatus=2 \" 代码换行自动缩进 set autoindent filetype plugin on \" 按 F5 执行当前 Python 代码\" map \u003cF5\u003e :call PRUN()\u003cCR\u003e func! PRUN() exec \"w\" if \u0026filetype == 'python' exec \"!python %\" endif endfunc \" NerdTree才插件的配置信息 \"\"将F2设置为开关NERDTree的快捷键 map \u003cf3\u003e :NERDTreeToggle\u003ccr\u003e \"\"修改树的显示图标 let g:NERDTreeDirArrowExpandable = '+' let g:NERDTreeDirArrowCollapsible = '-' \"\"窗口位置 let g:NERDTreeWinPos='left' \"\"窗口尺寸 let g:NERDTreeSize=30 \"\"窗口是否显示行号 let g:NERDTreeShowLineNumbers=1 \"\"不显示隐藏文件 let g:NERDTreeHidden=0 安装插件 :PluginInstall ","date":"2020-07-21","objectID":"/20200721-vim%E9%85%8D%E7%BD%AE/:1:1","tags":["Vim"],"title":"Vim配置","uri":"/20200721-vim%E9%85%8D%E7%BD%AE/"},{"categories":["Linux"],"content":"Debian 10添加163软件源： vi /etc/apt/source.list deb http://mirrors.163.com/debian/ buster main contrib non-free deb http://mirrors.163.com/debian/ buster-updates main contrib non-free deb http://mirrors.163.com/debian-security/ buster/updates main contrib non-free :wq 其它debian发行版本同理，更改代号即可，历史代号可到官网查看 debian.org 下一代 Debian 正式发行版的代号为 \"bullseye\" — 发布时间尚未确定 Debian 10（\"buster\"） — 当前的稳定版（stable） Debian 9（\"stretch\"） — 旧的稳定版（oldstable） Debian 8（\"jessie\"） — 更旧的稳定版（oldoldstable） Debian 7（\"wheezy\"） — 被淘汰的稳定版 Debian 6.0（\"squeeze\"） — 被淘汰的稳定版 Debian GNU/Linux 5.0（\"lenny\"） — 被淘汰的稳定版 Debian GNU/Linux 4.0（\"etch\"） — 被淘汰的稳定版 Debian GNU/Linux 3.1（\"sarge\"） — 被淘汰的稳定版 Debian GNU/Linux 3.0（\"woody\"） — 被淘汰的稳定版 Debian GNU/Linux 2.2（\"potato\"） — 被淘汰的稳定版 Debian GNU/Linux 2.1（\"slink\"） — 被淘汰的稳定版 Debian GNU/Linux 2.0（\"hamm\"） — 被淘汰的稳定版 ","date":"2020-07-20","objectID":"/20200720-%E4%B8%BAdebian10%E6%B7%BB%E5%8A%A0%E8%BD%AF%E4%BB%B6%E6%BA%90/:0:0","tags":["debian"],"title":"为debian10添加软件源","uri":"/20200720-%E4%B8%BAdebian10%E6%B7%BB%E5%8A%A0%E8%BD%AF%E4%BB%B6%E6%BA%90/"},{"categories":["Python"],"content":"datetime 库 from datetime import datetime, timedelta # 字符串 转 datetime类型 another_day_str = '2020-07-18 21:00:00' another_day_datetime = datetime.strptime(another_day_str, '%Y-%m-%d%H:%M:%S') # 时间加减运算， 增加1小时30分30秒 after_datetime = another_day_datetime + timedelta(hours=1, minutes=30, seconds=30) # datetime类型 转 字符串 2020-07-18 22:30:30 after_str = after_datetime.strftime('%Y-%m-%d%H:%M:%S') # 获取当前时间的字符串 格式化输出 20200719223030 now_datetime = datetime.now() now_str = now_datetime.strftime('%Y%m%d%H%M%S') # 转换为时间戳 timestamp = time.mktime(now_datetime.timetuple()) # 时间戳转换为datetime datetime.datetime.fromtimestamp(timestamp) # 获取间隔天数 day = (now_datetime - another_day_datetime).days # 获取间隔秒数（不包含天数差） second = (now_datetime - another_day_datetime).seconds time库 import time # 返回当前时间的时间戳（1970纪元后经过的浮点秒数） timestamp = time.time() # 时间戳转换为 struct_time类型(结构体时间) struct_time = time.localtime(timestamp) # 字符串转结构体时间 struct_time now_str = '2020-07-19 21:00:00' struct_time = time.strptime(now_str, \"%Y-%m-%d%H:%M:%S\") # time.struct_time(tm_year=2020, tm_mon=7, tm_mday=19, tm_hour=21, tm_min=0, tm_sec=0, tm_wday=6, tm_yday=201, tm_isdst=-1) \u003cclass 'time.struct_time'\u003e # struct_time 转 格式化字符串 20200719210000 str_time = time.strftime('%Y%m%d%H%M%S', struct_time) Commonly used format codes: %Y Year with century as a decimal number. %m Month as a decimal number [01,12]. %d Day of the month as a decimal number [01,31]. %H Hour (24-hour clock) as a decimal number [00,23]. %M Minute as a decimal number [00,59]. %S Second as a decimal number [00,61]. %z Time zone offset from UTC. %a Locale's abbreviated weekday name. %A Locale's full weekday name. %b Locale's abbreviated month name. %B Locale's full month name. %c Locale's appropriate date and time representation. %I Hour (12-hour clock) as a decimal number [01,12]. %p Locale's equivalent of either AM or PM. struct_time parameter tm_gmtoff \"\"\"offset from UTC in seconds\"\"\" tm_hour \"\"\"hours, range [0, 23]\"\"\" tm_isdst \"\"\"1 if summer time is in effect, 0 if not, and -1 if unknown\"\"\" tm_mday \"\"\"day of month, range [1, 31]\"\"\" tm_min \"\"\"minutes, range [0, 59]\"\"\" tm_mon \"\"\"month of year, range [1, 12]\"\"\" tm_sec \"\"\"seconds, range [0, 61])\"\"\" tm_wday \"\"\"day of week, range [0, 6], Monday is 0\"\"\" tm_yday \"\"\"day of year, range [1, 366]\"\"\" tm_year \"\"\"year, for example, 1993\"\"\" tm_zone \"\"\"abbreviation of timezone name\"\"\" ","date":"2020-07-19","objectID":"/20200719-python%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/:1:0","tags":["python","datetime","time"],"title":"Python时间处理","uri":"/20200719-python%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/"},{"categories":["算法"],"content":" import os old_path = 'data/20200222' new_path = 'new_path' old_file = 'oldfile' new_file = 'newfile' # 判断使用的系统平台windows 返回 nt, Linux 返回posix os_name = os.name print(os_name) if os_name == 'nt': print('Windows操作系统！') if os_name == 'posix': print('Linux操作系统！') # 获取当前用户主目录路径 print(os.environ['HOME']) print(os.path.expandvars('$HOME')) print(os.path.expanduser('~')) # 获取当前工作目录 print(os.getcwd()) # 创建目录 os.mkdir(new_path) # 递归创建目录 os.makedirs(old_path) # 获得文件的大小，如果为目录，返回0 os.path.getsize(new_path) print(os.listdir(new_path)) # 删除文件 if os.path.exists(new_file): os.remove(new_file) else: print(\"文件不存在， 删除失败\") # 改文件名 if os.path.exists(old_file): # 查看文件/目录是否存在 if os.path.exists(new_file): print(\"新文件（名）已存在\") else: os.rename(old_file, new_file) else: print(\"旧文件（名）不存在\") # 文件目录遍历 for dirpath, dirnames, filenames in os.walk(new_path): print(dirpath) # 当其目录绝对路径, 类似linux命令pwd的输出，str类型 print(dirnames) # 当前目录下的子目录，list类型 print(filenames) # 当前目录下的所有文件，list类型 # 删除目录 os.rmdir(new_path) os.rmdir(old_path) ","date":"2020-07-17","objectID":"/20200717-python%E4%BD%BF%E7%94%A8os%E6%A8%A1%E5%9D%97/:0:0","tags":["os"],"title":"Python使用os模块","uri":"/20200717-python%E4%BD%BF%E7%94%A8os%E6%A8%A1%E5%9D%97/"},{"categories":["软件工程"],"content":"git status 中文显示异常 中文名等特殊符号被转义，不易读。 使用下面命令可正常显示中文。 git config --global core.quotepath false ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:0:1","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"查看项目中某个人的代码数 git log --author=\"Spaceack\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' added lines: 1280, removed lines: 198, total lines: 1082 ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:0:2","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"合并多次commit 例如要合并 最新的三次提交,将后两个提交合并到第一个： git rebase -i HEAD~3 选择pick操作，git会应用这个补丁，以同样的提交信息（commit message）保存提交 选择reword操作，git会应用这个补丁，但需要重新编辑提交信息 选择edit操作，git会应用这个补丁，但会因为amending而终止 选择squash操作，git会应用这个补丁，但会与之前的提交合并 选择fixup操作，git会应用这个补丁，但会丢掉提交日志 选择exec操作，git会在shell中运行这个命令 然后将后两个提交的pick 改为 squash ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:0:3","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"解决Git冲突 Please move or remove them before you can merge. Aborting x -----删除忽略文件已经对git来说不识别的文件 d -----删除未被添加到git的路径中的文件 f -----强制运行 git clean -d -fx \"\" ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:0:4","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"您的分支和 ‘origin/master’ 出现了偏离 git status 位于分支 master 您的分支和 'origin/master' 出现了偏离， 并且分别有 1 和 1 处不同的提交。 （使用 \"git pull\" 来合并远程分支） 想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它： git fetch origin git reset --hard origin/master ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:0:5","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"拒绝合并无关历史 fatal: refusing to merge unrelated histories git pull origin hexo --allow-unrelated-histories ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:0:6","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"git pull 强制覆盖本地文件 git fetch --all git reset --hard origin/master ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:0:7","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"pull时，忽略变更的文件 git stash git pull git stash pop ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:0:8","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"GitHub ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:1:0","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"更新 fork 分支 - RP: spaceack/awesomeproject - Fork: xxxx/awesomeproject git clone https://github.com/spaceack/awesomeproject.git cd awesomeproject git remote add upstream https://github.com/spaceack/myframework.git - Update: git fetch upstream git rebase upstream/master git push git push --tags ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:1:1","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"更改某次提交记录 ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:2:0","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"Gerrit ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:3:0","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["软件工程"],"content":"git push 报错 remote rejected' vim .git/config 对应的分支develop refs/heads/develop 改为 merge = refs/for/develop 或 在 [remote \"origin\"] 下 添加 push = refs/heads/*:refs/for/* ","date":"2020-07-02","objectID":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/:3:1","tags":["git","gerrit"],"title":"git常见问题处理","uri":"/2020-07-02-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"categories":["Python","网络"],"content":"介绍 服务器推送事件： Server-Sent Events, SSE ","date":"2020-07-01","objectID":"/2020-07-01-sse%E5%8D%8F%E8%AE%AE/:1:0","tags":["sse","flask","网络协议"],"title":"SSE协议","uri":"/2020-07-01-sse%E5%8D%8F%E8%AE%AE/"},{"categories":["Python","网络"],"content":"特点 仅从服务器向客户端实现单向实时通信。 实现简单，基于HTTP协议。 浏览器端有断线重连功能。 支持用户自定义消息类型。 用来传送文本， 二进制需要编码。 ","date":"2020-07-01","objectID":"/2020-07-01-sse%E5%8D%8F%E8%AE%AE/:1:1","tags":["sse","flask","网络协议"],"title":"SSE协议","uri":"/2020-07-01-sse%E5%8D%8F%E8%AE%AE/"},{"categories":["Python","网络"],"content":"flask-sse 实现 flask-sse文档 ","date":"2020-07-01","objectID":"/2020-07-01-sse%E5%8D%8F%E8%AE%AE/:2:0","tags":["sse","flask","网络协议"],"title":"SSE协议","uri":"/2020-07-01-sse%E5%8D%8F%E8%AE%AE/"},{"categories":["Python","网络"],"content":"前置条件 本地Redis服务器 gunicorn gevent, sse是无限事件流，flask处理HTTP请求一次只能响应一个，要需要配合异步服务器使用。 ","date":"2020-07-01","objectID":"/2020-07-01-sse%E5%8D%8F%E8%AE%AE/:2:1","tags":["sse","flask","网络协议"],"title":"SSE协议","uri":"/2020-07-01-sse%E5%8D%8F%E8%AE%AE/"},{"categories":["Python","网络"],"content":"实现 服务端 sse.py from flask import Flask, render_template from flask_sse import sse app = Flask(__name__) app.config[\"REDIS_URL\"] = \"redis://localhost\" app.register_blueprint(sse, url_prefix='/stream') @app.route('/') def index(): return render_template(\"index.html\") @app.route('/hello') def publish_hello(): sse.publish({\"message\": \"Hello!\"}, type='greeting') return \"Message sent!\" 客户端 templates/index.html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eFlask-SSE Quickstart\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eFlask-SSE Quickstart\u003c/h1\u003e \u003cscript\u003e var source = new EventSource(\"{{ url_for('sse.stream') }}\"); source.addEventListener('greeting', function(event) { var data = JSON.parse(event.data); console.log(\"The server says \" + data.message); }, false); source.addEventListener('error', function(event) { console.log(\"Failed to connect to event stream. Is Redis running?\"); }, false); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e gunicorn sse:app --worker-class gevent --bind 127.0.0.1:8000 ","date":"2020-07-01","objectID":"/2020-07-01-sse%E5%8D%8F%E8%AE%AE/:2:2","tags":["sse","flask","网络协议"],"title":"SSE协议","uri":"/2020-07-01-sse%E5%8D%8F%E8%AE%AE/"},{"categories":["Linux"],"content":"问题现象 今天遇到一个奇怪的问题： 非正常重启后，或热插拔主板接口设备？。导致鼠标，键盘失去响应，重新插拔USB接口后，鼠标键盘电源灯无法点亮，屏幕无响应。再次重启后出现黑屏，提示错误如下： initramfs unpacking failed decoding failed radeon 0000:01:00.0: failed VCE resume (-110). 大意就是 /dev/sda2分区包含一个文件系统错误，（inodes）在被损坏的孤立的节点表中。 要用fsck这个命令修复。 按照提示，使用命令修复即可: fsck -y /dev/sda2 ","date":"2020-06-05","objectID":"/20200605-%E4%BD%BF%E7%94%A8fsck%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8Dlinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:0","tags":["busybox","fsck"],"title":"使用fsck命令检查并修复linux文件系统","uri":"/20200605-%E4%BD%BF%E7%94%A8fsck%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8Dlinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Linux"],"content":"BusyBox 幸运的是，出错后自动进入到BusyBox环境。BusyBox是什么呢？ 经过一通man busybox猛如虎的操作后，发现BusyBox是一个集合多种工具命令的工具箱，又或称嵌入式Linux系统的瑞士军刀。可用作急救盘。 ","date":"2020-06-05","objectID":"/20200605-%E4%BD%BF%E7%94%A8fsck%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8Dlinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:1","tags":["busybox","fsck"],"title":"使用fsck命令检查并修复linux文件系统","uri":"/20200605-%E4%BD%BF%E7%94%A8fsck%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8Dlinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Linux"],"content":"initramfs initramfs (initram file system) 用于挂载根文件系统。initramfs是在普通根文件系统上可以找到的完整目录集, 在启动时，引导加载程序会把内核和initramfs镜像加载到内存并启动内核。 initramfs可以在启动早期提供一个用户态环境。 ","date":"2020-06-05","objectID":"/20200605-%E4%BD%BF%E7%94%A8fsck%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8Dlinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:2","tags":["busybox","fsck"],"title":"使用fsck命令检查并修复linux文件系统","uri":"/20200605-%E4%BD%BF%E7%94%A8fsck%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8Dlinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Linux"],"content":"initramfs 与 BusyBox 是什么关系？ 我理解initramfs就是一种文件系统。BusyBox是命令工具集，其中还有一个switch_root命令,可以切换root文件系统。 ","date":"2020-06-05","objectID":"/20200605-%E4%BD%BF%E7%94%A8fsck%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8Dlinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:3","tags":["busybox","fsck"],"title":"使用fsck命令检查并修复linux文件系统","uri":"/20200605-%E4%BD%BF%E7%94%A8fsck%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8Dlinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Linux"],"content":"fsck fsck（file system check）用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。 ","date":"2020-06-05","objectID":"/20200605-%E4%BD%BF%E7%94%A8fsck%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8Dlinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:4","tags":["busybox","fsck"],"title":"使用fsck命令检查并修复linux文件系统","uri":"/20200605-%E4%BD%BF%E7%94%A8fsck%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8Dlinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["智能家具"],"content":"缘起 作为一名生命不止，折腾不息的小geek, 对享有智能生活， 掌握智能数据早已觊觎已久。奈何时间，空间，设备的限制一直未能如愿。 恰巧手头有一套yeelight智能吸顶灯，来发挥一直关注的HomeAssistant项目的威力！ 今天就将智能家居这个小兴趣来作为忙碌工作生活中的调剂吧。 ","date":"2020-05-24","objectID":"/20200524-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85homeassistant%E5%85%B3%E8%81%94yeelight%E6%99%BA%E8%83%BD%E5%90%B8%E9%A1%B6%E7%81%AF/:1:0","tags":["HomeAssistant","yeelight","IOT"],"title":"智能家居HomeAssistant关联yeelight智能吸顶灯","uri":"/20200524-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85homeassistant%E5%85%B3%E8%81%94yeelight%E6%99%BA%E8%83%BD%E5%90%B8%E9%A1%B6%E7%81%AF/"},{"categories":["智能家具"],"content":"HomeAssistant是什么 HomeAssistant是一套开源的家庭自动化系统，以Python为主要开发语言。拥有支持集成各种智能硬件设备（智能电器，传感器，监控设备，etc），自动化任务编排，数据统计等功能。拥有无限的扩展能力。 ","date":"2020-05-24","objectID":"/20200524-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85homeassistant%E5%85%B3%E8%81%94yeelight%E6%99%BA%E8%83%BD%E5%90%B8%E9%A1%B6%E7%81%AF/:1:1","tags":["HomeAssistant","yeelight","IOT"],"title":"智能家居HomeAssistant关联yeelight智能吸顶灯","uri":"/20200524-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85homeassistant%E5%85%B3%E8%81%94yeelight%E6%99%BA%E8%83%BD%E5%90%B8%E9%A1%B6%E7%81%AF/"},{"categories":["智能家具"],"content":"安装 HomeAssistant HomeAssistant文档 # OS环境 Ubuntu20.04 mkdir homeAssistant cd homeAssistant virtualenv venv source venv/bin/activate pip3 install homeassistant hass --open-ui 注册基本信息 ","date":"2020-05-24","objectID":"/20200524-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85homeassistant%E5%85%B3%E8%81%94yeelight%E6%99%BA%E8%83%BD%E5%90%B8%E9%A1%B6%E7%81%AF/:1:2","tags":["HomeAssistant","yeelight","IOT"],"title":"智能家居HomeAssistant关联yeelight智能吸顶灯","uri":"/20200524-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85homeassistant%E5%85%B3%E8%81%94yeelight%E6%99%BA%E8%83%BD%E5%90%B8%E9%A1%B6%E7%81%AF/"},{"categories":["智能家具"],"content":"集成yeelight智能吸顶灯 yeelight集成文档 基本配置（手动） 配置信息写入 /home/user/.homeassistant/configuration.yaml yeelight开启局域网控制 yeelight:devices:192.168.1.25:name:玄关192.168.1.26:name:客厅192.168.1.27:name:主卧192.168.1.28:name:次卧 重启hass服务生效 ","date":"2020-05-24","objectID":"/20200524-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85homeassistant%E5%85%B3%E8%81%94yeelight%E6%99%BA%E8%83%BD%E5%90%B8%E9%A1%B6%E7%81%AF/:1:3","tags":["HomeAssistant","yeelight","IOT"],"title":"智能家居HomeAssistant关联yeelight智能吸顶灯","uri":"/20200524-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85homeassistant%E5%85%B3%E8%81%94yeelight%E6%99%BA%E8%83%BD%E5%90%B8%E9%A1%B6%E7%81%AF/"},{"categories":["智能家具"],"content":"默认功能一瞥 支持单个灯控制与灯组开关控制。 支持亮度控制与色温控制。 灯组及系统的开关时间记录。 以可视化图表的形式展示历史记录。 ","date":"2020-05-24","objectID":"/20200524-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85homeassistant%E5%85%B3%E8%81%94yeelight%E6%99%BA%E8%83%BD%E5%90%B8%E9%A1%B6%E7%81%AF/:2:0","tags":["HomeAssistant","yeelight","IOT"],"title":"智能家居HomeAssistant关联yeelight智能吸顶灯","uri":"/20200524-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85homeassistant%E5%85%B3%E8%81%94yeelight%E6%99%BA%E8%83%BD%E5%90%B8%E9%A1%B6%E7%81%AF/"},{"categories":["基础设施"],"content":"Dockerfile FROM python:3.8.2 ENV PYTHONUNBUFFERED 1 RUN mkdir /code WORKDIR /code COPY requirements.txt /code/ RUN pip install -r requirements.txt COPY . /code/ RUN docker build . ","date":"2020-05-13","objectID":"/20200513-docker%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BAdjango%E9%95%9C%E5%83%8F%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/:0:1","tags":["Docker","Django","docker-compose"],"title":"Docker笔记-使用Dockerfile构建Django镜像的简单示例","uri":"/20200513-docker%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BAdjango%E9%95%9C%E5%83%8F%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/"},{"categories":["基础设施"],"content":"docker-compose.yml version:'3'services:web:build:.command:python manage.py runserver 0.0.0.0:8080volumes:- .:/codeports:- \"8080:8080\" RUN docker-compose up -d ","date":"2020-05-13","objectID":"/20200513-docker%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BAdjango%E9%95%9C%E5%83%8F%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/:0:2","tags":["Docker","Django","docker-compose"],"title":"Docker笔记-使用Dockerfile构建Django镜像的简单示例","uri":"/20200513-docker%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BAdjango%E9%95%9C%E5%83%8F%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/"},{"categories":["Python","数据处理"],"content":" pip3 install python-docx; pip3 install xlwl; ","date":"2020-05-08","objectID":"/20200508-%E4%BB%8Eword%E6%96%87%E4%BB%B6%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%88%B0excel%E6%96%87%E4%BB%B6/:0:0","tags":["docx","xlwl"],"title":"从Word文件抽取数据导入到Excel文件","uri":"/20200508-%E4%BB%8Eword%E6%96%87%E4%BB%B6%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%88%B0excel%E6%96%87%E4%BB%B6/"},{"categories":["Python","数据处理"],"content":"从docx抽取数据 import docx def get_docx(): from docx import Document path = \"info.docx\" document = Document(path) Lines = [] for paragraph in document.paragraphs: Lines.append(paragraph.text) return Lines ","date":"2020-05-08","objectID":"/20200508-%E4%BB%8Eword%E6%96%87%E4%BB%B6%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%88%B0excel%E6%96%87%E4%BB%B6/:0:1","tags":["docx","xlwl"],"title":"从Word文件抽取数据导入到Excel文件","uri":"/20200508-%E4%BB%8Eword%E6%96%87%E4%BB%B6%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%88%B0excel%E6%96%87%E4%BB%B6/"},{"categories":["Python","数据处理"],"content":"写入xls文件 import xlwt workbook = xlwt.Workbook(encoding = 'utf-8') worksheet = workbook.add_sheet('My Worksheet') # 0行 0列 写入 something worksheet.write(0, 0, label='something') workbook.save('result.xls') ","date":"2020-05-08","objectID":"/20200508-%E4%BB%8Eword%E6%96%87%E4%BB%B6%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%88%B0excel%E6%96%87%E4%BB%B6/:0:2","tags":["docx","xlwl"],"title":"从Word文件抽取数据导入到Excel文件","uri":"/20200508-%E4%BB%8Eword%E6%96%87%E4%BB%B6%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%88%B0excel%E6%96%87%E4%BB%B6/"},{"categories":["Python","数据处理"],"content":"结合使用 import docx, xlwt from docx import Document def get_docx(): path = \"info.docx\" document = Document(path) Lines = [] for paragraph in document.paragraphs: Lines.append(paragraph.text) return Lines def main(): workbook = xlwt.Workbook(encoding = 'utf-8') worksheet = workbook.add_sheet('My Worksheet') contents = get_docx() for index, content in enumerate(contents): print(content, index) worksheet.write(index, 1, label=content) workbook.save('result.xls') if __name__ == '__main__': main() ","date":"2020-05-08","objectID":"/20200508-%E4%BB%8Eword%E6%96%87%E4%BB%B6%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%88%B0excel%E6%96%87%E4%BB%B6/:0:3","tags":["docx","xlwl"],"title":"从Word文件抽取数据导入到Excel文件","uri":"/20200508-%E4%BB%8Eword%E6%96%87%E4%BB%B6%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%88%B0excel%E6%96%87%E4%BB%B6/"},{"categories":["Linux"],"content":"将中文名目录改为英文（因为英文名称在 Terminal 终端 中更容易操作。）： #debian/Ubuntu export LANG=en_US xdg-user-dirs-gtk-update export LANG=zh_CN 在弹出的窗口中勾选 升级新的名称 重启后 现在是英文名称，在弹出的窗口中勾选保留现有名称，并勾选下次不再询问，然后点击确定。 ","date":"2020-05-01","objectID":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:0:0","tags":["配置","Linux","Ubuntu"],"title":"Ubuntu20.04配置笔记","uri":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"},{"categories":["Linux"],"content":"环境变量 追加写入全局配置路径 /etc/profile 写入当前用户配置路径 ~/.bashrc or ~/.zshrc # HISTORY history 日志添加时间戳；默认的2000条记录上限提高至99999条 export HISTTIMEFORMAT=\"%Y-%m-%d %H:%M:%S \" export HISTFILESIZE=99999 # node env 个人习惯把程序环境都放在 /opt 目录下 export PATH=$PATH:/opt/node/bin # npm global env export PATH=~/.npm-global/bin:$PATH # env jdk JAVA_HOME=/opt/jdk CLASSPATH=.:$JAVA_HOME/lib.tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH # env golang export GOROOT=/opt/go export GOPATH=~/golib:~/goproject/ export GOBIN=~/gobin export PATH=$PATH:$GOROOT/bin:$GOBIN # redis env export REDIS_HOME=/opt/redis export PATH=$PATH:$REDIS_HOME/src # hadoop 3.1.1 env export HADOOP_HOME=/opt/hadoop-3.1.1 export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin # hadoop 2.8.5 env #export HADOOP_HOME=/opt/hadoop-2.8.5 #export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin # hbase env export HBASE_HOME=/opt/hbase-2.1.1 export PATH=$PATH:$HBASE_HOME/bin # mongodb export PATH=/opt/mongodb/bin:$PATH # RUST env export PATH=\"$HOME/.cargo/bin:$PATH\" # android env export ANDROID_HOME=$HOME/Android/Sdk export PATH=$PATH:$ANDROID_HOME/tools export PATH=$PATH:$ANDROID_HOME/tools/bin export PATH=$PATH:$ANDROID_HOME/platform-tools export PATH=$PATH:$ANDROID_HOME/emulator # QT env export QTDIR=/opt/Qt/5.11.0/gcc_64/ export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${QTDIR}/lib export PATH=${QTDIR}/bin:${PATH} alias postman='cd /opt/Postman/ \u0026\u0026 ./Postman' alias datagrip='/opt/Datagrip/bin/datagrip.sh' alias pycham='/opt/pycharm/bin/pycharm.sh' alias idea='/opt/idea/bin/idea.sh' alias webstorm='/opt/pycharm/bin/webstorm.sh' alias spoon='sh /opt/di/spoon.sh' alias elasticsearch='/opt/elasticsearch/bin/elasticsearch' alias kibana='/opt/kibana/bin/kibana' alias spoon='cd /opt/data-integration/ \u0026\u0026 ./spoon.sh' alias robo3t='cd /opt/robo3t/bin/ \u0026\u0026 ./robo3t \u0026' alias justmd='cd /opt/justmd/ \u0026\u0026 ./justmd \u0026' alias vnote='/opt/vnote.AppImage \u0026' ","date":"2020-05-01","objectID":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:1:0","tags":["配置","Linux","Ubuntu"],"title":"Ubuntu20.04配置笔记","uri":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"},{"categories":["Linux"],"content":"软件 ","date":"2020-05-01","objectID":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:2:0","tags":["配置","Linux","Ubuntu"],"title":"Ubuntu20.04配置笔记","uri":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"},{"categories":["Linux"],"content":"常用工具 sudo -- sh -c ' sudo apt update sudo apt upgrade sudo apt install -y cmake; sudo apt install -y git; sudo apt install -y vim; sudo apt install -y htop; # 资源监控工具 sudo apt install -y glances; sudo apt install -y tree; sudo apt install -y curl; sudo apt install -y aria2; sudo apt install -y whois; sudo apt install -y unrar; sudo apt install -y lrzsz; # 新立得软件包管理器 sudo apt install -y synaptic; # 用于查找缺失的依赖库 apt-file search xxx.so sudo apt install -y apt-file; sudo apt install -y python3-distutils; sudo apt-get install -y libmysqlclient-dev; sudo apt install -y python3-pip; sudo apt install -y zlib1g-dev; sudo apt install -y virtualenv; sudo apt install -y nginx; sudo apt install -y supervisor; sudo apt install -y nmap; # Common Lisp compiler sudo apt-get install -y sbcl; # 为源码文件生成一个索引（标签）文件 sudo apt install ctags; # # rime輸入法 # sudo apt-get install ibus-rime; # 功能强大的词典， 需要配置第三方词典资源 sudo apt install -y goldendict; # 文档格式转换 sudo apt install -y pandoc; # 文本版本差异对比，合并工具 可视化的diff和merge 工具 sudo apt install -y meld; # 远程桌面客户端 sudo apt install -y remmina; # VCN 客户端 可远程控制 mac 桌面 sudo apt install -y krdc; # 开源多媒体播放器， 感觉比VLC稳定。 sudo apt install -y smplayer; sudo apt install -y qbittorrent; # 密码管理器 sudo apt install -y keepassxc; # 深度截图，国人开发，功能强大。 配合系统默认的带有延时截图的screenshot更佳。 sudo apt install -y deepin-screenshot; # 深度桌面取色器 sudo apt install -y deepin-picker; # 深度终端，支持多个ssh远程记录，好用！ 有个bug： 第一次远程需要手动连接。之后就可以一键登录远程了。 sudo apt install -y deepin-terminal; # 通过管道监控数据进度 sudo apt install -y pv; sudo apt install -y neofetch; # 番茄时钟 sudo apt install -y gnome-shell-pomodoro; # tweaks 界面功能增强，时钟显示秒，设置。 sudo apt-get install -y gnome-tweaks; # sudo pip3 install jupyterlab; ' # 检查是否存在SSH秘钥 ls -al ~/.ssh # 生成ssh-key 密钥对 ssh-keygen -t rsa -C \"spaceack@qq.com\" # 将SSH key添加到ssh-agent： ssh-add ~/.ssh/id_rsa # 启用ssh sudo apt update sudo apt install openssh-server sudo systemctl status ssh # 禁用 sudo systemctl disable --now ssh # 重启 sudo systemctl enable --now ssh 需要注意 `.ssh`目录中文件的权限，否则会爆错 `bad permissions` chmod 600 .ssh/id_rsa chmod 644 .ssh/id_rsa.pub npm非root全局安装权限 mkdir ~/.npm-global npm config set prefix '~/.npm-global' # .bashrc 加入 export PATH=~/.npm-global/bin:$PATH source .bashrc ","date":"2020-05-01","objectID":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:2:1","tags":["配置","Linux","Ubuntu"],"title":"Ubuntu20.04配置笔记","uri":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"},{"categories":["Linux"],"content":"实用工具 rime输入法 F4 切换输入方案 sudo apt-get install ibus-rime ibus restart ibus engine rime Visual Studio Code Logseq 双链笔记 electerm electerm是一个跨平台的Terminal/SSH/SFTP客户端工具，同时支持Linux、MacOS、Windows，基于electron/ssh2/node-pty/xterm/antd/subx等开源组件。 CherryTree 功能强大的树形笔记工具 VNote 功能强大的 Vim 和 MarkDown 笔记工具 DBeaver 通用数据库管理 Another Redis Desktop Manager Another Redis Desktop Manager RDM 开源 Redis ® 管理工具 sudo snap install redis-desktop-manager Zeal 离线文档浏览器 sudo add-apt-repository ppa:zeal-developers/ppa sudo apt-get update sudo apt-get install zeal OBS(Open Broadcaster Software) 开源视频录制与直播软件 sudo apt install ffmpeg sudo add-apt-repository ppa:obsproject/obs-studio sudo apt update sudo apt install obs-studio ventoy 多系统安装启动U盘制作工具 Ventoy Peek 超级好用的屏幕GIF动画录制器 sudo add-apt-repository ppa:peek-developers/stable sudo apt-get update sudo apt-get install peek yEd 绘制流程图download BlinkMind BlinkMind 简洁的思维导图工具 KRDC 好用的远程桌面客户端 GIMP 功能强大的图像处理和绘画软件 Syncthing 多台设备双向文件同步工具 FreeFileSync FreeFileSync 开源的文件和目录 同步，备份，比较工具。 VirtualBox 虚拟机 Motrix 多功能下载器 特性： Async DNS BitTorrent Firefox3 Cookie GZip HTTPS Message Digest Metalink XML-RPC SFTP balenaEtcher 镜像写入工具 支持的映像格式包括：img、iso、zip、bz2、dsk、etch、gz、hddimg、raw、xz等； calibre 电子书管理工具 sudo -v \u0026\u0026 wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin 永中Office 体验不佳，暂不推荐~ 推荐使用 LibreOffice robo3t MongoDB可视化工具 OmegaT 开源计算机辅助翻译软件 linux 字符终端 tty下显示中文 sudo apt-get install fbterm -y sudo gpasswd -a $USER video sudo chmod u+s /usr/bin/fbterm ","date":"2020-05-01","objectID":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:2:2","tags":["配置","Linux","Ubuntu"],"title":"Ubuntu20.04配置笔记","uri":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"},{"categories":["Linux"],"content":"趣味软件 sonic-pi 通过编码的音乐合成器 figlet 命令行艺术字效果 neofetch Godot 开源游戏引擎 命令行查询天气 curl http://wttr.in/ ","date":"2020-05-01","objectID":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:2:3","tags":["配置","Linux","Ubuntu"],"title":"Ubuntu20.04配置笔记","uri":"/20200501-ubuntu20.04%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"},{"categories":["数据处理"],"content":"挂载Google云端硬盘 from google.colab import drive import os drive.mount('/content/drive') data_dir = 'drive/My Drive/dataset-resized' output_dir = 'drive/My Drive/out_put' logs = 'drive/My Drive/logs' os.listdir(data_dir) Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True). ","date":"2020-04-24","objectID":"/20200424-%E5%9C%A8googlecolab%E4%B8%8A%E5%AD%A6%E4%B9%A0tensorflow/:0:1","tags":["GoogleColab","Tensorflow"],"title":"在Google Colab上学习Tensorflow","uri":"/20200424-%E5%9C%A8googlecolab%E4%B8%8A%E5%AD%A6%E4%B9%A0tensorflow/"},{"categories":["数据处理"],"content":"查看被分配的GPU： ! nvidia-smi Tue May 19 00:23:20 2020 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 440.82 Driver Version: 418.67 CUDA Version: 10.1 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | |===============================+======================+======================| | 0 Tesla P4 Off | 00000000:00:04.0 Off | 0 | | N/A 40C P8 7W / 75W | 0MiB / 7611MiB | 0% Default | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: GPU Memory | | GPU PID Type Process name Usage | |=============================================================================| | No running processes found | +-----------------------------------------------------------------------------+ ","date":"2020-04-24","objectID":"/20200424-%E5%9C%A8googlecolab%E4%B8%8A%E5%AD%A6%E4%B9%A0tensorflow/:0:2","tags":["GoogleColab","Tensorflow"],"title":"在Google Colab上学习Tensorflow","uri":"/20200424-%E5%9C%A8googlecolab%E4%B8%8A%E5%AD%A6%E4%B9%A0tensorflow/"},{"categories":["数据处理"],"content":" # 导入库 from keras.callbacks import TensorBoard # 创建tensorboard对象， 结果保存在logs目录下 tensorboard = TensorBoard(log_dir='logs/{}'.format(NAME),histogram_freq=1,write_grads=True) # 在模型生成器函数作为回调参数 model.fit_generator( generator=train_generator, epochs=100, steps_per_epoch=2200 // BATCH_SIZE, validation_data=validation_generator, validation_steps=200 // BATCH_SIZE, callbacks=[tensorboard] ) 在浏览器中展示数据 tensorboard --logdir=logs ","date":"2020-04-23","objectID":"/20200423-keras%E4%BD%BF%E7%94%A8tensorboard/:0:0","tags":["tensorboard","keras"],"title":"keras使用tensorboard","uri":"/20200423-keras%E4%BD%BF%E7%94%A8tensorboard/"},{"categories":["数据处理"],"content":"简单来讲， 大多数人的PC都有很大一部分闲时，通过Folding@Home分布式计算项目，每个人都可以将这一部分算力贡献出来，为抗击病毒，解决医学难题，甚至是寻找外星人做贡献。 ","date":"2020-04-08","objectID":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/:0:0","tags":["分布式计算"],"title":"为抗击病毒助力，你也可以！加入Folding@Home项目参与病毒研究运算！","uri":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/"},{"categories":["数据处理"],"content":"什么是Folding@Home工程？ Folding@home 是在2000 年10 月1 日正式启动的一项世界上最大的分散式计算计划，通过号召大家GPU闲置时的计算能力，帮助科学家们了解、抵抗病毒。专注于精确地类比蛋白质折叠和错误折叠的过程，以便能更好地了解多种疾病的起因和发展，包括阿兹海默症、亨廷顿舞蹈症、牛海绵状脑病（狂牛症、狂牛症）、癌症和囊胞性纤维症。到目前为止，Folding@home 已成功类比5—10微秒的折叠过程，超出先前估计可类比的时段数千倍。现在 Folding@Home 已经上线了肺炎项目，打开 Folding@home 主页，点击“Start Folding Now”，在新的网页中点击“Download Now”即可进入下载页。 计算框架支持 MAC OS， Android, Windows, Linux等多种平台。 ","date":"2020-04-08","objectID":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/:0:1","tags":["分布式计算"],"title":"为抗击病毒助力，你也可以！加入Folding@Home项目参与病毒研究运算！","uri":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/"},{"categories":["数据处理"],"content":"Folding@home 怎么运作的？ Folding@home 并不是依靠超级电脑来运算，主要是透过全世界成千上万的个人电脑，由用户自愿参加，并在电脑中安装客户端程序，工具就会在系统闲置时，利用CPU 多核和GPU 图型运算来工作，主要是避免电脑平常没在使用时浪费运算能力，如果用户使用时，也不会影响到原本作业，不过会有几项缺点： 比较吃效能（如需要使用时，可以关闭程式），（可以选择Light模式，仅占用很少一部分效能。） 要发挥运算，造成风扇声偏大，（可以选择Light模式，仅占用很少一部分效能。） 比较耗电，如果是笔电会导致电池提早老化 Folding@Home 会定时连接设于斯坦福大学的伺服器去取得「工作单元」（work units），即一种存有实验资料的资料包，根据实验资料进行计算。每个工作单元计算完成后，再传回伺服器。 ","date":"2020-04-08","objectID":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/:0:2","tags":["分布式计算"],"title":"为抗击病毒助力，你也可以！加入Folding@Home项目参与病毒研究运算！","uri":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/"},{"categories":["数据处理"],"content":"如何使用 Floding@home 加入运算？ 进入下载页面，下载安装软件: 如果你的系统不是Windows，点击页面下方的“alternative downloads”，即可在选择你的操作系统，Mac、Linux常见发行版都能支持，甚至之前“模拟地球”的PS3都支持，希望索尼和微软能够重新将Folding@Home带回主机。 客户端下载安装完成之后，会在后台运行，退出客户端即自动结束。Folding@Home运行后会在桌面右下角显示小图标，通过访问 https://client.foldingathome.org/ 就能通过网页方便的控制程序。那么我们怎样设定Covid-19优先计算呢？ WEB控制台 在网页控制页面的 “I support research fighting” 中选择 “Any Desease”，尽管Folding@Home不允许专门为某一个项目贡献算力，但由于现在特殊时期，肺炎相关项目拥有最高优先级，会自动分配给你相关项目计算。 桌面控制端： 在下载完任务包之后，Folding@Home就自动开始计算了，如果大家在工作可以将算力调至中档保证自己工作效率，算力大小也是CPU和显卡性能的一大参考指标。你还可以去 https://apps.foldingathome.org/passkey/create 申请Passkey来获取额外分数奖励。 Name自己任意填，留下邮箱点击“Get Passkey”即可收到你的专属Passkey，然后再去FAH控制台填入即可。右键FAH图标，选择\"FAHControl\"，在弹出的界面中点击左上角“Configure”齿轮图标，再选择“Identity”选项卡，填入你刚刚申请的Name和Passkey，Team Number可以填入3213为中国队添砖加瓦。 Folding@Home 还涉及到众多计算机等相关知识，而我们贡献出自己电脑的一点算力就已足够，感兴趣的同学可以去项目官网、Github等深挖。在电脑贡献出力量之后，我们自己也能凭借自己的聪明才智，帮助科学家们一起对抗病毒。 ","date":"2020-04-08","objectID":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/:0:3","tags":["分布式计算"],"title":"为抗击病毒助力，你也可以！加入Folding@Home项目参与病毒研究运算！","uri":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/"},{"categories":["数据处理"],"content":"如何查看自己的积分？ 团队积分排行： 目前排名第一的是由开源操作系统Linux领袖领导的团队。中国团队排名第11位 个人积分： 通过https://stats.foldingathome.org/donor/+自己填入的Name 例如：https://stats.foldingathome.org/donor/Spaceack ","date":"2020-04-08","objectID":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/:0:4","tags":["分布式计算"],"title":"为抗击病毒助力，你也可以！加入Folding@Home项目参与病毒研究运算！","uri":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/"},{"categories":["数据处理"],"content":"什么是Foldit项目？ 相比Folding@Home 借助算法和算力解决蛋白质折叠问题，Foldit则充分利用人类与生俱来的三维能力和解谜思维。Foldit在2月底上线了肺炎病毒的内容，大家可以通过解谜游戏来帮助研究人员发现抗击肺炎病毒的药物。 [图片来自于@ Foldit，版权属于原作者 目前Foldit抗击肺炎病毒的活动来到第3轮，在页面右方可以下载游戏，Windows、Mac和Linux全平台支持。 图片来自于@ 小编，版权属于原作者 游戏下载安装完成后，我们来看看怎样才能上手吧。你可以在官网注册账号，用账号登陆游戏，你可以查看自己的得分和世界排名。Foldit上手需要了解一些病毒的基础知识，对于新手来说游戏的门槛其实不低，我们先从 Intro Puzzle 来练练手吧。新手关，你需要拖动侧链来避免冲突，只需要将左边的侧链往外拖动即可解决。 图片来自于@ 小编，版权属于原作者 当你渐入佳境之后，你可能会碰到从零开始设计蛋白质结构、解决冲突、蛋白空腔等问题。在你觉得脑洞已经打开之后，可以试着解决现实中的问题，在主菜单中选择 “Science Puzzles”。 排在第一位的就是冠状病毒，我们还可以往下拉，就能看到目前正在进行的第3轮Foldit抗击肺炎病毒的活动。 在游戏中我们可以看到肺炎病毒的真实结构，为了能阻止病毒和人类受体相互作用，实现药物对于肺炎病毒的靶向攻击，大家需要设计一种和病毒开放侧链结合的蛋白质，将蓝色的侧链和水的结合断开，也就是说破坏蓝色侧链和水形成的稳定氢键(Hydrogen bonds)。 那么玩Foldit真的能够解决实际问题吗，答案是肯定的！举个栗子，科学家们一直在尝试研究解构爱滋病的一项蛋白质“Retroviral Protease”长达15年，这种逆转录酶是爱滋病毒在活体细胞中复制和繁殖的关键。在Retroviral Protease上线Foldit之后，全世界的玩家们仅用10天时间搞定它的结构破解！ 文章参考: 特殊时期，我总想做点什么 —— Folding@Home + Foldit把手举起来 ","date":"2020-04-08","objectID":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/:0:5","tags":["分布式计算"],"title":"为抗击病毒助力，你也可以！加入Folding@Home项目参与病毒研究运算！","uri":"/20200408-%E4%B8%BA%E6%8A%97%E5%87%BB%E7%97%85%E6%AF%92%E5%8A%A9%E5%8A%9B%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/"},{"categories":["Python"],"content":"在更新模型的时候遇到问题，网上有说删app下migrations目录的，有说要删数据库django_migrations表的, 还有的要在数据库中更改字段的。 但是有更好的方法， 如下： python manage.py makemigrations app python manage.py migrate --fake app 在app.models 中更新字段 python manage.py makemigrations app 在migrations文件夹中添加一个新的文件，并将更新添加到db python manage.py migrate app ","date":"2020-03-18","objectID":"/20200318-django%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/:0:0","tags":["Django"],"title":"Django更新数据模型","uri":"/20200318-django%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"},{"categories":["网络"],"content":"一般截图工具仅能截道可视的部分： 使用谷歌浏览器内置命令可以方便的对长网页进行截屏操作： 按下 F12 键位 同时按下 Ctrl+Shift+P 键位 输入 Capture full size screenshot 点击命令项（注意命令前不能有空格） 此时长截图已经下载好啦！ ","date":"2020-03-12","objectID":"/20200312-%E5%B0%8F%E6%8A%80%E5%B7%A7-chrome%E9%95%BF%E6%88%AA%E5%B1%8F/:0:0","tags":["浏览器"],"title":"小技巧-Chrome长截屏","uri":"/20200312-%E5%B0%8F%E6%8A%80%E5%B7%A7-chrome%E9%95%BF%E6%88%AA%E5%B1%8F/"},{"categories":["网络"],"content":"git clone 代理 git config --global http.proxy http://127.0.0.1:10809 git config --global https.proxy https://127.0.0.1:1081 # 查看代理配置 git config --global -e # 取消代理 git config --global --unset http.proxy ","date":"2020-03-11","objectID":"/20200310-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%B7%A7%E7%94%A8%E4%BB%A3%E7%90%86/:1:0","tags":["proxy"],"title":"科学上网-巧用镜像站","uri":"/20200310-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%B7%A7%E7%94%A8%E4%BB%A3%E7%90%86/"},{"categories":["网络"],"content":"华为云镜像 阿里云镜像 腾讯云镜像 清华大学开源软件镜像站 这几个镜像站真香啊， 包括了很多开源镜像， 包括Elasticsearch， Android SDK，OS镜像，网络授时NTP等， 这部分阔以免去翻墙打洞的烦恼啦。 ","date":"2020-03-11","objectID":"/20200311-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%B7%A7%E7%94%A8%E9%95%9C%E5%83%8F%E7%AB%99/:0:0","tags":["开源镜像","科学上网"],"title":"科学上网-巧用镜像站","uri":"/20200311-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%B7%A7%E7%94%A8%E9%95%9C%E5%83%8F%E7%AB%99/"},{"categories":["网络"],"content":"pip 镜像加速 --index-url=http://mirrors.aliyun.com/pypi/simple/ --trusted-host=mirrors.aliyun.com ","date":"2020-03-11","objectID":"/20200311-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%B7%A7%E7%94%A8%E9%95%9C%E5%83%8F%E7%AB%99/:1:0","tags":["开源镜像","科学上网"],"title":"科学上网-巧用镜像站","uri":"/20200311-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%B7%A7%E7%94%A8%E9%95%9C%E5%83%8F%E7%AB%99/"},{"categories":["网络"],"content":"npm 加速 npm install -g cnpm --registry=https://registry.npm.taobao.org npm config set registry https://registry.npm.taobao.org ","date":"2020-03-11","objectID":"/20200311-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%B7%A7%E7%94%A8%E9%95%9C%E5%83%8F%E7%AB%99/:2:0","tags":["开源镜像","科学上网"],"title":"科学上网-巧用镜像站","uri":"/20200311-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%B7%A7%E7%94%A8%E9%95%9C%E5%83%8F%E7%AB%99/"},{"categories":["数据处理"],"content":"1.建立Mysql连接 ","date":"2020-02-21","objectID":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/:0:1","tags":["PDI","kettle","数据处理"],"title":"使用PDI从Mysql抽取数据存入到Sqlite","uri":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/"},{"categories":["数据处理"],"content":"2.建立Sqlite连接 自定义连接URL：jdbc:sqlite:/data/testdb.sqlite3 自定义驱动类型 org.sqlite.JDBC ","date":"2020-02-21","objectID":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/:0:2","tags":["PDI","kettle","数据处理"],"title":"使用PDI从Mysql抽取数据存入到Sqlite","uri":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/"},{"categories":["数据处理"],"content":"3.建立抽取和插入步骤  ","date":"2020-02-21","objectID":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/:0:3","tags":["PDI","kettle","数据处理"],"title":"使用PDI从Mysql抽取数据存入到Sqlite","uri":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/"},{"categories":["数据处理"],"content":"4.编辑输入步骤 ","date":"2020-02-21","objectID":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/:0:4","tags":["PDI","kettle","数据处理"],"title":"使用PDI从Mysql抽取数据存入到Sqlite","uri":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/"},{"categories":["数据处理"],"content":"5.编辑插入步骤 如果两边字段都完全一致kettle会自动映射匹配 ","date":"2020-02-21","objectID":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/:0:5","tags":["PDI","kettle","数据处理"],"title":"使用PDI从Mysql抽取数据存入到Sqlite","uri":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/"},{"categories":["数据处理"],"content":"6.运行转换，启动所有步骤： 转换完成! ","date":"2020-02-21","objectID":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/:0:6","tags":["PDI","kettle","数据处理"],"title":"使用PDI从Mysql抽取数据存入到Sqlite","uri":"/20200221-%E4%BD%BF%E7%94%A8pdi%E4%BB%8Emysql%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0sqlite/"},{"categories":["特效"],"content":"第一种实现 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003e浮窗效果\u003c/title\u003e \u003cstyle\u003e * { margin: 0; padding: 0; } #box { width: 200px; height: 200px; left: 0; top: 0; border: 1px solid #eee; box-shadow: 0 0 5px #ccc; position: absolute; } #box h2 { padding: 8px 4px; font-size: 16px; color: #666666; } #box p { padding: 8px 4px; font-size: 12px; color: #a9a9a9; line-height: 20px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"box\"\u003e \u003cimg src=\"octocat.png\" alt=\"章鱼猫\"/\u003e \u003cp\u003e\u003ca href=\"#\"\u003e章鱼猫\u003c/a\u003e\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e let box = document.getElementById('box'); let speedX = 15, speedY = 12; //水平方向运动最大值 let maxL = document.documentElement.clientWidth - box.offsetWidth; maxT = document.documentElement.clientHeight - box.offsetHeight; let timer = null; box.onmouseenter = function () { clearInterval(timer); }; box.onmouseleave = function () { autoMove(); }; autoMove(); function autoMove() { timer = setInterval(() =\u003e { let nextX = box.offsetLeft + speedX; nextY = box.offsetTop + speedY; //左侧边界 if (nextX \u003c= 0) { nextX = 0; speedX *= -1; } //上侧边界 if (nextY \u003c= 0) { nextY = 0; speedY *= -1; } //右侧边界 if (nextX \u003e= maxL) { nextX = maxL; speedX *= -1; } //底侧边界 if (nextY \u003e= maxT) { nextY = maxT; speedY *= -1; } box.style.left = nextX + 'px'; box.style.top = nextY + 'px'; }, 80); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-01-07","objectID":"/20200107-%E5%89%8D%E7%AB%AF%E9%A3%98%E7%AA%97%E6%95%88%E6%9E%9C/:1:0","tags":["前端特效","飘窗"],"title":"飘窗效果","uri":"/20200107-%E5%89%8D%E7%AB%AF%E9%A3%98%E7%AA%97%E6%95%88%E6%9E%9C/"},{"categories":["特效"],"content":"第二种实现，更平滑 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e飘窗效果\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e * { margin: 0px; padding: 0px } #ad { position: absolute; left: 0px; top: 0px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"ad\"\u003e\u003cimg src=\"octocat.png\" alt=\"章鱼猫\"/\u003e \u003cp\u003e\u003ca href=\"#\"\u003e章鱼猫\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e \u003c/body\u003e \u003cscript type=\"text/javascript\"\u003e //通过ID获取img ad = document.getElementById(\"ad\"); //定义横纵坐标 x = 0; y = 0; //设置初始速度 xv = 1.5; yv = 1.5; //根据img横纵坐标位置，设置反方向速度 function fun() { if (x \u003c 0 || x \u003e window.innerWidth - ad.offsetWidth) { xv = -xv; } if (y \u003c 0 || y \u003e window.innerHeight - ad.offsetHeight) { yv = -yv; } x += xv; y += yv; //将xy坐标值赋予img css样式中的left与top ad.style.left = x + \"px\"; ad.style.top = y + \"px\"; } //定时器调用 mytime = setInterval(fun, 100); //ad绑定鼠标悬停事件 ad.onmouseover = function () { //清除定时器 clearInterval(mytime); } //鼠标离开，重新触发定时器 ad.onmouseout = function () { mytime = setInterval(fun, 100); }\u003c/script\u003e \u003c/html\u003e ","date":"2020-01-07","objectID":"/20200107-%E5%89%8D%E7%AB%AF%E9%A3%98%E7%AA%97%E6%95%88%E6%9E%9C/:2:0","tags":["前端特效","飘窗"],"title":"飘窗效果","uri":"/20200107-%E5%89%8D%E7%AB%AF%E9%A3%98%E7%AA%97%E6%95%88%E6%9E%9C/"},{"categories":["网络"],"content":" name desc Wappalyzer 网站技术架构分析，分析目标网站所采用的平台构架、网站环境、服务器配置环境、JavaScript框架、编程语言等参数 User-Agent Switcher and Manager User-Agent 管理 EditThisCookie Cookie 管理 QR Code Generator QR Code Tampermonkey 用户脚本管理器 greasyfork SwitchyOmega 代理设置工具 Vimum 使用vim键位操作浏览器 Video Download Professional 媒体下载工具 highlight multiple 多关键词高亮 ","date":"2019-12-29","objectID":"/20191229-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95/:0:0","tags":["科学上网","browser"],"title":"浏览器常用扩展","uri":"/20191229-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"demo data = {\"column_name\":[\"name\", \"age\", \"sex\"], \"column\": [[\"Jack\", \"25\", \"male\"], [\"Rebot\",\"18\", \"male\"]]} col_ks = data.get(\"column_name\") col_vs = data.get(\"column\") def dict_to_table(ks, vs): \"\"\" desc: dict2html_table \"\"\" th = '' for name in ks: th = th + '\u003cth\u003e' + name + '\u003c/th\u003e' trth = '\u003ctr\u003e' + th + '\u003c/tr\u003e' trtd = '' for tds in vs: tdss = '' for td in tds: tdss = tdss + '\u003ctd\u003e' + str(td) + '\u003c/td\u003e' tdss = '\u003ctr\u003e' + tdss + '\u003c/tr\u003e' trtd = trtd + tdss return '\u003ctable\u003e' + trth + trtd + '\u003c/table\u003e' print(dict_to_table(col_ks, col_vs)) # \u003ctable\u003e\u003ctr\u003e\u003cth\u003ename\u003c/th\u003e\u003cth\u003eage\u003c/th\u003e\u003cth\u003esex\u003c/th\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eJack\u003c/td\u003e\u003ctd\u003e25\u003c/td\u003e\u003ctd\u003emale\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eRebot\u003c/td\u003e\u003ctd\u003e18\u003c/td\u003e\u003ctd\u003emale\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e ","date":"2019-12-11","objectID":"/20191211-json%E7%94%9F%E6%88%90html%E8%A1%A8%E6%A0%BC/:1:0","tags":["python","string"],"title":"json生成html表格","uri":"/20191211-json%E7%94%9F%E6%88%90html%E8%A1%A8%E6%A0%BC/"},{"categories":["Python"],"content":"preview nameagesexJack25maleRebot18male ","date":"2019-12-11","objectID":"/20191211-json%E7%94%9F%E6%88%90html%E8%A1%A8%E6%A0%BC/:2:0","tags":["python","string"],"title":"json生成html表格","uri":"/20191211-json%E7%94%9F%E6%88%90html%E8%A1%A8%E6%A0%BC/"},{"categories":null,"content":"友链 url tags desc Spaceack’s Blog 生活, 技术, Python, Linux 做一个有追求的人 即对爱的渴望，知识的渴求, 苦难的理解 Lucien’s Blog 算法，pasteme 因为孤独是人之常态，所以陪伴才显得尤为珍贵。 Edwiv’s Blog 算法 永远年轻，永远热泪盈眶 极客兔兔 全栈 致力于分享有趣的技术实践 MagicLen 全栈 多元化原创文章，内容包罗万象，有编程语言、网站应用、软件介绍、硬件介绍、操作系统、旅行游记、专题采访、益智问题、文学创作，以及作者们的知识分享和作品分享。 骏马金龙 技术大牛 网名骏马金龙，钟情于IT世界里的各种原理和实现机制，强迫症重症患者。爱研究、爱翻译、爱分享。特借此一亩三分田记录自己成长点滴！！！ lu4nx@wiki Security,Unix,Python,Lisp, Emacs manateelazycat linux开源软件 Lisp,Emacs 戈楷旎 Happy hacking emacs! Emacs 小简博客 Java, 前端 楼外的蒹葭,傍晚的月亮,还有那鸡鸣寺的樱花 TRHX’S BLOG Python、爬虫、前端 求知若饥，虚心若愚！ 迷思语 技术大牛 一个人，一介学生，一个儿子~ 愿你我都被世界温暖以待 アストルフォの幻想郷 编程 Raoul’s Pub 谓之小一 机器学习，深度学习 永远相信-美好的事情即将发生 vmaig python django 反汇编 unix环境高级编程 imcaviare 前端 浅时光 前端，技术博客 精彩程序人生 三点水 技术干货 不积小流，无以成江海 Shuzang’s Blog golang 随心所向，素履以往 Jeremy’s blog Python Shall We Code? Python, Go, Linux, Kubernetes 建造者说 Python dabeaz Python cookbook作者 嘻嘻琦琦 Vickey’s Blog nginx, 云主机，https ","date":"2019-11-28","objectID":"/links/:1:0","tags":null,"title":"友链","uri":"/links/"},{"categories":null,"content":"网址导航 ","date":"2019-11-28","objectID":"/links/:2:0","tags":null,"title":"友链","uri":"/links/"},{"categories":null,"content":"常用网站导航 url tags Arch中文社区 Linux社区 纳威安全导航 网络安全 ChinaUnix IT技术社区 博客园 IT社区 CSDN IT技术社区 cnBeta 互联网,科技资讯 科创论坛 Geek学术社区 开源工厂 资讯，资源 transifex 国际化汉化写作网站 pexels 免费图片素材 pixabay 免费图片素材 The Architecture of Open Source Applications 程序技术，架构～～ ","date":"2019-11-28","objectID":"/links/:2:1","tags":null,"title":"友链","uri":"/links/"},{"categories":null,"content":"算法赛题 url tags 阿里天池 算法，编程比赛 腾讯云+竞赛 算法，编程比赛 稀土掘金-码上掘金 项目挑战赛 洛谷 NOIP题库，比赛 力扣 leetcode中国 牛客竞赛 ACM编程 计蒜客 ACM， 信息学编程比赛 蓝桥/实验楼 技术实战，比赛 百度之星 编程比赛 华为云大赛 编程比赛 datawhale AI开源组织，数据竞赛 codewars 编程比赛 codejam 编程比赛 KAGGLE 数据分析比赛 pyweek python游戏开发挑战赛 CodinGame 编码游戏，编码挑战 ","date":"2019-11-28","objectID":"/links/:2:2","tags":null,"title":"友链","uri":"/links/"},{"categories":null,"content":"规范化标准 url tags 中文文案指北 统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。 Message Headers HTTP 消息头说明 RFC HTTP Methods HTTP 请求方法 ","date":"2019-11-28","objectID":"/links/:2:3","tags":null,"title":"友链","uri":"/links/"},{"categories":null,"content":"工具 url tags Notion 多人协作，看板 TAPD 多人协作，看板 语雀 多人协作，看板 蓝湖 多人协作，原型设计 pasteme 文本分享平台 ubuntu paste 文本分享平台 airportal 空投-文件分享平台 carbon 生成代码美化的图片 diagrams 在线画图（流程图，时序图…） le5le 在线画图（流程图，时序图…） ","date":"2019-11-28","objectID":"/links/:2:4","tags":null,"title":"友链","uri":"/links/"},{"categories":null,"content":"趣味游戏站 url tags Flash 保存计划 海量Flash游戏资源，得益于ruffle模拟器，浏览器无需flash插件也可流畅运行 在线DOS游戏 大量DOS游戏，可以直接在浏览器中开玩 poki 免费在线游戏 ","date":"2019-11-28","objectID":"/links/:2:5","tags":null,"title":"友链","uri":"/links/"},{"categories":null,"content":"添加本站为友链 # 名称 Spaceack's Blog # 主页 http://spaceack.github.io/ # markdown 链接 [Spaceack's Blog](http://spaceack.github.io/) # 标签 Python, Linux # 简介 做一个有追求的人 即对爱的渴望，知识的渴求, 苦难的理解 互加友链请邮箱私信 ","date":"2019-11-28","objectID":"/links/:3:0","tags":null,"title":"友链","uri":"/links/"},{"categories":["网络安全"],"content":" MAT：Metadata Anonymisation Toolkit ","date":"2019-11-23","objectID":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/:0:0","tags":["脱敏","元数据","mat"],"title":"使用MAT元数据匿名工具包","uri":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/"},{"categories":["网络安全"],"content":"什么是元数据Metadata? 元数据是描述其它数据的数据（data about other data）， 比如一张图片是图像数据，那么图片的拍摄时间，拍摄地点等就是它的元数据。 ","date":"2019-11-23","objectID":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/:0:1","tags":["脱敏","元数据","mat"],"title":"使用MAT元数据匿名工具包","uri":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/"},{"categories":["网络安全"],"content":"为什么要清除元数据？ 因为元数据包含时间，地点等个人敏感隐私数据。网上不乏有黑客通过社交照片的元数据信息追踪到用户地址，从而进行骚扰勒索等危险行动。包括此文中的博客, 上传图床前已经过脱敏处理. ","date":"2019-11-23","objectID":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/:0:2","tags":["脱敏","元数据","mat"],"title":"使用MAT元数据匿名工具包","uri":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/"},{"categories":["网络安全"],"content":"安装 # 安装 apt install mat # 启动图形界面 mat-gui # 查看帮助信息 mat -h usage: mat [-h] [-a] [-b] [-L] [-c] [-d] [-l] [-v] [files [files ...]] Metadata anonymisation toolkit positional arguments: files optional arguments: -h, --help show this help message and exit Options: -a, --add2archive add to output archive non-supported filetypes (Off by default) -b, --backup, -b keep a backup copy -L, --low-pdf-quality produces a lighter, but lower quality PDF Information: -c, --check check if a file is free of harmful metadatas -d, --display list all the harmful metadata of a file without removing them -l, --list list all supported fileformats -v, --version show program's version number and exit ","date":"2019-11-23","objectID":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/:1:0","tags":["脱敏","元数据","mat"],"title":"使用MAT元数据匿名工具包","uri":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/"},{"categories":["网络安全"],"content":"使用 # 参数 -c 检查是否含有元数据 mat -c metadata.jpg [+] metadata.jpg is not clean # 参数 -d 显示元数据 mat -d metadata.jpg [+] File metadata.jpg : Harmful metadata found: Orientation: Horizontal (normal) XMP Toolkit: XMP Core 4.4.0-Exiv2 Exif Image Width: 1147 Exif Image Height: 859 Exif Byte Order: Little-endian (Intel, II) Software: Shotwell 0.28.4 # 删除元数据 mat metadata.jpg [*] Cleaning metadata.jpg [+] metadata.jpg cleaned! # 再次检查 mat -c metadata.jpg [+] metadata.jpg is clean ","date":"2019-11-23","objectID":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/:2:0","tags":["脱敏","元数据","mat"],"title":"使用MAT元数据匿名工具包","uri":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/"},{"categories":["网络安全"],"content":"图形界面 添加， 清除两步操作很简单 ","date":"2019-11-23","objectID":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/:2:1","tags":["脱敏","元数据","mat"],"title":"使用MAT元数据匿名工具包","uri":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/"},{"categories":["网络安全"],"content":"支持格式 Portable Network Graphics (.png) JPEG (.jpg, .jpeg, …) TIFF (.tif, tiff, …) Open Documents (.odt, .odx, .ods, …) Office OpenXml (.docx, .pptx, .xlsx, …) Portable Document Fileformat (.pdf) Tape ARchives (.tar, .tar.bz2, …) MPEG AUdio (.mp3, .mp2, .mp1, …) Ogg Vorbis (.ogg, …) Free Lossless Audio Codec (.flac) Torrent (.torrent) ","date":"2019-11-23","objectID":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/:2:2","tags":["脱敏","元数据","mat"],"title":"使用MAT元数据匿名工具包","uri":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/"},{"categories":["网络安全"],"content":"备注 依赖Python2解释器 谨慎使用，不一定能清除所有的元数据， 尤其是深度自定义，水印或隐写数据。 ","date":"2019-11-23","objectID":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/:3:0","tags":["脱敏","元数据","mat"],"title":"使用MAT元数据匿名工具包","uri":"/20191123-%E4%BD%BF%E7%94%A8mat%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BF%E5%90%8D%E5%B7%A5%E5%85%B7%E5%8C%85/"},{"categories":["Blog"],"content":"Blog经历 从2014年起，我的博客先后经历了博客第三方平台博客园，Wordpress，Django 框架自建， Tornado框架自建，Pelican 静态博客框架及现在使用的Hexo静态博客框架。 可谓是第三方，动静结合，都经历过了， 但最终还是被爆表的颜值主题和易用性强大的Hexo所深深折服 ，Hexo真香ヾ(o◕∀◕)ﾉヾ！ ","date":"2019-11-22","objectID":"/20191122-%E4%BD%BF%E7%94%A8hexo%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%AB%99/:1:0","tags":["Hexo"],"title":"使用Hexo构建静态博客站","uri":"/20191122-%E4%BD%BF%E7%94%A8hexo%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%AB%99/"},{"categories":["Blog"],"content":"博客框架特点： 框架 开发语言 类型 特点 Wordpress PHP 动态博客 功能插件完备，拿来就用 Django Python 动态博客 模块完备，开发速度快 Tornado Python 动态博客 小巧玲珑，支持系统级异步并发 Pelican Python 静态博客 简洁，纯粹 Hexo Node.js 静态博客 美，易用 ","date":"2019-11-22","objectID":"/20191122-%E4%BD%BF%E7%94%A8hexo%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%AB%99/:1:1","tags":["Hexo"],"title":"使用Hexo构建静态博客站","uri":"/20191122-%E4%BD%BF%E7%94%A8hexo%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%AB%99/"},{"categories":["Blog"],"content":"Hero安装简述 首先安装Node.js, 然后安装hexo-cli: npm install hexo-cli -g hexo init myblog cd myblog # 预览 hexo server 默认主题模板是landscape， 这里推荐国人设计开发的melody, 文档完备，通俗易懂，非常棒！ npm i hexo-wordcount --save npm install hexo-tag-aplayer npm install hexo-tag-dplayer ","date":"2019-11-22","objectID":"/20191122-%E4%BD%BF%E7%94%A8hexo%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%AB%99/:2:0","tags":["Hexo"],"title":"使用Hexo构建静态博客站","uri":"/20191122-%E4%BD%BF%E7%94%A8hexo%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%AB%99/"},{"categories":["Linux","Python"],"content":"下载 # 下载源码包至`opt`目录 wget -c -P /opt https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tar.xz # 解压解包 tar - xvf Python-3.8.0.tar.xz cd Python-3.8.0 ","date":"2019-11-18","objectID":"/20191118-ubuntu18-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85python3-8/:1:0","tags":["python"],"title":"ubuntu18.04编译安装python3.8","uri":"/20191118-ubuntu18-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85python3-8/"},{"categories":["Linux","Python"],"content":"编译安装 # 更新系统 apt-get update apt-get upgrade apt-get dist-upgrade # 安装依赖库 apt-get install libbz2-dev libncurses5-dev libgdbm-dev libgdbm-compat-dev liblzma-dev libsqlite3-dev libssl-dev openssl tk-dev uuid-dev libreadline-dev python-dev ./configure --enable-optimizations --enable-shared make -j8 make altinstall ","date":"2019-11-18","objectID":"/20191118-ubuntu18-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85python3-8/:2:0","tags":["python"],"title":"ubuntu18.04编译安装python3.8","uri":"/20191118-ubuntu18-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85python3-8/"},{"categories":["Linux","Python"],"content":"运行测试 python3.8 # python3.8: error while loading shared libraries: libpython3.8.so.1.0: cannot open shared object file: No such file or directory 配置动态链接库路径 vim ~/.profile # 追加 export LD_LIBRARY_PATH=\"/usr/local/lib\" alias python=\"/usr/local/bin/python3.8\" alias python3.8=\"/usr/local/bin/python3.8\" # 更新 source ~/.profile 再次测试成功！ ","date":"2019-11-18","objectID":"/20191118-ubuntu18-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85python3-8/:3:0","tags":["python"],"title":"ubuntu18.04编译安装python3.8","uri":"/20191118-ubuntu18-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85python3-8/"},{"categories":["生活"],"content":"配置明细： 组件 选型 选型分析 价格 CPU 盒装AMD Ryzen 7 3700X 4.4GHz Max Boost, 3.6GGz Base 7nm 8核16线程65w,性能强劲，性价比高 2660.15（含主板） 主板 MSI B450M PRO-VDH MAX 集成声卡/网卡，最大内存容量64GB， 有较大扩展性 内存 金士顿HX430C5PB3/16 SP 549 显卡 盈通 RX550 2G 369 SSD Samsung SSD 970 EVO Plus 250G 用做系统盘，秒启的秘密 422.82 硬盘 WD 蓝盘 20EZAZ RZ 2T 数据盘 340.03 电源 先马金牌500W全模组 338 机箱 爱国者YOGO M2 白色机箱很好看ヾ(o◕∀◕)ﾉヾ 165.62 4844.62 ","date":"2019-11-17","objectID":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/:1:0","tags":["攒机","硬件","数码"],"title":"第一次攒机记录-1-基本配置","uri":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/"},{"categories":["生活"],"content":"CPU参数 lscpu 架构： x86_64 CPU 运行模式： 32-bit, 64-bit 字节序： Little Endian CPU: 16 在线 CPU 列表： 0-15 每个核的线程数： 2 每个座的核数： 8 座： 1 NUMA 节点： 1 厂商 ID： AuthenticAMD CPU 系列： 23 型号： 113 型号名称： AMD Ryzen 7 3700X 8-Core Processor 步进： 0 CPU MHz： 2199.572 CPU 最大 MHz： 3600.0000 CPU 最小 MHz： 2200.0000 BogoMIPS： 7200.06 虚拟化： AMD-V L1d 缓存： 32K L1i 缓存： 32K L2 缓存： 512K L3 缓存： 16384K NUMA 节点0 CPU： 0-15 标记： fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid extd_apicid aperfmperf pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate sme ssbd mba sev ibpb stibp vmmcall fsgsbase bmi1 avx2 smep bmi2 cqm rdt_a rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local clzero irperf xsaveerptr wbnoinvd arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif umip rdpid overflow_recov succor smca ","date":"2019-11-17","objectID":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/:1:1","tags":["攒机","硬件","数码"],"title":"第一次攒机记录-1-基本配置","uri":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/"},{"categories":["生活"],"content":"内存 ","date":"2019-11-17","objectID":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/:1:2","tags":["攒机","硬件","数码"],"title":"第一次攒机记录-1-基本配置","uri":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/"},{"categories":["生活"],"content":"主板 ","date":"2019-11-17","objectID":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/:1:3","tags":["攒机","硬件","数码"],"title":"第一次攒机记录-1-基本配置","uri":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/"},{"categories":["生活"],"content":"SSD 术语解析： NVM Express （Non-Volatile Memory express， NVMe）非易失性内存主机控制器接口规范是一个逻辑设备接口规范， 用于访问通过PCI-Express（PCIe）总线附加的非易失性内存介质。 此规范目的在于充分利用PCI-E通道的低延时以及并行性，还有当代处理器、平台与应用的并行性，在可控制的存储成本下，极大的提升固态硬盘的读写性能，降低由于AHCI接口带来的高延时，彻底解放SATA时代固态硬盘的极致性能。 PCIe: PCI-Express, 高速串行计算机扩展总线标准。 使用hdparm初步测试硬盘性能 apt-get install hdparm // 使用 fdisk -l 查看设备信息 /dev/nvme0n1p2 /dev/sda2 // 测试SSD读取效率 hdparm -tT /dev/nvme0n1p2 Timing cached reads: 23364 MB in 2.00 seconds = 11693.62 MB/sec Timing buffered disk reads: 8170 MB in 3.00 seconds = 2723.12 MB/sec // 测试机械硬盘读取效率 hdparm -tT /dev/sda2 Timing cached reads: 23728 MB in 2.00 seconds = 11875.69 MB/sec Timing buffered disk reads: 462 MB in 3.01 seconds = 153.42 MB/sec ","date":"2019-11-17","objectID":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/:1:4","tags":["攒机","硬件","数码"],"title":"第一次攒机记录-1-基本配置","uri":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/"},{"categories":["生活"],"content":"显卡 ","date":"2019-11-17","objectID":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/:1:5","tags":["攒机","硬件","数码"],"title":"第一次攒机记录-1-基本配置","uri":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/"},{"categories":["生活"],"content":"电源 ","date":"2019-11-17","objectID":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/:1:6","tags":["攒机","硬件","数码"],"title":"第一次攒机记录-1-基本配置","uri":"/20191117-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%92%E6%9C%BA%E8%AE%B0%E5%BD%95/"},{"categories":["基础设施"],"content":"docker info - 查看系统(docker)层面信息 docker images - 查看镜像信息 ","date":"2019-10-07","objectID":"/20191007-docker%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/:0:1","tags":["Docker"],"title":"Docker笔记-基础操作","uri":"/20191007-docker%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"},{"categories":["基础设施"],"content":"Docker 能做什么，与虚拟机区别： 与虚拟机区别， 每个虚拟机是一个操作系统。docker 是操作系统上的应用。 环境打包成镜像，自动化运行容器，打包部署自动化。 创建轻量，私密的PAAS环境。 实现自动化测试和持续的集成/部署。 部署与扩展webapp,数据库和后台服务。 完全沙箱机制。 项目 传统虚拟机 Docker虚拟机 占用空间 大 小 启动速度 慢 快 资源利用率 低 高 运行基础 Hypervisor CPU虚拟化技术 Linux内核虚拟化 部署 复杂 方便 隔离 操作系统级别 容器级别 基于namespace隔离 相互通信 简单造作系统间通信 复杂 容器间通信 ","date":"2019-10-06","objectID":"/20191006-docker%E7%AC%94%E8%AE%B0-%E4%BB%8B%E7%BB%8D/:1:0","tags":["Docker"],"title":"Docker笔记-介绍","uri":"/20191006-docker%E7%AC%94%E8%AE%B0-%E4%BB%8B%E7%BB%8D/"},{"categories":["基础设施"],"content":"Docker组成： Docker Client 客户端：通过API访问Docker Daemon 管理Docker镜像。 Docker Daemon 守护进程：负责Docker镜像的创建，删除，启动，停止等服务。 Docker Image镜像：“只读”系统。 Docker Container 容器 Docker images的仓库 Docker Hub dockerhub.com ","date":"2019-10-06","objectID":"/20191006-docker%E7%AC%94%E8%AE%B0-%E4%BB%8B%E7%BB%8D/:2:0","tags":["Docker"],"title":"Docker笔记-介绍","uri":"/20191006-docker%E7%AC%94%E8%AE%B0-%E4%BB%8B%E7%BB%8D/"},{"categories":["基础设施"],"content":"基础概念 镜像（Image）: 特殊文件系统，除了提供容器运行时所需的程序，库，资源，配置文件外，还包含配置参数（匿名卷，环境变量，用户等）。不包含然和动态数据。构建之后也不会改变。 镜像构建时，会一层层构建，前一层是后一层基础。 容器（Container）: 镜像运行的实体，可以被创建，停止，访问，删除等。 仓库（Repository）： 每个仓库可包含多个标签（Tag）:每个标签对应一个镜像。 Docker Registry： Docker Registry 中可以包含多个 仓库（Repository）, 如 Docker Hub 容器存储层需要保持无状态变化， 写入的数据应使用数据卷（Volume） 或 绑定系统目录。 ","date":"2019-10-06","objectID":"/20191006-docker%E7%AC%94%E8%AE%B0-%E4%BB%8B%E7%BB%8D/:3:0","tags":["Docker"],"title":"Docker笔记-介绍","uri":"/20191006-docker%E7%AC%94%E8%AE%B0-%E4%BB%8B%E7%BB%8D/"},{"categories":["基础设施"],"content":"dcoker Install ","date":"2019-10-05","objectID":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:1:0","tags":["Docker"],"title":"Docker笔记-安装配置","uri":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["基础设施"],"content":"ubuntu 安装文档 Uninstall old versions sudo apt-get remove docker docker-engine docker.io containerd runc Install using the repository sudo apt-get update sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo apt-key fingerprint 0EBFCD88 sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" INSTALL DOCKER ENGINE sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io Verify sudo docker run hello-world 将登陆用户添加到docker用户组 sudo gpasswd -a $USER docker newgrp docker docker ps ","date":"2019-10-05","objectID":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:1:1","tags":["Docker"],"title":"Docker笔记-安装配置","uri":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["基础设施"],"content":"CentOS Uninstall old versions sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine INSTALL DOCKER ENGINE sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io 将非root登陆用户添加到docker用户组 sudo gpasswd -a $USER docker newgrp docker docker ps ","date":"2019-10-05","objectID":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:1:2","tags":["Docker"],"title":"Docker笔记-安装配置","uri":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["基础设施"],"content":"配置 ","date":"2019-10-05","objectID":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:0","tags":["Docker"],"title":"Docker笔记-安装配置","uri":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["基础设施"],"content":"docker镜像加速 /etc/docker/daemon.json（Linux） { \"registry-mirrors\": [\"https://registry.docker-cn.com\", \"https://docker.mirrors.ustc.edu.cn\"] } sudo systemctl restart docker 重启生效 ","date":"2019-10-05","objectID":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:1","tags":["Docker"],"title":"Docker笔记-安装配置","uri":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["基础设施"],"content":"增加到随机启动项 systemctl enbale docker ","date":"2019-10-05","objectID":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:2","tags":["Docker"],"title":"Docker笔记-安装配置","uri":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["基础设施"],"content":"启动docker service docker start ","date":"2019-10-05","objectID":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:3","tags":["Docker"],"title":"Docker笔记-安装配置","uri":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["基础设施"],"content":"docker GUI kitematic portainer 轻量级的Docker管理面板 docker pull portainer/portainer docker run -p 9000:9000 -p 8000:8000 --name portainer \\ --restart=always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /mydata/portainer/data:/data \\ -d portainer/portainer ","date":"2019-10-05","objectID":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:4","tags":["Docker"],"title":"Docker笔记-安装配置","uri":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["基础设施"],"content":"安装docker-compose pip3 install docker-compose ","date":"2019-10-05","objectID":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:5","tags":["Docker"],"title":"Docker笔记-安装配置","uri":"/20191005-docker%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["Linux"],"content":" 新增1T磁盘一块 使用df -h查看当前硬盘信息（并未出现要挂在的磁盘） 文件系统 容量 已用 可用 已用% 挂载点 /dev/vda1 50G 5.0G 42G 11% / devtmpfs 1.9G 0 1.9G 0% /dev tmpfs 1.9G 0 1.9G 0% /dev/shm tmpfs 1.9G 208M 1.7G 11% /run tmpfs 1.9G 0 1.9G 0% /sys/fs/cgroup tmpfs 383M 0 383M 0% /run/user/0 使用命令fdisk -l查看所有磁盘信息（包括未挂载磁盘） 磁盘 /dev/vda：53.7 GB, 53687091200 字节，104857600 个扇区 Units = 扇区 of 1 * 512 = 512 bytes 扇区大小(逻辑/物理)：512 字节 / 512 字节 I/O 大小(最小/最佳)：512 字节 / 512 字节 磁盘标签类型：dos 磁盘标识符：0x000c4895 设备 Boot Start End Blocks Id System /dev/vda1 * 2048 104857599 52427776 83 Linux 磁盘 /dev/vdb：1099.5 GB, 1099511627776 字节，2147483648 个扇区 Units = 扇区 of 1 * 512 = 512 bytes 扇区大小(逻辑/物理)：512 字节 / 512 字节 I/O 大小(最小/最佳)：512 字节 / 512 字节 磁盘 /dev/vdb 为需要挂载的磁盘。 2. 通过lsblk查看 NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 253:0 0 50G 0 disk └─vda1 253:1 0 50G 0 part / vdb 253:16 0 1T 0 disk 使用fdisk工具分区（当硬盘小于等于2T时，用fdisk，大于2T时，用parted） 键入：fdisk /dev/vdb出现欢迎信息 然后键入n新建分区 欢迎使用 fdisk (util-linux 2.23.2)。 更改将停留在内存中，直到您决定将更改写入磁盘。 使用写入命令前请三思。 Device does not contain a recognized partition table 使用磁盘标识符 0x3561697b 创建新的 DOS 磁盘标签。 命令(输入 m 获取帮助)：n Partition type: p primary (0 primary, 0 extended, 4 free) e extended p建立主分区， e建立扩展分区 我们建立主分区，分区号，起始及结束扇区选择默认值： Select (default p): p 分区号 (1-4，默认 1)：1 起始 扇区 (2048-2147483647，默认为 2048)： 将使用默认值 2048 Last 扇区, +扇区 or +size{K,M,G} (2048-2147483647，默认为 2147483647)： 将使用默认值 2147483647 分区 1 已设置为 Linux 类型，大小设为 1024 GiB 键入w写入分区并退出 命令(输入 m 获取帮助)：w The partition table has been altered! Calling ioctl() to re-read partition table. 正在同步磁盘。 再次使用lsblk查看 [root@main ~]# partprobe /dev/vdb [root@main ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 253:0 0 50G 0 disk └─vda1 253:1 0 50G 0 part / vdb 253:16 0 1T 0 disk └─vdb1 253:17 0 1024G 0 part 格式化为ext4文件系统 mkfs.ext4 /dev/vdb1 mke2fs 1.42.9 (28-Dec-2013) 文件系统标签= OS type: Linux 块大小=4096 (log=2) 分块大小=4096 (log=2) Stride=0 blocks, Stripe width=0 blocks 67108864 inodes, 268435200 blocks 13421760 blocks (5.00%) reserved for the super user 第一个数据块=0 Maximum filesystem blocks=2415919104 8192 block groups 32768 blocks per group, 32768 fragments per group 8192 inodes per group Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968, 102400000, 214990848 Allocating group tables: 完成 正在写入inode表: 完成 Creating journal (32768 blocks): 完成 Writing superblocks and filesystem accounting information: 完成 使用mount临时挂载磁盘至**/mnt**目录 mount /dev/vdb1 /mnt vim /etc/fstab更改配置文件永久挂载 追加 /dev/vdb1 /data ext4 defaults 0 0 使用 mount -a 判断加载是否正确 参考教程 Linux检查未挂载磁盘和为磁盘分区、挂载 ","date":"2019-09-23","objectID":"/20190926-linux%E7%A3%81%E7%9B%98%E6%A3%80%E6%B5%8B%E5%88%86%E5%8C%BA%E4%B8%8E%E6%8C%82%E8%BD%BD/:0:0","tags":["fdisk","lsblk","mount"],"title":"Linux磁盘检测，分区与挂载","uri":"/20190926-linux%E7%A3%81%E7%9B%98%E6%A3%80%E6%B5%8B%E5%88%86%E5%8C%BA%E4%B8%8E%E6%8C%82%E8%BD%BD/"},{"categories":["网络"],"content":"有多个域名: dog.aimiter.com cat .aimiter.com … 需要映射到不同的静态资源目录: /var/www/html/dog /var/www/html/cat 配置如下: 分别建立nginx配置 dog.conf, cat.conf. 然后只需设置静态资源目录root 和 域名地址server_name即可. ","date":"2019-09-23","objectID":"/20190923-nginx%E4%B8%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/:0:0","tags":["Nginx"],"title":"Nginx为多个不同的静态资源配置不同的二级域名","uri":"/20190923-nginx%E4%B8%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/"},{"categories":["网络"],"content":"本地8081 端口有某web应用, 但只开放了80端口, 有该ip域名一枚 pet.aimiter.com, 要通过域名pet.aimiter.com 访问本地8081端口的应用. 创建 配置文件: sudo cp default pet.conf, 然后更改server_name 和 proxy_pass即可. ","date":"2019-09-23","objectID":"/20190923-nginx%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%BA%94%E7%9A%84%E5%9F%9F%E5%90%8D/:0:0","tags":["Nginx"],"title":"Nginx使用反向代理为不同的端口应用配置相应的域名","uri":"/20190923-nginx%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%BA%94%E7%9A%84%E5%9F%9F%E5%90%8D/"},{"categories":["网络"],"content":"配置示例 server { listen 443 ssl; server_name wxapi.aimiter.com; root html; index index.html index.htm; ssl_certificate /etc/nginx/conf.d/cert.pem; ssl_certificate_key /etc/nginx/conf.d/cert.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_prefer_server_ciphers on; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { # resolver 127.0.0.1; proxy_pass http://127.0.0.1:8080; #root /usr/share/nginx/html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } ","date":"2019-09-23","objectID":"/20190923-nginx%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6/:0:1","tags":["Nginx"],"title":"Nginx配置SSL证书","uri":"/20190923-nginx%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6/"},{"categories":["生活"],"content":"功能一瞥 ","date":"2019-08-08","objectID":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/:1:0","tags":["个人项目","robot","itchat"],"title":"使用itchat开发微信群聊机器人","uri":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/"},{"categories":["生活"],"content":"命令菜单 ","date":"2019-08-08","objectID":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/:1:1","tags":["个人项目","robot","itchat"],"title":"使用itchat开发微信群聊机器人","uri":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/"},{"categories":["生活"],"content":"名言与笑话 ","date":"2019-08-08","objectID":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/:1:2","tags":["个人项目","robot","itchat"],"title":"使用itchat开发微信群聊机器人","uri":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/"},{"categories":["生活"],"content":"宋代诗词 ","date":"2019-08-08","objectID":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/:1:3","tags":["个人项目","robot","itchat"],"title":"使用itchat开发微信群聊机器人","uri":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/"},{"categories":["生活"],"content":"天气预报（精确到市区，高德地图api） ","date":"2019-08-08","objectID":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/:1:4","tags":["个人项目","robot","itchat"],"title":"使用itchat开发微信群聊机器人","uri":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/"},{"categories":["生活"],"content":"看图猜成语 ","date":"2019-08-08","objectID":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/:1:5","tags":["个人项目","robot","itchat"],"title":"使用itchat开发微信群聊机器人","uri":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/"},{"categories":["生活"],"content":"猜谜语 ","date":"2019-08-08","objectID":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/:1:6","tags":["个人项目","robot","itchat"],"title":"使用itchat开发微信群聊机器人","uri":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/"},{"categories":["生活"],"content":"其它 生日提醒 备忘提醒 闲聊对话（图灵机器人api） 更多功能完善中，暂不开源。 ","date":"2019-08-08","objectID":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/:1:7","tags":["个人项目","robot","itchat"],"title":"使用itchat开发微信群聊机器人","uri":"/20190808-%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/"},{"categories":["网络"],"content":"主机记录 域名前缀 ","date":"2019-06-25","objectID":"/20190625-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9F%A5%E8%AF%86/:1:0","tags":["域名"],"title":"域名解析知识","uri":"/20190625-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9F%A5%E8%AF%86/"},{"categories":["网络"],"content":"记录类型 类型 说明 A 将域名指向一个IPV4地址 CNAME 将域名指向另一个域名 AAAA 将域名指向一个IPV6地址 NS 将子域名指定其他DNS服务器解析 MX 将域名指向邮件服务器地址 SRV 记录提供特定的服务的服务器 TXT 文本长度限制512，通常做SPF记录（反垃圾邮件） CAA CA证书办法机构授权校验 ","date":"2019-06-25","objectID":"/20190625-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9F%A5%E8%AF%86/:2:0","tags":["域名"],"title":"域名解析知识","uri":"/20190625-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9F%A5%E8%AF%86/"},{"categories":["网络"],"content":"解析线路(isp) ","date":"2019-06-25","objectID":"/20190625-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9F%A5%E8%AF%86/:3:0","tags":["域名"],"title":"域名解析知识","uri":"/20190625-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9F%A5%E8%AF%86/"},{"categories":["网络"],"content":"记录值 服务器IP ","date":"2019-06-25","objectID":"/20190625-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9F%A5%E8%AF%86/:4:0","tags":["域名"],"title":"域名解析知识","uri":"/20190625-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9F%A5%E8%AF%86/"},{"categories":["网络"],"content":"TTL Time To Live，缓存的生存时间。指地方dns缓存您域名记录信息的时间。 600（10分钟）：建议正常情况下使用 600。 60（1分钟）：如果您经常修改IP，修改记录一分钟即可生效。长期使用 60，解析速度会略受影响。 3600（1小时）：如果您IP极少变动（一年几次），建议选择 3600，解析速度快。如果要修改IP，提前一天改为 60，即可快速生效。 ","date":"2019-06-25","objectID":"/20190625-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9F%A5%E8%AF%86/:5:0","tags":["域名"],"title":"域名解析知识","uri":"/20190625-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":" 数据结构 数组 Array 栈 Stack 队列 Queue 优先队列（Priority Queue, heap） 链表 LinkedList(single/double) Tree/ Binary Tree Binary Search Tree HashTable Disjoint Set Trie BloomFliter LRU Cache 算法分类 线性结构 莫队 (Mo’s Algorithm) 前缀和 基本数组 向量 链接表（linked list） 栈(stack) 队列 块状链表,块状数组,分块 st表, 稀疏表 差分 树形结构 线段树 二维线段树 矩形树 zkw线段树 主席树 点分治 平衡树 AVL Treap SBT Splay 静态排序树 替罪羊树 二叉堆（binary heap） 左偏树 斜堆 二项堆 树状数组 cdp分治 树上距离 节点到根的距离 最近公共祖先,LCA 节点间距离 树的直径 动态树 树链部分,树剖 Link-Cut Tree,LCT 树的应用 并查集 (Disjoint set) 树的遍历 哈夫曼树 RMQ 树套树 可持久化 虚树 整体二分 环套树 K-D Tree 字符串 后缀自动机,SAM 字典树, Trie树 AC自动机 KMP 后缀数组,SA 后缀树 有限状态自动机 哈夫曼, Huffman 简单密码学 回文自动机PAM Manacher算法 排序 冒泡排序 选择排序 桶排 插入排序 归并 快速排序,快排 堆排序 希尔排序 外部排序 查找 二分答案 顺序查找 二分查找 二分图 最大匹配 匈牙利算法 一般图的最大匹配 Konig定理 带权二分图匹配 稳定婚姻系统 搜索 广度优先搜索, BFS 深度优先搜索, DFS 剪枝 记忆化搜索 启发式搜索 启发式迭代加深, IDA* Dancing Links 爬山法 模拟退火 遗传 A*算法 迭代加深 随机调整 网络流 最大流 Dinic Sap 有上下界的最大流 最小割 闭合图 最小点权覆盖集 最大点权覆盖集 分数规划 最大密度子图 费用流 最短路增广费用流 zkw费用流 最小费用可行流 基础算法 模拟 贪心(Greedy) 递推 递归（backtrace） 枚举, 暴力 分治（Divide and conquer） 动态规划(Dynamic Programming) 动态规划初步 背包 环形动规,环形dp 数位动规,数位dp 多维状态 区间动归,区间dp 字母树 动态规划优化 单调队列 降低维度,降维 优先队列(Priority Queue) 矩阵加速,矩阵优化 斜率优化 状态压缩,状压 凸完全单调性,凸单调 四边形不等式 树形动归 插头dp 其它技巧 暴力数据结构 高精 博弈论 Nim游戏 博弈树 Shannon开关游戏 倍增 离散化 哈希,Hash ELFhash SDBM BKDR 随机贪心, 随机化 快速傅立叶变换,DFT,FFT 位运算,按位 骗分 NP问题 构造 快速数论变换NTT 快速沃尔什变换FWT 数论,数学 整数研究 素数判断, 质数, 筛法 最大公约数, gcd 扩展欧几里得, 扩欧 不定方程 进制 同余,中国剩余定理 莫比乌斯反演 逆元 集合论 群论 置换 Polya原理 组合数学 排列组合 二项式定理 康托展开 袋与球问题 鸽笼 熔斥 斐波那契,Fibonacci 卡特兰,Catalan Stirling 生成函数 卢卡斯,Lucas 线性规划 概率论,统计 众数 简单概率 条件概率 Bayes 期望 线性代数 矩阵运算 矩阵乘法 线性递推,递推式 高斯消元 异或方程组 线基性 微积分初步 极限 导数 积分 定积分 立体解析几何 级数 图论 图遍历 拓扑排序 AOV AOE 最短路 Floyd Dijkstra Bellman-Ford SPFA 差分约束 K短路 生成树 Prim Kruskal 生成树的另类算法 次小生成树 特殊生成树 圈和块 最小环 负权环 连通块 2-SAT 欧拉公式 四色定理 欧拉环路 强连通分量,缩点 Tarjan 割点 仙人掌 计算几何 凸包 叉积 线段相交 点积 半平面相交,半平面交 最近点对 凸多边形的交 离散化扫描 旋转卡壳 ","date":"2019-06-19","objectID":"/20190619-%E7%AE%97%E6%B3%95%E6%A0%87%E7%AD%BE/:0:0","tags":["算法"],"title":"算法标签","uri":"/20190619-%E7%AE%97%E6%B3%95%E6%A0%87%E7%AD%BE/"},{"categories":["软件工程"],"content":"create a new repository on the command line git init git add README.md git commit -m \"first commit\" git remote add origin git@github.com:user/project_name.git git push -u origin master ","date":"2019-06-13","objectID":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","tags":["git"],"title":"Git常用命令","uri":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["软件工程"],"content":"push an existing repository from the command line git remote add origin git@github.com:user/project_name.git git push -u origin master ","date":"2019-06-13","objectID":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","tags":["git"],"title":"Git常用命令","uri":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["软件工程"],"content":"tag # 查看 git tag # 在某个 commit 打 tag git tag tag_name commit_id # 本地 tag 推到线上 git push origin tag_name # 删除本地 tag git tag -d tag_name # 删除本地，然后删除线上tag git push origin :refs/tags/tag_name # 添加tag 并推送到远程 git tag tag_name -m \"tag_msg\" git push origin tag_name ","date":"2019-06-13","objectID":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:3","tags":["git"],"title":"Git常用命令","uri":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["软件工程"],"content":"commit # 统计提交次数 git log | grep \"^Author: Spaceack\"|wc -l # 统计合并次数 git log | grep \"^Merge\" | wc -l # 修改当前分支最新的一次提交。commit的 hash 不变. 避免有多个commit的情况。 git commit --amend ","date":"2019-06-13","objectID":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:4","tags":["git"],"title":"Git常用命令","uri":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["软件工程"],"content":"revert git revert -n commit-id ","date":"2019-06-13","objectID":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:5","tags":["git"],"title":"Git常用命令","uri":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["软件工程"],"content":"cherry-pick git cherry-pick commit-id ","date":"2019-06-13","objectID":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:6","tags":["git"],"title":"Git常用命令","uri":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["软件工程"],"content":"git log 使用 pretty 格式化参数获取更详细的信息 git log --pretty=\"%h %p %t %cn %an %s \" 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 ","date":"2019-06-13","objectID":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:7","tags":["git"],"title":"Git常用命令","uri":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["软件工程"],"content":"git config git config --global user.name \"spaceack\" git config --global user.email \"spaceack@qq.com\" 忽略文件权限的变更 git config core.filemode false //当前版本库 git config --global core.filemode false //全局 ","date":"2019-06-13","objectID":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:8","tags":["git"],"title":"Git常用命令","uri":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["软件工程"],"content":"proxy 设置HTTP代理 git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2019-06-13","objectID":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:9","tags":["git"],"title":"Git常用命令","uri":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["软件工程"],"content":"submodule 项目不完整， submodule 目录为空 # 进入到 submodule 目录 git submodule update --init --recursive ","date":"2019-06-13","objectID":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:10","tags":["git"],"title":"Git常用命令","uri":"/20190613-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"提取mp4中的音频另存为mp3 ffmpeg -i foo.mp4 bar.mp3 ","date":"2019-06-09","objectID":"/20190609-%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E4%B8%8E%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:0:1","tags":["ffmpeg"],"title":"多媒体处理与格式转换","uri":"/20190609-%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E4%B8%8E%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["Python"],"content":"没有什么编码是不能转的 import hashlib import base64 # string to md5 input_text = \"我能吞下玻璃而不伤身体\" md5_string = hashlib.md5(input_text.encode(encoding='utf8')).hexdigest() # 2e536f0d3a95e676e30afb2b511c6fe2 # string to base64 base64_string = base64.b64encode(input_text.encode('utf-8')).decode('utf-8') # 5oiR6IO95ZCe5LiL546755KD6ICM5LiN5Lyk6Lqr5L2T # base64 to string output_text = base64.b64decode(base64_string).decode(encoding='utf8') # 我能吞下玻璃而不伤身体 # URL Decode quote/unquote import urllib.parse result = urllib.parse.unquote(\"%E6%88%91%E8%83%BD%E5%90%9E%E4%B8%8B%E7%8E%BB%E7%92%83%E8%80%8C%E4%B8%8D%E4%BC%A4%E8%BA%AB%E4%BD%93\") # 我能吞下玻璃而不伤身体 result = urllib.parse.quote(input_text) #%E6%88%91%E8%83%BD%E5%90%9E%E4%B8%8B%E7%8E%BB%E7%92%83%E8%80%8C%E4%B8%8D%E4%BC%A4%E8%BA%AB%E4%BD%93 # string to hex bytes_string = input_text.encode() bytes_string = b'\\xe6\\x88\\x91\\xe8\\x83\\xbd\\xe5\\x90\\x9e\\xe4\\xb8\\x8b\\xe7\\x8e\\xbb\\xe7\\x92\\x83\\xe8\\x80\\x8c\\xe4\\xb8\\x8d\\xe4\\xbc\\xa4\\xe8\\xba\\xab\\xe4\\xbd\\x93' hex_str = bytes_string.hex() # e68891e883bde5909ee4b88be78ebbe79283e8808ce4b88de4bca4e8baabe4bd93 # hex to string text = bytes.fromhex(hex_str).decode() # 我能吞下玻璃而不伤身体 ","date":"2019-06-08","objectID":"/20190608-python3%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/:0:0","tags":["编码","python"],"title":"Python3编码转换","uri":"/20190608-python3%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/"},{"categories":["Python"],"content":"ipv4字符串与数字转换 import socket import struct ip = '127.0.0.1' int_ip = struct.unpack('!I', socket.inet_aton(ip))[0] print(int_ip) str_ip = socket.inet_ntoa(struct.pack('!I', int_ip)) print(str_ip) ","date":"2019-06-08","objectID":"/20190608-python3%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/:0:1","tags":["编码","python"],"title":"Python3编码转换","uri":"/20190608-python3%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/"},{"categories":["Python"],"content":"发送POST请求，内容为json格式。并忽略证书验证。 import json import urllib3 urllib3.disable_warnings() # 屏蔽警告忽略证书的警告。 # cert_reqs='CERT_NONE' 忽略https证书验证 http = urllib3.PoolManager(cert_reqs='CERT_NONE') encode_data = json.dumps({\"name\":\"spaceack\"}).encode(\"utf-8\") url = \"https://127.0.0.1:5000/api/v1/hello\" req = http.request('POST', url=url, body=encode_data, headers={'Content-Type': 'application/json'}, timeout=10, ) result = req.data.decode('utf-8') # 获取响应的数据。 ","date":"2019-06-07","objectID":"/urllib3/:0:1","tags":["python","urllib3"],"title":"Python urllib3","uri":"/urllib3/"},{"categories":["Python"],"content":"字典 ","date":"2019-06-07","objectID":"/20190607-python%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/:1:0","tags":["python"],"title":"Python基础操作","uri":"/20190607-python%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"合并两个字典 merge two dictionaries dict1 = {'a': 1, 'b': 2} dict2 = {'c': 3, 'd': 4} dict3 = {**dict1, **dict2} # python3.5+ 写法 dict3 = dict(dict1, **dict2) # python3.5- 写法 print(dict3) ","date":"2019-06-07","objectID":"/20190607-python%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/:1:1","tags":["python"],"title":"Python基础操作","uri":"/20190607-python%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"字典按值排序 sort a Python dict by value xs = {'a': 4, 'b': 3, 'c': 2, 'd': 1} for k, v in sorted(xs.items(), key=lambda x: x[1]): print(k, v) import operator xs = {'a': 4, 'b': 3, 'c': 2, 'd': 1} for k, v in sorted(xs.items(), key=operator.itemgetter(1)): print(k, v) ","date":"2019-06-07","objectID":"/20190607-python%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/:1:2","tags":["python"],"title":"Python基础操作","uri":"/20190607-python%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"},{"categories":["生活"],"content":"四月的风，撩乱倒映水中白云的心。 迁徙的鸟，勾起岸旁垂杨柳的思恋。 迷乱的花，怎能敌四季长青的松乔。 暮霭晨雾，是否也是春姑娘的话语。 ","date":"2019-04-06","objectID":"/20190406-%E6%98%A5%E8%AF%AD/:0:0","tags":["poem","情感","love"],"title":"春语","uri":"/20190406-%E6%98%A5%E8%AF%AD/"},{"categories":["数据库"],"content":" import pymongo myclient = pymongo.MongoClient(host=\"localhost\", port=27017) mydb = myclient.database_name collection_obj = mydb.collection_name # upsert 是否插入新数据，如果不存在则插入，存在则更新 collection_obj.update_one({\"id\": \"1\"}, {\"$set\": {\"id\": \"1\", \"age\": 18}}, upsert=True) ","date":"2018-11-08","objectID":"/20181107-mongodb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["MongoDB"],"title":"MongoDB常用操作命令","uri":"/20181107-mongodb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["数据库"],"content":"统计 collection信息 db.getCollection('collection_name').stats() ","date":"2018-11-08","objectID":"/20181107-mongodb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","tags":["MongoDB"],"title":"MongoDB常用操作命令","uri":"/20181107-mongodb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["RCA"],"content":"问题现象 程序崩溃，提示MongoDB写入失败，无法再连起。 ","date":"2018-11-07","objectID":"/20181107-rca-mongodb%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%A4%B1%E8%B4%A5/:1:0","tags":["MongoDB"],"title":"RCA-MongoDB数据写入失败","uri":"/20181107-rca-mongodb%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%A4%B1%E8%B4%A5/"},{"categories":["RCA"],"content":"分析原因 1.首先想到分析mongoDB日志记录 通过 cat /etc/mongod.conf 找到日志所在目录 /var/log/mongodb/mongod.log 2018-11-07T16:50:44.165+0800 W FTDC [ftdc] Uncaught exception in 'FileStreamFailed: Failed to write to interim file buffer for full-time diagnostic data capture: /var/lib/mongo/diagnostic.data/metrics.interim.temp' in full-time diagnostic data capture subsystem. Shutting down the full-time diagnostic data capture subsystem. 2018-11-07T16:51:30.913+0800 E STORAGE [WTCheckpointThread] WiredTiger error (28)：handle-write: pwrite: failed to write 4096 bytes at offset 1486848: No space left on device 2018-11-07T16:51:30.914+0800 E STORAGE [WTCheckpointThread] WiredTiger error (28): fatal checkpoint failure: No space left on device 2018-11-07T16:51:30.914+0800 E STORAGE [WTCheckpointThread] WiredTiger error (-31804) WT_SESSION.checkpoint: the process must exit and restart: WT 日志反馈的信息很明确，“磁盘已被写满啦！”， 但是很奇怪，写入量并不大，且只有唯一任务在执行，写满是不可能的。 可能想到的问题是蠕虫病毒，或是由程序递归，死循环等造成的错误数据写入。 2.那么现在的目标就是找到占用的文件，我现在希望这是一个大文件，若干个碎片文件查找起来会很痛苦（虽然也可通过写入时间搜索）。 幸好所在磁盘分区不大，首先进入数据目录所在分区根目录，查找大于100M的单文件 find . -type f -size +100M。很快定位到一个16G的日志文件!验证了之前的猜想。 3.为什么会形成如此大的日志文件？？？ 初步分析是由一个第三方库写入的。 ","date":"2018-11-07","objectID":"/20181107-rca-mongodb%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%A4%B1%E8%B4%A5/:2:0","tags":["MongoDB"],"title":"RCA-MongoDB数据写入失败","uri":"/20181107-rca-mongodb%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%A4%B1%E8%B4%A5/"},{"categories":["RCA"],"content":"解决方案 为了快速释放服务器资源并启动服务，初步方案是删除日志文件，注释掉日志记录代码，代码线下再做检查。 重启mongoDB, 服务恢复。 ","date":"2018-11-07","objectID":"/20181107-rca-mongodb%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%A4%B1%E8%B4%A5/:3:0","tags":["MongoDB"],"title":"RCA-MongoDB数据写入失败","uri":"/20181107-rca-mongodb%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%A4%B1%E8%B4%A5/"},{"categories":["RCA"],"content":"经验总结 虽然问题不复杂，也很快得以解决。但也有许多地方值得注意: 不要完全信任第三方库。尤其是很冷门的库。要做测试审查。 数据写入到系统分区，系统分区写满严重影响其它程序执行，数据写入，非常危险！。应保持系统分区独立性。所有数据写入包括日志文件应存入单独的数据盘。 系统负载报警机制也很重要，若线上同时有重要的实时任务运行，后果很严重。发现报警可以提前做处理，避免资源超载。 ","date":"2018-11-07","objectID":"/20181107-rca-mongodb%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%A4%B1%E8%B4%A5/:4:0","tags":["MongoDB"],"title":"RCA-MongoDB数据写入失败","uri":"/20181107-rca-mongodb%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%A4%B1%E8%B4%A5/"},{"categories":["生活"],"content":" 大学的时候，体育馆场上的街舞是如此的酷炫哇！但我只能眼巴巴地瞪着，羡慕得眼珠子都要掉下来。 舞蹈离我是如此的遥远！但当我邂逅Zumba舞时我为什么喜爱尊巴， 一下子拉近了我与舞蹈的距离。 ","date":"2018-07-28","objectID":"/20180728-%E8%88%9E%E8%B9%88%E9%9A%8F%E6%83%B3/:0:0","tags":["舞蹈","运动"],"title":"舞蹈随想","uri":"/20180728-%E8%88%9E%E8%B9%88%E9%9A%8F%E6%83%B3/"},{"categories":["生活"],"content":"为什么我们需要舞蹈？ 说起舞蹈(跳舞)的好处，人们首先会想到的是“健身”，“唯美的艺术”，“娱人娱己”，“使人更有自信”。 更概括的说是满足了我们在马斯洛需要层次论中自我实现（Self-actualization）的需求。 有什么比可以控制自己身体做到想要的动作更快乐的事呢？舞蹈中容易产生多次高峰经验，通俗讲就是\"很嗨\"，“忘我”。 舞蹈训练我们的模仿力：模仿力更确切的说是学习能力，婴儿一出生，便无时无刻在模仿，模仿动作, 模仿声音。 有一种论调说人在孩童时学习能力最强，学的最快。随着年龄增长学习能力逐渐下降，若我们能保持高效的模仿,那么便是抑制减缓衰老的一剂良药！ 许多舞蹈动作本身便是在模仿，或是模仿拉弓射箭，击鼓拍球，或是模仿水中捞月，蜻蜓点水。 模仿时，会出现2个分身，一个是作出动作的自己；另一个是作为第三人观察者的自己，观察领舞者的动作，并觉察自己的动作是否正确。 假使一个没有任何舞蹈基础的人模仿舞蹈动作很像，那么他的学习能力也不会差。 学习能力与专注度和记忆力 两者不分家，那么也可以说他有着很强的专注度和较好的记忆力。 舞蹈增强我们的应激力: 舞蹈中很多动作是急速转身，下蹲或跳跃。尤其是偏力量型的街舞。 以超越常人的速度和控制力做出一系列动作。 当危险来临时，可以更快的作出本能反应。关键时刻可以减轻甚至避免伤害，是可以救命的！ ","date":"2018-07-28","objectID":"/20180728-%E8%88%9E%E8%B9%88%E9%9A%8F%E6%83%B3/:0:1","tags":["舞蹈","运动"],"title":"舞蹈随想","uri":"/20180728-%E8%88%9E%E8%B9%88%E9%9A%8F%E6%83%B3/"},{"categories":["生活"],"content":"舞蹈与律动 每个舞蹈都会伴随一首动听的音乐，舞蹈的律动更多是指按照音乐节奏的舞动。我们所处的时空便是由律动所组成，律动无处不在。 不难发现“律动”一词可解释为“有规律的运动”。不动，便是涅槃寂静。但只动却没有规律，就像太阳一样内部一片混沌。 人的生命靠心脏脉搏的有序跳动。计算机程序本质由CPU时钟脉冲的滴答电平所驱动。那么舞蹈唯美的源泉便在于律动。 律动的成本：将无序的元素有序地排列便产生美。 但根据热率学第二定律，事物总朝向混沌无序的方向发展，除非有外部能量注入。那么可以说舞蹈是一项较高成本的艺术（大误）。 不像“音乐”，“绘画”等艺术，动动手指就能完成（当然过程也是艰辛）。而是要靠调动全身的机能感官，身体力行才能完成。 仅从“存储”一项便可知悉：音乐艺术的载体是乐谱;绘画艺术的载体是画纸，而舞蹈艺术的载体是实实在在的人。存储成本的高低高下立判！ 虽然现在数字媒体科技的发展，可以用视频录制保存。但视频文件的体量也是音频文件和图片文件的数百倍，这还是将三维压缩为二维的代价下! 这种压缩方式不是无损压缩，会丢失许多细节和感官的冲击，即失真。 即是如此，那么更加彰显片刻舞蹈的弥足珍贵! 多年后,曾经的动作或早已忘却,但当那重复多次而熟悉的音乐再次响起时,就会成为亲切的怀恋:) ","date":"2018-07-28","objectID":"/20180728-%E8%88%9E%E8%B9%88%E9%9A%8F%E6%83%B3/:0:2","tags":["舞蹈","运动"],"title":"舞蹈随想","uri":"/20180728-%E8%88%9E%E8%B9%88%E9%9A%8F%E6%83%B3/"},{"categories":["Linux"],"content":"Supervisor Docs 使用ssh远程维护VPS时候，要在后台挂起一个程序。挂起程序很简单，在command后加上**\u0026**符号就可以，但是当断开ssh时候，挂起的程序也随之killed, 很是恼火。在使用**nohup** 的时候意外发现了**supervisor**, **supervisor**使用python开发，通过配置文件来配置需要启动监管的程序，作为supervisord的子进程。执行程序**supervisord**即‘守护进程’（Daemon）[在希腊神话中是守护神的意思！类似中国的护法？**daemon**这个词和恶魔(demon)只差一个字母，且发音完全一样！多的a这个品质可理解为全神关注的(absorbed)/精确的(accurate)/能干的(able)/乐于助人的(accommodating)/友好的(amicable)]。类似**httpd**, **mysqld**最后的d字母意为守护程序。 ","date":"2018-07-10","objectID":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/:0:0","tags":["supervisor","运维"],"title":"使用supervisor监控管理Linux服务进程","uri":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux"],"content":"安装 easy_install supervisor or pip3 install supervisor or sudo apt install supervisor ","date":"2018-07-10","objectID":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/:0:1","tags":["supervisor","运维"],"title":"使用supervisor监控管理Linux服务进程","uri":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux"],"content":"配置 执行命令echo_supervisord_conf回显默认的初始配置文件。 可通过管道命令将配置文件重定向到某个目录，eg:echo_supervisord_conf \u003e /etc/supervisord.conf 以root用户运行需要增加 user=root 配置进程 例如要在vps上启用一个简单的http服务，用于分享download目录下的文件 [program:http-server] command=python3 -m http.server directory=/home/download/ redirect_stderr = true user=root autostart=true autorestart=true stderr_logfile=/var/log/simple-http-server_err.log stdout_logfile=/var/log/simple-http-server_out.log 启用web监控服务 通过浏览器远程管理，启动停止程序，查看日志等，非常方便。 [inet_http_server] ; inet (TCP) server disabled by default port=0.0.0.0:9001 ; (ip_address:port specifier, *:port for all iface) username=user ; (default is no username (open server)) password=123 ; (default is no password (open server)) ","date":"2018-07-10","objectID":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/:0:2","tags":["supervisor","运维"],"title":"使用supervisor监控管理Linux服务进程","uri":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux"],"content":"启动 supervisor supervisord -c supervisor.conf ","date":"2018-07-10","objectID":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/:0:3","tags":["supervisor","运维"],"title":"使用supervisor监控管理Linux服务进程","uri":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux"],"content":"supervisorctl 当配置文件更新后, 可用supervisorctl update更新配置, 但并未立即生效,需重启. 一般使用supervisorctl reload更新配置并重启所有程序. 停止所有程序 supervisorctl stop all 启动/停止/重启某程序 supervisorctl {start:stop:restart} program_name 查看所有子进程的状态supervisorctl ","date":"2018-07-10","objectID":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/:0:4","tags":["supervisor","运维"],"title":"使用supervisor监控管理Linux服务进程","uri":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux"],"content":"子进程状态 七种状态 STOPPED STARTING RUNNING BACKOFF STOPPING EXITED 第八种UNKNOWN(由supervisord出错引起) ","date":"2018-07-10","objectID":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/:0:5","tags":["supervisor","运维"],"title":"使用supervisor监控管理Linux服务进程","uri":"/20180710-%E4%BD%BF%E7%94%A8supervisor%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86linux%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux","数据库"],"content":"编译安装 # downloads postgresql-10.3.tar.gz wget https://ftp.postgresql.org/pub/source/v10.3/postgresql-10.3.tar.gz wget https://ftp.postgresql.org/pub/source/v10.3/postgresql-10.3.tar.gz.md5 wget https://ftp.postgresql.org/pub/source/v10.3/postgresql-10.3.tar.gz.sha256 # MD5 check 检查数据是否被篡改 cat postgresql-10.3.tar.gz.md5 md5sum postgresql-10.3.tar.gz # extract tar -xvf postgresql-10.3.tar.gz cd postgresql-10.3/ # 安装文档介绍的很详细 cat INSTALL ./configure # 提示缺少readline library， 尝试安装libreadline5-dev 提示已被libreadline-gplv2-dev 替代， 安装之 checking for library containing readline... no configure: error: readline library not found sudo apt install libreadline5-dev However the following packages replace it: libreadline-gplv2-dev:i386 libreadline-gplv2-dev sudo apt install libreadline-gplv2-dev checking for inflate in -lz... no configure: error: zlib library not found # 又提示缺失zlib library， 安装之 sudo apt install zlib1g-dev # 后边编译安装就顺利了：） make sudo make install sudo adduser postgres sudo mkdir /usr/local/pgsql/data sudo chown postgres /usr/local/pgsql/data su - postgres # 初始化数据库 /usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data or initdb -D /usr/local/pgsql/data # start the database server /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data \u003elogfile 2\u003e\u00261 \u0026 or pg_ctl -D /usr/local/pgsql/data -l logfile start # 测试成功 /usr/local/pgsql/bin/createdb test /usr/local/pgsql/bin/psql test # set postgresql env to .bashrc export PGHOME=/usr/local/pgsql export PGDATA=/usr/local/pgsql/data export PATH=$PGHOME/bin:$PATH:$HOME/bin ","date":"2018-04-26","objectID":"/20180426-ubuntu16.0418.04%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85postgresql/:0:1","tags":["PostgreSQL"],"title":"ubuntu16.04(18.04)下编译安装 postgresql v10.3","uri":"/20180426-ubuntu16.0418.04%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85postgresql/"},{"categories":["Linux","数据库"],"content":"创建用户 #CREATEDB是权限，还有其它权限，比如SUPERUSER、CREATEUSER等。一般情况下CREATEDB是最安全的做法。因为这个test用户的权限被限制在很小范围。CREATEUSERusernameCREATEDB;#修改用户密码ALTERUSERusernamePASSWORD'password'; ","date":"2018-04-26","objectID":"/20180426-ubuntu16.0418.04%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85postgresql/:0:2","tags":["PostgreSQL"],"title":"ubuntu16.04(18.04)下编译安装 postgresql v10.3","uri":"/20180426-ubuntu16.0418.04%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85postgresql/"},{"categories":["Linux","数据库"],"content":"设置远程访问权限 # edit postgresql.conf '*' replace 'localhost' vim /usr/local/pgsql/data/postgresql.conf #listen_addresses = 'localhost' listen_addresses = '*' # edit pg_hba.conf vim /usr/local/pgsql/data/pg_hba.conf # IPv4 local connections: add username authentication host all all 127.0.0.1/32 trust host all username 0.0.0.0/0 md5 # 重启使之生效 su - postgres pg_ctl restart ","date":"2018-04-26","objectID":"/20180426-ubuntu16.0418.04%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85postgresql/:0:3","tags":["PostgreSQL"],"title":"ubuntu16.04(18.04)下编译安装 postgresql v10.3","uri":"/20180426-ubuntu16.0418.04%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85postgresql/"},{"categories":["数据分析"],"content":" 微信小程序\"生命数计算器\"是一个根据\"生日\",“星座\"来分析性格特点，爱情匹配等信息的一款“娱乐玄学”小应用。 ","date":"2018-03-17","objectID":"/20180317-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%88%86%E6%9E%90/:0:0","tags":["用户画像","数据分析","微信小程序"],"title":"小程序\"生命数计算器\"用户画像分析(1-2月)","uri":"/20180317-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%88%86%E6%9E%90/"},{"categories":["数据分析"],"content":"年龄分布 **恋爱窗口期与年龄分布：**两性恋爱中有一种观点是18-25岁是一个恋爱活跃的窗口。24岁正是大学毕业后开始为事业忙碌奋斗的时刻。到了30岁心智更加成熟，也会有一定的财富积累，这个时候会打开第二个窗口期。从图中可以看出的分布走势呈M型，和这一观点非常吻合。是对这一观点的又一有力佐证。(所以呀，25岁还没找到异性朋友就再等5年吧！[自嘲脸]) **性别分布：**按照一般的固有思想，这类“玄学”类的应用女性用的会比较多，然而从统计分布图上来看男女比例相等，甚至男性用户还多一些，很有意思。数据还是很合理。 ","date":"2018-03-17","objectID":"/20180317-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%88%86%E6%9E%90/:0:1","tags":["用户画像","数据分析","微信小程序"],"title":"小程序\"生命数计算器\"用户画像分析(1-2月)","uri":"/20180317-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%88%86%E6%9E%90/"},{"categories":["数据分析"],"content":"地区分布 从地区分布图看广东省top1,是\"广东省更相信风水\"的又一个佐证。为什么\"广东省更相信风水”？ 来自知乎讨论： 因为广东香港远离中原，自古所受的战乱不多，传统习俗保存得比较完整，你试看看粤语就知道了，它保留的口音是唐代以前的，称得上是活文物了。尤其是文革那个疯狂的年代，广东这里所受的冲击，相比于北方，不算太大的，传统文化或习俗很大没有被清洗。所以也是万幸的事了。这样，风水的习俗在广东依然盛行就不为怪。 作者：梁巷华 链接：https://www.zhihu.com/question/20004702/answer/13914692 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2018-03-17","objectID":"/20180317-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%88%86%E6%9E%90/:0:2","tags":["用户画像","数据分析","微信小程序"],"title":"小程序\"生命数计算器\"用户画像分析(1-2月)","uri":"/20180317-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%88%86%E6%9E%90/"},{"categories":["数据分析"],"content":"迷之凸起 一月25日有一个用户访问高峰，这一天既不是假日，也不是重大节日。很奇怪造成这个异常点的原因。 ","date":"2018-03-17","objectID":"/20180317-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%88%86%E6%9E%90/:0:3","tags":["用户画像","数据分析","微信小程序"],"title":"小程序\"生命数计算器\"用户画像分析(1-2月)","uri":"/20180317-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%88%86%E6%9E%90/"},{"categories":["生活"],"content":" 不全身心投入地跳一次, 永无法理解Zumba的魅力. 第一次来到健身房的我，对桑巴，尊巴，POP，普拉提，阿斯汤加等课程的新鲜名词一丝概念也没有，仿佛发现了新大陆。按我以往对新事物的态度，必然会在网上检索一番。然后针对自己的特长喜好来做出选择。但我这次想要把所有的课程都亲身体验一遍。“实践是检验真理的唯一标准”，亲自体验才能真正了解自己想要的。也考虑到了，即使自己没有任何基础，跟不上节奏，我也要坚持完一节课。我很庆幸自己做出了这样的选择，假使我只是隔窗相望, 看到的必然是一副\"群魔乱舞\"的景象而心存芥蒂。 当伴随音乐响起扭动的那一刻，我知道我爱上她啦。当那节奏强烈的音乐响起，便足以使人兴奋！在这里的快速运动不仅仅是消耗身体中多余的脂肪，更多的还有精神上的愉悦。沉浸其中，可以忘却\"生活\"，“情感”，“工作\"中的种种烦恼，酣畅淋漓地恣意挥洒着舞姿是多么畅快！不用在意任何人的看法。在这里没有对舞姿，舞感的任何要求，入门门槛极低，更没有性别，年龄，肤色的任何限制，甚至不在乎是不是一个’人'，只要它能伴随着音乐尽情扭动，脸上洋溢着快乐，这就够了！ 上遍所有课的第二个好处就是可以体验每个教师的授课特点。情绪是可以传染的，假使我\"意外\"步入尊巴教室是一件幸事，那么第二件便是遇到一个能够把快乐与激情带给我的孙洁老师。孙老师不但有很强的舞感。那一颦一簇，举手投足，几声呐喊，便足以把快乐的情感传到到人间。这我可学不来。 (～￣▽￣)～ 这是音乐与运动美的结合，随着音乐领略南美舞动的文化。我喜欢的Zumba音乐有zum72的Makosa和Internacionales等。歌词都是西班牙语，其中Makosa的歌词大意便是“挥动舞步前后左右摇摆”。Internacionales译为“国际化”？大意是“舞蹈不需要语言，来自各个国家的人同在一个舞台舞动”。它的MV也很有意思，讲的是：一个南美的旅游社的社员因没去过中国长城受到旅客嘲讽，随即萌发访问东方世界的想法。买了双旱冰鞋便开启了一场说走就走的旅行。 ～(￣▽￣～) 不过遗憾的是我感到Zumba在中国仍属小众运动，我在这次‘偶遇’之前从没听过这个词。这大抵是东方内敛中庸的文化与南美激情奔放文化巨大差异导致的。不过好在今年看到优酷独家推出《这！就是街舞》，会对尊巴，街舞类文化知识的普及，流行起到巨大的推动作用吧！(最近新开了街舞课，我要再尝试一下！φ(≧ω≦*)♪) 最后介绍下我对Zumba的亲身了解吧。 1.没学过舞步动作，没有舞蹈基础都不打紧，模仿领舞的动作直接开跳就是。 2.开始不要在意自己的舞姿是否好看。但一定要用力大幅度挥动舞姿。让自己沉浸其中，想着自己是最快乐的人，做到忘我。（PS:我舞感就很差，跳的就很尴尬，但这里的人都沉浸在自己的世界中。不必害羞或放不开步伐，达到健康快乐的目的就好） 3.虽然不要求舞姿，但做任何事都要有些专业精神不是么？所以应尽量模仿做到一板一眼。 4.服装方面没有特定要求，尽量穿宽松，鲜艳的服装（鲜艳的衣服扭动起来多带劲啊！） 5.体液消耗巨大，随身带个小水瓶补充体液。 ","date":"2018-03-10","objectID":"/20180310-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%96%9C%E7%88%B1%E5%B0%8A%E5%B7%B4/:0:0","tags":["zumba","运动"],"title":"我为什么喜爱尊巴","uri":"/20180310-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%96%9C%E7%88%B1%E5%B0%8A%E5%B7%B4/"},{"categories":["生活"],"content":" 祈祷式: for the beginning of Ashtanga Yoga practice Sanskrit Mantra/梵语唱诵: CHANT-PATANJALI OM vande gurunam caranaravinde sandarsita svatma sukhava bodhe nih sreyase jangalikayamane samsara halahala mohasantyai abahu purusakaram sankhacakrasi dharinam sahasra sirasam svetam pranamami patanjalim OM OM I bow to the two lotus feet of the Gurus which awaken insight into the happiness of pure Being, which are the refuge, the jungle physician, which eliminate the delusion caused by the poisonous herb of Samara (conditioned existence) I prostrate before the sage Patanjali who has thousands of radiant, white heads (as the divine serpent, Ananta) and who has, as far as his arms, assumed the form of a man holding a conch shell (divine sound), a wheel (discus of light or infinite time) and a sword (discrimination ) OM OM Vande = bow Gurunam = to the plurality of gurus Caranaravinde = two lotus feet sandarsita = to bring to sight Svatma = pure Being Sukhava = happiness Bodhe = awakened nishreyase = refuge jangalikayamane = jungle hut (meaning shaman, jungle physician) samsara = conditioned existence halahala = poison moha = delusion santyai = peace abahu = down to the shoulders purusakaram = assumes the form of a man sankha = conch shell cakra = a wheel (discus of light or infinite time) asi = sword (of discrimination) dharinam = holding sahasra = thousands sirasam = heads svetam = radiant, white pranamami = prostrate patanjalim = the sage Patanjali 我虔诚地向我最尊敬的导师俯身祈祷，他传授我知识，唤起我内心的巨大的快乐。他像一名丛林医生，能祛除在某种情况下由于存在毒素而生的幻念。帕坦加力(Patanjali)，阿迪塞萨(Adisesa)的化身，他有白色的肌肤，长着一千个向四方延展的头(外形如蛇神)，人身；手举一把歧视之剑，一个象征无穷时间的火轮和一个象征给他神的声音的海螺。我俯身致敬。 祈祷式: End Mantra of Ashtanga Yoga Sanskrit Mantra/梵语唱诵: Mangala Mantra Om Svasti praja bhyaha pari pala yantam Nya yena margena mahi mahishaha Go brahmanebhyaha shubamastu nityam Lokah samastah sukhino bhavantu Om shanti shanti shanti Let prosperity be glorified - let rulers, (administrators) rule the world with law and justice let divinity and erudition be protected let all beeings be happy and prosperous. 用法律和正义维护世界 保护神圣的生命 让所有的众生过上幸福繁荣的生活。 ","date":"2018-01-23","objectID":"/20180123-%E9%98%BF%E6%96%AF%E6%B1%A4%E5%8A%A0%E7%91%9C%E4%BC%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%94%B1%E8%AF%B5%E7%BB%8F%E6%96%87/:0:0","tags":["Ashtanga","运动"],"title":"阿斯汤加瑜伽学习笔记-唱诵经文","uri":"/20180123-%E9%98%BF%E6%96%AF%E6%B1%A4%E5%8A%A0%E7%91%9C%E4%BC%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%94%B1%E8%AF%B5%E7%BB%8F%E6%96%87/"},{"categories":["Linux"],"content":"安装 sudo apt-get install vmpk sudo apt-get install timidity ","date":"2017-10-23","objectID":"/20171023-%E4%BD%BF%E7%94%A8vmpk%E5%9C%A8linux%E4%B8%8B%E5%BC%B9%E9%92%A2%E7%90%B4/:0:1","tags":["Linux","tools","midi"],"title":"玩转midi:使用vmpk在Gnu/Linux下弹钢琴","uri":"/20171023-%E4%BD%BF%E7%94%A8vmpk%E5%9C%A8linux%E4%B8%8B%E5%BC%B9%E9%92%A2%E7%90%B4/"},{"categories":["Linux"],"content":"配置 依次打开　QjackCTL，Qsynth(打开后其它音乐软件会禁声), VMPK, 配置Qsynth: Soundfonts　→　Open 加载sf2文件，(一般路径为/usr/share/sounds/sf2/FluidR3_GM.sf2) 配置QjackCTL: 1.Start 2.Connect Audio: qsynth match system ALSA: VMPK Output match FLUID Synth(21225) 配置VMPK Edit → Connections → Output MIDI Connection: FLUID Synth → OK 尽情在键盘上挥洒音符吧：） 软件禁声恢复: quit Qsynth, STOP QjackCTL ubuntu中文论坛ＶＭＰK 配置 ","date":"2017-10-23","objectID":"/20171023-%E4%BD%BF%E7%94%A8vmpk%E5%9C%A8linux%E4%B8%8B%E5%BC%B9%E9%92%A2%E7%90%B4/:0:2","tags":["Linux","tools","midi"],"title":"玩转midi:使用vmpk在Gnu/Linux下弹钢琴","uri":"/20171023-%E4%BD%BF%E7%94%A8vmpk%E5%9C%A8linux%E4%B8%8B%E5%BC%B9%E9%92%A2%E7%90%B4/"},{"categories":["微信小程序"],"content":" ├── app.js 应用程序逻辑 ├── app.json 页面路径(默认显示第一个)，全局应用程序配置 ├── app.wxss 应用程序公共样式 ├── pages 页面目录 │ ├── index index 页面 │ │ ├── index.js 页面入口，index页面逻辑 │ │ ├── index.wxml index页面结构 │ │ └── index.wxss index页面样式 │ └── logs logs页面 │ ├── logs.js 逻辑页面 │ ├── logs.json │ ├── logs.wxml 结构页面 │ └── logs.wxss 样式页面 └── utils 公共脚本目录 └── util.js 公共脚本 tool desc 微信小程序控制台 开发管理，数据分析，设置，获取AppID 开发文档API 开发者工具 wx小程序IDE Linux开发者工具 计算器Demo参考sCalc WeUI leancloud控制台 可作为免费的微信小程序后台数据测试服务器 小程序数据助手 {:height=“200px” width=“400px”} 表单 input 属性： maxlength: 最大字符数限制 focus true: 启用光标焦点 type text: 全键盘 number: 数字键盘(0~9) idcard：数字键盘(0~9, X) digit:数字键盘(0~9, .) placeholder: 输入框中默认的提示文字 表单重置 层级规范 Popout: 弹出层，内容层和导航层的补充。 承载弹窗通知，操作菜单，菜单，成功或加载中状态的Toast Mask: 蒙层，配合Popout层使用，用于锁定内容层和导航层 Navigation: 导航层 位于内容层之上，用户滑动内容层时可保持位置不动。 Content: 内容层 ","date":"2017-10-13","objectID":"/2017-10-13-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/:0:0","tags":["微信小程序"],"title":"微信小程序开发笔记","uri":"/2017-10-13-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"categories":["生活"],"content":" 生活如此美妙 穿过万丈乌云 有温暖的阳光照耀 还有你的微笑 ","date":"2017-09-17","objectID":"/20170917-%E7%BE%8E%E5%A6%99%E7%9A%84%E7%94%9F%E6%B4%BB/:0:0","tags":["poem","情感"],"title":"美妙的生活","uri":"/20170917-%E7%BE%8E%E5%A6%99%E7%9A%84%E7%94%9F%E6%B4%BB/"},{"categories":["生活"],"content":" 时间:2017-09-10 主讲人: 杜保瑞 老师 ","date":"2017-09-11","objectID":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/:0:0","tags":["笔记","哲学"],"title":"《有理想的人如何运用老庄的智慧》讲座笔记与总结","uri":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/"},{"categories":["生活"],"content":"1、理想与人生的关系是什么？ 找到生命的意义，终生努力的目标，时刻清醒自觉，价值判断有据，应对进退合理 找有意义的事全心投入，不好高骛远，也不轻视自己。 有自己的原则，做任何事都不违背自己设定的目标。 有自己的节奏，有目标，找到自己的角色扮演。认同自己，就是尊重自己，即自重。能够不为一些人或事所左右。 ","date":"2017-09-11","objectID":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/:0:1","tags":["笔记","哲学"],"title":"《有理想的人如何运用老庄的智慧》讲座笔记与总结","uri":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/"},{"categories":["生活"],"content":"2、如何发掘(实现)个人的理想？ 先有爱心，愿意付出，愿意忍耐，尊重自己。 ","date":"2017-09-11","objectID":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/:0:2","tags":["笔记","哲学"],"title":"《有理想的人如何运用老庄的智慧》讲座笔记与总结","uri":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/"},{"categories":["生活"],"content":"中国哲学都是有理想的人的哲学 墨家：自救团体照顾百姓 儒家：知识分子从政 儒家：敬鬼神而远之，协助王作为民的代言人。承担责任，从政为天下服务。 庄子：追求个人天分的个性逍遥 不相信体制，对自己喜欢的事做到极致。 老子：站在高位照顾全民 多人合作，把利益让出去，最终目的把事办成。 法家：登上高峰，富国强兵 小人是国君欲望的代言人 权臣是国君无能表现的发言人 佛家：面对命运了脱生死 ","date":"2017-09-11","objectID":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/:0:3","tags":["笔记","哲学"],"title":"《有理想的人如何运用老庄的智慧》讲座笔记与总结","uri":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/"},{"categories":["生活"],"content":"3、孔孟所追求的以及所面对的理想是什么？ 孔子：为学，修己，致孝，应对，辩惑，崇礼，问仁，治国。 孟子：圣王，圣贤，致仕，性善，求放心，浩然之气。 ","date":"2017-09-11","objectID":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/:0:4","tags":["笔记","哲学"],"title":"《有理想的人如何运用老庄的智慧》讲座笔记与总结","uri":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/"},{"categories":["生活"],"content":"4、庄子所追求的以及所面对的理想是什么？ 逍遥游、齐物论、养生主、人间世、德充符、大宗师、应帝王 ","date":"2017-09-11","objectID":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/:0:5","tags":["笔记","哲学"],"title":"《有理想的人如何运用老庄的智慧》讲座笔记与总结","uri":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/"},{"categories":["生活"],"content":"5、老子所追求的以及所面对的理想是什么？ 有无相生。反者道之动 弱者道之用。玄同，玄德。不敢为天下先。以无事取天下。天下莫能与之争。 ","date":"2017-09-11","objectID":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/:0:6","tags":["笔记","哲学"],"title":"《有理想的人如何运用老庄的智慧》讲座笔记与总结","uri":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/"},{"categories":["生活"],"content":"6、一个儒者如何学习庄子的智慧。 看破体制的绝对性，一切靠自己，寻求可以实践的事业。 ","date":"2017-09-11","objectID":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/:0:7","tags":["笔记","哲学"],"title":"《有理想的人如何运用老庄的智慧》讲座笔记与总结","uri":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/"},{"categories":["生活"],"content":"7、一个儒者如何学习老子的智慧。 卸下道德仁义功名利禄之心，顾全大局，委曲求全，忍辱负重，给而不取。 ","date":"2017-09-11","objectID":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/:0:8","tags":["笔记","哲学"],"title":"《有理想的人如何运用老庄的智慧》讲座笔记与总结","uri":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/"},{"categories":["生活"],"content":"8、圆滿的理想主义者。 一切自足，随时调整角色，一切都是别人的，一切都是自己的。 ","date":"2017-09-11","objectID":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/:0:9","tags":["笔记","哲学"],"title":"《有理想的人如何运用老庄的智慧》讲座笔记与总结","uri":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/"},{"categories":["生活"],"content":"释义： 朝闻道，夕死可矣: 早晨闻道，晚上死去。形容对真理或某种信仰追求的迫切。 欲仁斯仁至: 想追求仁，那么仁就会来到 反者道之动 弱者道之用: 循环往复的运动变化，是道的运动，道的作用是微妙、柔弱的。天下的万物产生于看得见的有形质，有形质又产生于不可见的无形质。 敬鬼神而远之: 原意是敬之而不亲近之意。现在常用来指对某些人所持的一种态度，即不愿理睬他，又怕得罪他，所以对他客客气气，但是绝不接近。 上有所好，下必甚焉: 居上位的人有哪一种爱好，在下面的人必定爱好得更厉害。指上行下效，影响深重。 燕京读书会blog：传承中华生命智慧为目标。国学研读。 《人物志》：对职场上人分类。人物性格的优缺点。甄别人才，选贤任能。了解自己及自己的部署。协助自己了解状态。 天才 通才 偏才 平步青云上升的原则：做公家的事，不争公家的事的名和利。 《菜根谭》：三大智慧，儒家为人服务的人生观；庄子潇洒自由的智慧，不被别人的眼光，世俗所束缚；老子创造福报，不与人争斗的智慧。 ","date":"2017-09-11","objectID":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/:0:10","tags":["笔记","哲学"],"title":"《有理想的人如何运用老庄的智慧》讲座笔记与总结","uri":"/20170911-%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0%E6%9C%89%E7%90%86%E6%83%B3%E7%9A%84%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E8%80%81%E5%BA%84%E7%9A%84%E6%99%BA%E6%85%A7/"},{"categories":["Linux"],"content":" 3.05.01 及 以后的版本没有Linux的二进制包,需要编译安装. # 安装相关组件 sudo apt-get install g++ # or clang++ (presumably) sudo apt-get install autoconf automake libtool sudo apt-get install autoconf-archive sudo apt-get install pkg-config sudo apt-get install libpng12-dev sudo apt-get install libjpeg8-dev sudo apt-get install libtiff5-dev sudo apt-get install zlib1g-dev sudo apt-get install libicu-dev sudo apt-get install libpango1.0-dev sudo apt-get install libcairo2-dev 依赖图像库Leptonica,在编译tesseract前先编译Leptonica, 版本对应关系见Compiling#linux,3.05对应leptonica-1.74.tar.gz wget http://www.leptonica.org/source/leptonica-1.74.tar.gz tar -xvf leptonica-1.74.tar.gz cd leptonica-1.74 ./configure make make install 编译安装tesseract 4.00.00alpha git clone https://github.com/tesseract-ocr/tesseract.git cd tesseract ./autogen.sh ./configure make make install wiki ","date":"2017-08-25","objectID":"/20170825-ubuntu16-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85tesseract4/:0:0","tags":["图像识别","tesseract"],"title":"Ubuntu16.04 下编译安装tesseract 4.00.00alpha 及测试","uri":"/20170825-ubuntu16-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85tesseract4/"},{"categories":["Linux"],"content":"python3 调用 sudo pip3 install pytesseract import pytesseract vcode = pytesseract.image_to_string(im, lang='eng', config='-psm 12 --tessdata-dir /tessdata/') ","date":"2017-08-25","objectID":"/20170825-ubuntu16-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85tesseract4/:0:1","tags":["图像识别","tesseract"],"title":"Ubuntu16.04 下编译安装tesseract 4.00.00alpha 及测试","uri":"/20170825-ubuntu16-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85tesseract4/"},{"categories":["算法"],"content":"问题: 对如下图中的字符进行识别: 样本: ","date":"2017-08-23","objectID":"/20170823-%E5%9F%BA%E4%BA%8E%E7%9B%B8%E5%90%8C%E9%A2%9C%E8%89%B2%E8%BF%9E%E9%80%9A%E5%83%8F%E7%B4%A0%E4%B8%AA%E6%95%B0%E7%9A%84%E7%BB%9F%E8%AE%A1%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/:0:1","tags":["图像识别","python","算法","DFS"],"title":"基于相同颜色连通像素个数的统计进行图像字符识别","uri":"/20170823-%E5%9F%BA%E4%BA%8E%E7%9B%B8%E5%90%8C%E9%A2%9C%E8%89%B2%E8%BF%9E%E9%80%9A%E5%83%8F%E7%B4%A0%E4%B8%AA%E6%95%B0%E7%9A%84%E7%BB%9F%E8%AE%A1%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/"},{"categories":["算法"],"content":"解题思路: 无论是图像，音频的识别，不外乎是对各种特征(特征向量)进行统计归纳。 放大后的样本: 通过观察，发现这是一张简单的，非常有规律可循的图。 越有规律越容易进行分类。这里的思路就是自左至右依次对相同颜色的像素连通区进行像素个数统计，从而制成像素与字符对应的字典进行识别。 ","date":"2017-08-23","objectID":"/20170823-%E5%9F%BA%E4%BA%8E%E7%9B%B8%E5%90%8C%E9%A2%9C%E8%89%B2%E8%BF%9E%E9%80%9A%E5%83%8F%E7%B4%A0%E4%B8%AA%E6%95%B0%E7%9A%84%E7%BB%9F%E8%AE%A1%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/:0:2","tags":["图像识别","python","算法","DFS"],"title":"基于相同颜色连通像素个数的统计进行图像字符识别","uri":"/20170823-%E5%9F%BA%E4%BA%8E%E7%9B%B8%E5%90%8C%E9%A2%9C%E8%89%B2%E8%BF%9E%E9%80%9A%E5%83%8F%E7%B4%A0%E4%B8%AA%E6%95%B0%E7%9A%84%E7%BB%9F%E8%AE%A1%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/"},{"categories":["算法"],"content":"局限性及应对措施: 此种方法只针对’少量的'，’简单的‘字符图形。若字符种类过多，容易造成不同像素个数冲突的问题。 针对冲突问题，一种有限的解决办法即针对’不同’的特征，进行二次验证。 ","date":"2017-08-23","objectID":"/20170823-%E5%9F%BA%E4%BA%8E%E7%9B%B8%E5%90%8C%E9%A2%9C%E8%89%B2%E8%BF%9E%E9%80%9A%E5%83%8F%E7%B4%A0%E4%B8%AA%E6%95%B0%E7%9A%84%E7%BB%9F%E8%AE%A1%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/:0:3","tags":["图像识别","python","算法","DFS"],"title":"基于相同颜色连通像素个数的统计进行图像字符识别","uri":"/20170823-%E5%9F%BA%E4%BA%8E%E7%9B%B8%E5%90%8C%E9%A2%9C%E8%89%B2%E8%BF%9E%E9%80%9A%E5%83%8F%E7%B4%A0%E4%B8%AA%E6%95%B0%E7%9A%84%E7%BB%9F%E8%AE%A1%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/"},{"categories":["算法"],"content":"python实现: from PIL import Image import numpy as np class dfs_simple_digital_chacpt(object): def __init__(self, path): self.white = [238, 238, 238] self.row_num = 10 self.col_num = 40 self.walked_set = set() self.roming_set = set() self.dfs_num = 0 im = Image.open(path) self.image_array = np.array(im).tolist() def dfs(self, x, y, rgb): ''' desc:用递归实现搜索范围内相同rgb值的像素 :param x: :param y: :param char: :return: ''' self.roming_set.add(tuple([x, y])) if 0 \u003e x or 0 \u003e y or x \u003e= self.row_num or y \u003e= self.col_num: # 越界检查 return if tuple([x,y]) in self.walked_set: # 重复遍历检查 return if rgb != self.image_array[x][y]: # 目标rgb值检查 return self.walked_set.add(tuple([x, y])) self.dfs(x + 1, y, rgb) # x self.dfs(x, y + 1, rgb) # y self.dfs(x - 1, y, rgb) # -x self.dfs(x, y - 1, rgb) # -y self.dfs(x + 1, y + 1, rgb) # Ⅰ self.dfs(x + 1, y - 1, rgb) # Ⅱ self.dfs(x - 1, y - 1, rgb) # Ⅲ self.dfs(x - 1, y + 1, rgb) # Ⅳ return def walk(self): ''' desc: :return: ''' for y in range(self.col_num): for x in range(self.row_num): rgb = self.image_array[x][y] if tuple([x, y]) in self.roming_set: continue if rgb != self.white: self.dfs(x, y, rgb) num = len(self.walked_set) print(num) self.walked_set.clear() self.roming_set.clear() if __name__ == '__main__': path = '' c = dfs_simple_digital_chacpt(path) dfs_num = c.walk() ","date":"2017-08-23","objectID":"/20170823-%E5%9F%BA%E4%BA%8E%E7%9B%B8%E5%90%8C%E9%A2%9C%E8%89%B2%E8%BF%9E%E9%80%9A%E5%83%8F%E7%B4%A0%E4%B8%AA%E6%95%B0%E7%9A%84%E7%BB%9F%E8%AE%A1%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/:0:4","tags":["图像识别","python","算法","DFS"],"title":"基于相同颜色连通像素个数的统计进行图像字符识别","uri":"/20170823-%E5%9F%BA%E4%BA%8E%E7%9B%B8%E5%90%8C%E9%A2%9C%E8%89%B2%E8%BF%9E%E9%80%9A%E5%83%8F%E7%B4%A0%E4%B8%AA%E6%95%B0%E7%9A%84%E7%BB%9F%E8%AE%A1%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/"},{"categories":["算法"],"content":"POJ 2386 问题: 有一个大小为N×M的园子，雨后积起了水。八连通的积水被认为是连在一起的。求园子里一共有多少水洼？\\ 限制条件N,M\u003c=100 输入 W........WW. .WWW.....WWW ....WW...WW. .........WW. .........W.. ..W......W.. .W.W.....WW. W.W.W.....W. .W.W......W. ..W.......W. 输出: 3 题解: DFS次数为水洼的个数， POJ No.2386 python 实现: # POJ No.2386 class poj2386(object): def __init__(self, map): self.row_num = 10 self.col_num = 12 self.m = self.matrix(map.replace('\\n','')) self.walked_set = set() self.dfs_num = 0 def matrix(self, map): ''' desc: 字符串转数组，方便遍历 :return ['row0','row1'...] ''' col_num = 0 matrix = [] for r in range(self.row_num): matrix.append(map[col_num: col_num + self.col_num]) col_num = col_num + self.col_num return matrix def dfs(self, x, y, char): ''' desc:用递归实现搜索范围内相同字符 :param x: :param y: :param char: :return: ''' if 0 \u003e x or 0 \u003e y or x \u003e= self.row_num or y \u003e= self.col_num : # 越界检查 return if tuple([x,y]) in self.walked_set: # 重复遍历检查 return if char != self.m[x][y]: # 目标字符检查 return self.walked_set.add(tuple([x, y])) self.dfs(x + 1, y, char) # x self.dfs(x, y + 1, char) # y self.dfs(x - 1, y, char) # -x self.dfs(x, y - 1, char) # -y self.dfs(x + 1, y + 1, char) # Ⅰ self.dfs(x + 1, y - 1, char) # Ⅱ self.dfs(x - 1, y - 1, char) # Ⅲ self.dfs(x - 1, y + 1, char) # Ⅳ return def walk(self): ''' desc: 对矩阵遍历 :return: ''' for x in range(self.row_num-1): for y in range(self.col_num-1): if tuple([x, y]) in self.walked_set: continue if self.m[x][y] == '.': continue if self.m[x][y] == 'W': self.dfs(x, y, 'W') self.dfs_num +=1 return self.dfs_num if __name__ == '__main__': map = ''' W........WW. .WWW.....WWW ....WW...WW. .........WW. .........W.. ..W......W.. .W.W.....WW. W.W.W.....W. .W.W......W. ..W.......W. ''' c = poj2386(map) dfs_num = c.walk() print(dfs_num) ","date":"2017-08-19","objectID":"/20170819-poj2386/:0:1","tags":["《挑战程序设计(第二版)》","python","算法","DFS"],"title":"《挑战程序设计(第二版)》（第二章）POJ No.2386","uri":"/20170819-poj2386/"},{"categories":["网络安全"],"content":"火车票脱敏身份证信息还原 经常在朋友圈看到好友晒旅行的火车票. 火车票有我们的姓名及经过脱敏处理的身份证信息, 但仅仅屏蔽了出生的月份日期，通过校验位暴力遍历便可筛选可能的30余组号码.即猜中的概率为3%．如果再通过其它渠道获得如星座等信息．就可将猜中的概率提高10倍，即有三分之一的可能性被猜中． 验证Demo: import re import calendar IDCARD_REGEX = '[1-9][0-9]{14}([0-9]{2}[0-9X])?' def is_valid_idcard(idcard): \"\"\"Validate id card is valid.\"\"\" if isinstance(idcard, int): idcard = str(idcard) if not re.match(IDCARD_REGEX, idcard): return False # 将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为： factors = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2] items = [int(item) for item in idcard[:-1]] # 将这17位数字和系数相乘的结果相加 copulas = sum([a * b for a, b in zip(factors, items)]) # 用加出来和除以11，看余数是多少？ 余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。 其分别对应的最后一位身份证的号码为： ckcodes = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'] return ckcodes[copulas % 11].upper() == idcard[-1].upper() def show_possibility_month_day(year): for month in range(1, 13): m = '0' + str(month) if len(str(month)) \u003c 2 else str(month) for day in range(calendar.monthrange(year, month)[1] + 1)[1:]: d = '0' + str(day) if len(str(day)) \u003c 2 else str(day) r = '110101'+str(year)+m+d+'0539' if is_valid_idcard(r): print(r) if __name__ == '__main__': show_possibility_month_day(1999) # 符合条件的可能 ''' 110101199901010539 110101199901280539 110101199902080539 110101199902160539 110101199902240539 110101199903040539 110101199903120539 110101199903200539 110101199904190539 110101199904270539 110101199905070539 110101199905150539 110101199905230539 110101199905310539 110101199906030539 110101199906110539 110101199907180539 110101199907260539 110101199908060539 110101199908140539 110101199908220539 110101199908300539 110101199909020539 110101199909100539 110101199909290539 110101199910080539 110101199910160539 110101199910240539 110101199911040539 110101199911120539 110101199911200539 110101199912190539 110101199912270539 ''' ","date":"2017-08-01","objectID":"/20170802-%E7%81%AB%E8%BD%A6%E7%A5%A8%E4%B8%AD%E7%9A%84%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%BF%A1%E6%81%AF/:0:1","tags":["社会工程学","身份证号","python","CTF"],"title":"火车票中的社会工程学信息","uri":"/20170802-%E7%81%AB%E8%BD%A6%E7%A5%A8%E4%B8%AD%E7%9A%84%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%BF%A1%E6%81%AF/"},{"categories":["网络安全"],"content":"隐私泄露的危害: 首先信息泄露会推动诈骗行为，即使自己有防范意识也难免会殃及身边的亲朋好友．泄露的信息越多，诈骗者的套路手段越高明. 所以为了自己爱的人和爱自己的人应尽量避免泄露重要的身份信息，即使要晒图也要打好码啊！(尤其身份证后四位)［手动捂脸］ ","date":"2017-08-01","objectID":"/20170802-%E7%81%AB%E8%BD%A6%E7%A5%A8%E4%B8%AD%E7%9A%84%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%BF%A1%E6%81%AF/:0:2","tags":["社会工程学","身份证号","python","CTF"],"title":"火车票中的社会工程学信息","uri":"/20170802-%E7%81%AB%E8%BD%A6%E7%A5%A8%E4%B8%AD%E7%9A%84%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%BF%A1%E6%81%AF/"},{"categories":["网络安全"],"content":"如何检测信息是否泄露及应对措施: 社工自己:即利用多个搜索引擎搜索自己可能泄露出的信息(如姓名, 身份证号, 手机号等)．即使没有查到也不表明隐私信息是安全的,　可能仍在地下市场流动或在某个社工库中伺机爆发． 若发现搜索引擎有相关隐私记录需第一时间联系相关搜索网站，避免扩大影响．如百度搜索投诉服务中心 侵犯隐私权的行为的主要表现形式： 根据国情和社情，下列行为可归入侵犯隐私权范畴： 1、未经公民许可，公开其姓名、肖像、住址和电话号码。 2、非法侵入、搜查他人住宅，或以其他方式破坏他人居住安宁。 3、非法跟踪他人，监视他人住所，安装窃听设备，私拍他人私生活镜头，窥探他人室内情况。 4、非法刺探他人财产状况或未经本人允许公布其财产状况。 5、私拆他人信件，偷看他人日记，刺探他人私人文件内容，以及将他们公开。 6、调查、刺探他人社会关系并非法公诸于众。 7、干扰他人夫妻性生活或对其进行调查、公布。 8、将他人婚外性生活向社会公布。 9、泄露公民的个人材料或公诸于众或扩大公开范围。 10、收集公民不愿向社会公开的纯属个人隐私的情况。 ","date":"2017-08-01","objectID":"/20170802-%E7%81%AB%E8%BD%A6%E7%A5%A8%E4%B8%AD%E7%9A%84%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%BF%A1%E6%81%AF/:0:3","tags":["社会工程学","身份证号","python","CTF"],"title":"火车票中的社会工程学信息","uri":"/20170802-%E7%81%AB%E8%BD%A6%E7%A5%A8%E4%B8%AD%E7%9A%84%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%BF%A1%E6%81%AF/"},{"categories":["生活"],"content":"警告: ↓↓↓大量剧透 ↓↓↓ 在未来世界，都市中巨幅全息投影的大规模应用，隐形技术的实战应用，及义体的广泛流行，展现着生物机械技术，影像技术及网络技术的飞速发展。然而科技与伦理道德间的冲突如达摩克利斯之剑悬在社会的肩头。光怪陆离的都市与平民街景的格格不入，也彰显科技的融合，矛盾与冲突。 影片前半段随着2571计划的失败品，反社会角色Kuze(久世)的复仇行动展开。这里涉及到意识操控及自由意志的问题。首先被阪华机械公司剥夺身体的女主角素子(身份:Major,蜜拉Mira)和Kuze本身就被剥夺了意志。其次，为实行复仇计划，被Kuze操控无辜的人也失去了自己的意志。在复仇行动中以及警局的反剿过程中被波及的人被无情的屠杀。战争，受伤的永远是平民。这些意识被操控的人是否有罪？ 此外，这个世界义体不再只为残疾群体服务。都市街头的立体影像，街头招揽生意的义体强化服务者。都向人民灌输着义体强化的种种“好处”，身体健康的人，为了所谓的“力量”，“超能力”抛弃原有的肢体而换上义体。有的人只为了“豪饮”，而装上了义体胃。这是享乐主义盛行的社会。另一方面的危险由非洲联邦总统对阪华机械顾问奥斯蒙博士提出的质疑讲述:“但是没有人知道 操弄人类灵魂，对自我身份认同所造成的危险。\"这里有个有意思的讽刺桥段,当总统刚说完这句话，博士就被身旁伺机而动的服务艺伎劫持。此时总统还一本正经地指着说道:“你看，就像我刚才说的那样。\"。 随着Major与Kuze第一次接触后，对自己的身世及公司和犹如母亲般改造自己的奥莱特博士产生质疑。Major由和奥斯蒙博士的对话中的得知前98个实验品都已失败。Major是第99个实验品。这个99是个隐喻(metaphor)，预示不会再有被剥夺意志而产生的实验品。(在动画《叛逆的鲁鲁修》中也有此隐喻。鲁鲁修的父亲是不列颠帝国第98代皇帝，鲁鲁修篡夺成为第99代。预示着帝制在此终结) 从影片中还可看出对人类记忆操作技术的成熟。记忆可以像电脑数据一样。包括但不限于记忆存取,记忆传输,记忆消除,记忆抑制,记忆伪造。但Major的记忆并没有完全消除。在神经元的深处还存在残留的记忆。可以用数据仓库中的多重备份策略来理解。一份数据(记忆)分别保存在不同的节点(神经元)，即使某些节点的数据损害。只要有一个节点存在，数据(记忆)就是存在的。Kuze的理想网络世界也是同样的道理。 在后半部分，Major对奥斯蒙博士每次记忆操作的授权也是一种自由意志的体现。Major想要留住奥斯蒙博士这份记忆，不同意删除记忆的操作。奥斯蒙博士:“We never needed your consent.Yours or anyone’s.\"，一方面是说给反派BOSS卡特听，另一方面也反映像公司一样一类人对自由意志赤裸裸的剥夺，践踏。最后警长征得Major对反派BOSS卡特的删除令，则是对Major自由意志的尊重，成全。 最后与巨型机器坦克BOSS大战的桥段槽点还是蛮多的。 火控精度不准，无法形成有效杀伤。制动差，转火慢。机舱甲板被拉起这点尤为勉强，仅仅是为了增加悲壮气氛的效果吧。 总体还是很不错的一部片子 我们执着与记忆，觉得它定义了我们,但定义我们的是我们的行为。人性才是我们的美德。We cling to memories as if they define us,But what we do defines us.humanity is our virtue. 与VR虚拟影像, 记忆，自由意志相关概念的剧集:黑镜第三季《游戏测试》，《圣朱尼佩罗》，《人与武器的对抗》 ","date":"2017-07-29","objectID":"/20170729-%E5%BD%B1%E8%AF%84-%E6%94%BB%E5%A3%B3%E6%9C%BA%E5%8A%A8%E9%98%9F/:0:0","tags":["影评","科幻"],"title":"攻壳机动队 Ghost in the Shell 影评","uri":"/20170729-%E5%BD%B1%E8%AF%84-%E6%94%BB%E5%A3%B3%E6%9C%BA%E5%8A%A8%E9%98%9F/"},{"categories":["生活"],"content":" 作为一个20多岁的男人，没有经历过恋爱和爱情，自然也没有孩子。 但是作为曾经是一个无知，愚蠢，懦弱孩子的我， 也许更加深知一个孩子在怎样的成长道路上行进是何等的重要。 假使我有了孩子，我将会更加敏感，敏感气温的变化，及时提醒他增减衣物，因为我的父母总是这样做。 假使我有了孩子，我将从他张开双眼的那天起，培养自己良好的习惯，痛改自己的不良习惯和嗜好，因为他在模仿。 假使我有了孩子，我将会从他对声音有一丝的反应开始，更加注意自己的言谈举止，更加礼貌待人，因为他在倾听。 假使我有了孩子，我将会更加珍惜宝贵的时间，会对无意义的事情说不。因为我伴随他的时间和他的童年一样短暂。 假使我有了孩子，我将不会对某件事过多评论，更不会对某件事轻易对他灌输某种思想，因为他的思想更重要。 假使我有了孩子，我将更加坚持原则，没有底线的人是可怕的人，即使有时不容易，但我不想他变的可怕。 假使我有了孩子，我将会加倍努力的工作，打理好日常一切事物，因为他需要一个温馨和谐的家。 无论他是男是女，是胖或瘦，是亲生亦或领养，我将祝福他的降临和成长。 ","date":"2017-06-22","objectID":"/20170622-%E5%81%87%E4%BD%BF%E6%88%91%E6%9C%89%E4%BA%86%E5%AD%A9%E5%AD%90/:0:0","tags":["情感"],"title":"假使我有了孩子","uri":"/20170622-%E5%81%87%E4%BD%BF%E6%88%91%E6%9C%89%E4%BA%86%E5%AD%A9%E5%AD%90/"},{"categories":["Python"],"content":"platform import platform # 获取操作系统的位数 print('architecture: ', platform.architecture()) # architecture: ('64bit', 'ELF') # 计算机类型/CPU架构 print('machine: ', platform.machine()) # machine: x86_64 aarch64 print('system:', platform.system()) # Linux # 获取Linux内核版本 print('platform: ', platform.platform()) # Linux-5.4.0-42-generic-x86_64-with-glibc2.29 print('version: ', platform.version()) # #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 # 计算机的网络名称 print('node: ', platform.node()) # idea570 # 计算机处理器信息 print('processor', platform.processor()) # processor x86_64 print('uname: ', platform.uname()) # uname_result(system='Linux', node='idea570', release='5.4.0-42-generic', version='#46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020', machine='x86_64', processor='x86_64') print(platform.python_build()) # ('default', 'Jul 16 2020 14:00:26') print(platform.python_compiler()) # GCC 9.3.0 print(platform.python_branch()) # python 解释器实现 print(platform.python_implementation()) # CPython print(platform.python_revision()) print(platform.python_version_tuple()) # ('3', '8', '2') lsb_release import lsb_release lsb_info = lsb_release.get_distro_information() print(lsb_info) # {'ID': 'Ubuntu', 'DESCRIPTION': 'Ubuntu 20.04.1 LTS', 'RELEASE': '20.04', 'CODENAME': 'focal'} print('ID: ', lsb_info.get('ID')) # ID: Ubuntu print('RELEASE: ', lsb_info.get('RELEASE')) # RELEASE: 20.04 print('DESCRIPTION: ', lsb_info.get('DESCRIPTION')) # DESCRIPTION: 'Ubuntu 20.04.1 LTS print('CODENAME: ', lsb_info.get('CODENAME')) # CODENAME: focal 密码哈希 from passlib.apps import custom_app_context as pwd_context password = pwd_context.encrypt('password') print(password, len(password)) # $6$rounds=656000$Q.AXo68BhIXq7LnM$bldegF6rHZ5Gi7ujPnXHOAdnAvC8srNImdIFQ9DcBWx7aF0sCWn/HryRIbyh6nuyhD3Trp.y2Sb6yVEyHsWCS1 120 result = pwd_context.verify('password', password) print(result) # True selenium 登陆测试 import time from selenium import webdriver browser = webdriver.Firefox(executable_path='/opt/geckodriver') browser.get('http://127.0.0.1:8080') name_input = browser.find_element_by_xpath(\"//*[@type='text']\") # 找到用户名的框框 pass_input = browser.find_element_by_xpath(\"//*[@type='password']\") # 找到输入密码的框框 login_button = browser.find_element_by_class_name('loginButton') # 找到登录按钮 name_input.clear() name_input.send_keys('admin') # 填写用户名 time.sleep(0.2) pass_input.clear() pass_input.send_keys('password') # 填写密码 time.sleep(0.2) login_button.click() # 点击登录 c = browser.context() print(c) ","date":"2017-06-20","objectID":"/20170620-pythoncookbook/:0:0","tags":["platform","lsb_release","python","passlib","selenium","密码哈希","snippet","xpath","HMAC"],"title":"Python CookBook","uri":"/20170620-pythoncookbook/"},{"categories":["Python"],"content":"删除字典值为空的元素 dict(filter(lambda x: x[1] != ‘’, dic.items())) - postgresql connect ```python import psycopg2 conn = psycopg2.connect(database='', user='', password=, host='', port=5432) cur = conn.cursor() # select query = 'select * from public.test where id=%(id)s' query_dict = {'id': id} cur.execute(query,query_dict) row = cur.fetchone() # insert pickle with open(\"test.txt\", 'wb+') as f: pickle.dump(test.txt, f) with open(\"test.txt\", 'rb+') as f: text = pickle.load(f) PIL 显示图片流 from PIL import Image import io stream = io.BytesIO(pic.content) img = Image.open(stream) # img = Image.open(\"pic.jpg\") img.show() img.close() socket5 proxy # socket5 proxy: # import copy import socks import socket defaultSocket = copy.copy(socket.socket) # proxy switch socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, \"127.0.0.1\", 1080) # socket.socket = socks.socksocket RE import re find_string = re.findall(r\"\u003cp\u003e(.*?)\u003c/p\u003e\" ,text_string) Requests CookieJar Dict type conversion cookies = requests.utils.dict_from_cookiejar(r.cookies) cookies = requests.utils.cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True) s = requests.Session() s.cookies = cookies # 两个list 合并为一个字典 a = [1, 2, 3] b = [a, b, c] d = dict(zip(a, b)) # {1:a,2:b,3:c} Chrome Cookie 字符串转字典 def chrome_cookie_to_dict(str): cookie = {} f = str.strip('Cookie:').strip('\\n').split(';') for line in f: name, value = line.strip().split('=') cookie[name] = value return cookie if __name__ == '__main__': str = 'Cookie:SESSION_COOKIE=3cab1829cea36ddbceb17f7e; JSESSIONID=E2EE5E944C1E82BE0B26613F3D9A9AAB' chrome_cookie_to_dict(str) # {'SESSION_COOKIE': '3cab1829cea36ddbceb17f7e', 'JSESSIONID': 'E2EE5E944C1E82BE0B26613F3D9A9AAB'} OptionParser 命令行选项解析器, 应用场景:(命令行选项, 帮助说明) from optparse import OptionParser, OptionError usage = 'usage: %prog [options] xxx' description = HandlerClass.__doc__ parser = OptionParser(usage=usage, description=description) parser.add_option('-a', dest='address', help='host address', default='127.0.0.1') parser.add_option('-p', dest='port', help='port number', default=8080) try: (options, args) = parser.parse_args() except OptionError: sys.exit(2) except OptionError: print('No option input') sys.exit(2) importlib模块动态加载 应用场景: 组件可插拔(fully pluggable) import importlib module = importlib.import_module(module_name) HMAC password generator demo import hashlib import hmac import base64 def hmac_password(message, salt, digestmod=hashlib.sha256): \"\"\" digestmod:always_supported:'md5','sha1','sha224','sha256','sha384','sha512'. :param message: :param salt: :param digestmod: :return: hmac password \"\"\" message = message.encode() salt = salt.encode() signature = base64.b64encode(hmac.new(salt, message, digestmod=digestmod) .digest()) return signature if __name__ == '__main__': m = hmac_password('secret info', 'random sring') print(m.decode()) Stmp SSL Mail. import smtplib import email.mime.multipart import email.mime.text from_mail = '' from_mail_password = '' to_mail = '' mail_subject = 'test' mail_content = ''' 这是一封自动发送的邮件. ''' stmp_host = 'smtp.exmail.qq.com' stmp_port = '465' def SMTP_SSL(): \"\"\" Send mail. :return: (250, b'Ok') \"\"\" msg = email.mime.multipart.MIMEMultipart() msg['from'] = from_mail msg['to'] = to_mail msg['subject'] = mail_subject content = mail_content txt = email.mime.text.MIMEText(content) msg.attach(txt) smtp = smtplib.SMTP_SSL(stmp_host, stmp_port) smtp.login(from_mail, from_mail_password) # smtp.set_debuglevel(1) smtp.sendmail(from_mail, to_mail, str(msg)) return smtp.noop() if __name__ == '__main__': print(SMTP_SSL()) 通过网卡名获取ip地址 # 方法1： 使用 netifaces 库 # pip3 install netifaces ip_address = ifaddresses(netcard_name)[AF_INET][0]['addr'] # 方法2： my_addr = os.popen( \"ifconfig | grep -A 1 %s|tail -1| awk '{print $2}'\" % netcard_name).read() ip_address = re.search( r'(?\u003c![\\.\\d])(?:25[0-5]\\.|2[0-4]\\d\\.|[01]?\\d\\d?\\.)'r'{3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)(?![\\.\\d])', my_addr).group() ","date":"2017-06-20","objectID":"/20170620-pythoncookbook/:0:1","tags":["platform","lsb_release","python","passlib","selenium","密码哈希","snippet","xpath","HMAC"],"title":"Python CookBook","uri":"/20170620-pythoncookbook/"},{"categories":["算法"],"content":"问题: 阿里九游开放平台近日上架了一款新的益智类游戏——成三棋。成三棋是我国非常古老的一个双人棋类游戏. 成三棋的棋盘上有很多条线段，只能在线段交叉点上放入棋子。我们可以用坐标系来描述棋盘. 如果一条线段上的三个交叉点都被同一玩家的棋子占据的话，则称这条线段被该玩家 成三。现在，小红和小明两人在游戏平台上下棋，其中小红的棋子是黑色的。请你帮小红计算他成三的线段数。 样例对应的棋盘如下： 输入 输入第一行两个整数 (n,m(3 \\le n, m \\le 9))，n表示小红的棋子数，m表示小明的棋子数。 接下来 n行输入小红的棋子坐标。 接下来 m行输入小明的棋子坐标。 输入保证坐标合法，并且棋子之间不重合。 6 3 -1 0 -2 0 -3 0 -1 -1 -1 1 1 0 0 2 0 3 2 2 样例输出 # 输出小红成三的线段数。 2 题解 按一定规则对成三棋盘进行扫描，应避免某些坐标点漏扫或重复扫描． x ,y = [int(x) for x in str(input()).split()] R = [] for m in range(x): mx,my = [int(x) for x in str(input()).split()] R.append(tuple((mx,my))) num = 0 for x in range(-3,4): if len(set(R) \u0026 set([(x,0)])) \u003e 0: # 正方形竖边 if (x,x) in R and (x,-x) in R: num += 1 # X正半轴 if x==2 and (x+1,0) in R and (x-1,0) in R: num += 1 # X负半轴 if x==-2 and (x+1,0) in R and (x-1,0) in R: num += 1 if len(set(R) \u0026 set([(0,x)])) \u003e 0: # 正方形横边 if (x,x) in R and (-x,x) in R: num += 1 # Y正半轴 if x == 2 and (0, x+1) in R and (0, x-1) in R: num += 1 # Y负半轴 if x == -2 and (0, x+1) in R and (0, x-1) in R: num += 1 print(num) ","date":"2017-06-19","objectID":"/20170728-2017%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%E5%88%9D%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%98%BF%E9%87%8C%E7%9A%84%E6%96%B0%E6%B8%B8%E6%88%8F%E9%A2%98%E8%A7%A3/:0:0","tags":["算法","python","模拟"],"title":"2017 计蒜之道 初赛 第一场 阿里的新游戏 题解","uri":"/20170728-2017%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%E5%88%9D%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%98%BF%E9%87%8C%E7%9A%84%E6%96%B0%E6%B8%B8%E6%88%8F%E9%A2%98%E8%A7%A3/"},{"categories":["Python"],"content":"demo #更新： 新版本引入etree模块方式 from lxml import html etree = html.etree tree = etree.HTML(\"\") html = ''' \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle class=\"sub_title\"\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"none\"\u003e \u003ca href =\"#\"\u003eSpaceack's code\u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"link\"\u003e \u003ca href =\"http://spaceack.com\"\u003eSpaceack's blog\u003c/a\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ''' from lxml import etree tree = etree.HTML(html) # 获取class为link的a标签的元素内容 a_content = tree.xpath('.//div[@class=\"link\"]/a/text()') print(a_content) # [\"Spaceack's blog\"] # 使用attrib获取标签的属性值 href_element = tree.xpath('.//div[@class=\"link\"]/a') print(href_element) # [\u003cElement a at 0x7ff3571a4d80\u003e] href = href_element[0].attrib.get('href') print(href) # http://spaceack.com ","date":"2017-06-19","objectID":"/20170619-python%E4%BD%BF%E7%94%A8lxml%E6%8F%90%E5%8F%96xml%E6%95%B0%E6%8D%AE/:0:0","tags":["python","xpath","lxml","数据采集"],"title":"使用lxml提取HTML/XML 数据","uri":"/20170619-python%E4%BD%BF%E7%94%A8lxml%E6%8F%90%E5%8F%96xml%E6%95%B0%E6%8D%AE/"},{"categories":["Python"],"content":"获取标签元素内容为空的两种不同效果: demo from lxml import etree # 可见第二个标签 td 元素内容为空 tree = etree.HTML(\"\u003cth\u003e水果\u003c/th\u003e\u003ctd\u003e苹果\u003c/td\u003e\u003cth\u003e价格\u003c/th\u003e\u003ctd\u003e\u003c/td\u003e\") key = tree.xpath(\"//th/text()\") value = tree.xpath(\"//td/text()\") print(key, value) ''' ['水果', '价格'] ['苹果'] ''' 如果想让价格使用None或空字符串''来占位，可以这样做: key = tree.xpath(\"//th\") value = tree.xpath(\"//td\") key = [item.text for item in key] value = [item.text for item in value] print(key, value) ''' ['水果', '价格'] ['苹果', None] ''' key = [\"\" if item.text==None else item.text for item in key] value = [\"\" if item.text==None else item.text for item in value] print(key, value) ''' key ['水果'， '价格'] ['水果', '价格'] ['苹果', ''] ''' ","date":"2017-06-19","objectID":"/20170619-python%E4%BD%BF%E7%94%A8lxml%E6%8F%90%E5%8F%96xml%E6%95%B0%E6%8D%AE/:0:1","tags":["python","xpath","lxml","数据采集"],"title":"使用lxml提取HTML/XML 数据","uri":"/20170619-python%E4%BD%BF%E7%94%A8lxml%E6%8F%90%E5%8F%96xml%E6%95%B0%E6%8D%AE/"},{"categories":null,"content":"关于我 我热爱计算机，崇尚 黑客文化, 渴望Geek生活, 希望成为一只理想的程序猿, 终身学习者(perpetual learner). 希望能做有意义的事，做一个有追求的人。 即对爱的渴望，知识的渴求, 苦难的理解 —— by罗素《三种激情》 喜爱KISS原则， 复杂系统也令人着迷。 ","date":"2017-06-18","objectID":"/about/:0:0","tags":null,"title":"about","uri":"/about/"},{"categories":null,"content":"技术栈 9年GNU/Linux操作系统经验(Ubuntu) 常用语言: Python，Go Language web框架: FastApi, Flask, Django, Tornado, 熟悉一定的web 前端开发 数据库: Postgresql, Mysql, Redis, MongoDB 容器：Docker 中间件: gRPC, RabbitMQ web数据采集(垂直型爬虫)，数据清洗 数据分析初学者 大数据相关: 了解 Hadoop MapReduce 计算模型， Hive，HDFS 网络安全相关: Wireshark数据抓包与分析，数据隐写 etc. 微信小程序开发 生命数计算器: 其它工具: Pycharm, Sublime, Markdown/Moeditor, Git, Nmap, Vim, Postman, Fiddler, FreeMind/Xmind Remarkjs/pydown etc. CAD: SweetHome3D ","date":"2017-06-18","objectID":"/about/:0:1","tags":null,"title":"about","uri":"/about/"},{"categories":null,"content":"关于博客 博客用于生活，计算机技术的积累与分享。 有所积累，有所遗忘，有所成长。 Now 迁移到 Github Hugo 2020 Hexo 2018 Pelican 2017 Tornado Blog, Mongodb, BootStrap, Mardown渲染， 代码高亮，MathJax Tex公式渲染 2016 Django girls Blog ","date":"2017-06-18","objectID":"/about/:0:2","tags":null,"title":"about","uri":"/about/"},{"categories":null,"content":"联系方式 Email: spaceack@qq.com ","date":"2017-06-18","objectID":"/about/:0:3","tags":null,"title":"about","uri":"/about/"},{"categories":["Java"],"content":"Java 文档下载 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:0:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"使用集成开发环境 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:1:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Eclipse 新建项目 File-New-Project 对话框中选择Java Project 点击Finish ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:1:1","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Virtual Studio Code 安装扩展包Java Extension Pack Ctrl-Shift-D 根据提示生成launch.json配置文件 F5运行程序 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:1:2","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"第一段Java程序 // Welcome/Welcome.java public class Welcome{ public static void main(String [] args){ String greeting = \"Welcome to Spaceack's blog\"; System.out.println(greeting); for(int i=0; i\u003cgreeting.length(); i++) System.out.print(\"=\"); System.out.println(); } } 程序解读 关键字public称为访问修饰符（access modifier）用于控制程序其它部分对这段代码的访问级别。 关键字class表明Java程序中的全部内容都包含在类中。 class后面是类名，命名规范类名首字母大写，建议使用骆驼命名法。 源代码的文件名需与公共类名相同，并用.java作为扩展名。 main方法必须声明为public Java中所有的函数都属于某个类的方法，因此main方法必须有一个外壳类。每个Java应用程序都必须有一个main方法, 声明格式： public class ClassName{ public static void main(String[] args){ program statements } } void表示这个方法没有返回值。如果main方法正常退出，Java应用程序退出代码为0。若想终止程序时返回其他代码，需要调用System.exit方法。 每个程序块使用{}括号包裹，每条语句使用;分号结束。 输出语句使用了System.out对象，并调用了println方法。 .点号用于调用方法，通用语法为object.method(parameters) ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:2:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"易错点 需要注意大小写， 类名首字母大写 Welcome 编译时只需指定类名javac Welcome,不要带扩展名.java或.javac ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:2:1","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"注释 单行注释// 多行注释/* */ 文档注释/** */ 可以生成文档 /** * This is the first sample program * @version 1.0 2016-09-03 * @author Spaceack * / ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:3:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"数据类型 Java中规定8种基本类型（primitive type）4种整型，2种浮点型，1种表示Unicode编码的字符型，和一种表示真值的boolean类型。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:4:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Java整型 类型 存储 取值 科学 byte 1字节 -128~127 2^7 short 2字节 -32768~32767 2^15 int 4字节 -2147483648～2147483647（错过20亿） 2^31 long 8字节 -9223372036854775808~9223372036854775807 2^63 长整型数值有一个后缀L或l(4000000000L) 十六进制数值有一个前缀0x或0X(0xCAFE) 八进制有个前缀0（010 表示对应八进制中的8） 二进制数值前缀0b或0B（0b1001就是9） 数字字面量加入下划线使之更易读：1_000_000（0b1111_0100_0010_0100_0000）表示一百万。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:4:1","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"浮点类型 类型 存储 取值 float 4字节 约 ±3.40282347E+38F(有效位数6～7位) double 8字节 约 ±1.79769313486231570E+308(有效位数15位) float类型的数值有一个后缀f或F。没有后缀的浮点数默认为double类型 表示溢出和出错情况的三个特殊的浮点数值 正无穷大，对应常量Double.POSITIVE_INFINITY 负无穷大,Double.NEGATIVE_INFINITY NaN, Double.NaN eg: 一个正整数除0的结果为正无穷大。计算0/0或者负数平方根的结果为NaN。 使用Double.isNaN()方法判断是否等于Double.NaN。 浮点数值表示使用二进制系统表示，会有误差。金融计算应使用BigDecimal类。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:4:2","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"char类型 使用单引号''包裹,例如'A'是编码值为65所对应的字符常量。与被双引号包裹的\"A\"不同，它是包含一个字符A的字符串。 char类型可以表示十六进制值，范围从\\u0000到\\Uffff。例如\\u2122表示注册符号™,\\u03C0表示希腊字母π。 转义序列\\u可以出现在加引号的字符常量或字符串之外（其他转义序列不可以）例如 \\u005B\\u005D是[]的编码。 public static void main(String \\u005B\\u005D args) 其它特殊字符转义序列 转义序列 名称 Unicode值 \\b 退格 \\u0008 \\t 制表 \\u0009 \\n 换行 \\u000a \\r 回车 \\u000d \\\" 双引号 \\u0022 \\' 单引号 \\u0027 // 反斜杠 \\u005c System.out.println(\"\\u0022+\\u0022\");的输出会是\"\"吗？不是的， 会输出一个空字符串 。 需要小心注释中的\\u, // Look inside c:\\users 会产生语法错误，因为\\u后面并未跟着4个十六进制数。 Unicode 码点（code point）: 指与一个编码表中的某个字符对应的代码值。 在Unicode标准中，码点采用16进制书写，并加上前缀U+,egU+0041是A的码点。 Unicode码点可以分成17个代码级别（code plane）。第一个代码级别称为基本的多语言级别(basic multilingual plane)， 码点从U+0000到U+FFFF,包括经典的Unicode代码。其余的16个级别码点从U+10000到U+10FFFF，包括一些辅助字符（supplementary character） UTF-16编码采用不同长度的编码表示所有的Unicode码点。在基本的多语言级别中每个字符用16位表示，通常被称为代码单元（code unit）。辅助字符采用一对连续的代码单元进行编码。这样构成的编码值落入基本的多语言级别中空闲的2048字节内，通常被称为替代区域（surrogate area）。 在Java中，char类型描述了UTF-16编码中的一个代码单元。 强烈建议不要在程序中使用char类型。建议使用字符串作为抽象数据类型处理。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:4:3","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"boolean类型 boolean类型有两个值：false和true,用来判定逻辑条件。 整型和布尔值之间不能相互转换。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:4:4","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"变量 Java中每个变量都有1个类型（type）,在声明变量时，变量的类型位于变量之前。以分号结束。 可以使用任何有意义的Unicode字符组成变量名。若想知道该Unicode字符是否可以用作变量名，可以使用Character类的isJavaIdentifierStart和isJavaIdentifierPart方法来检查。 不要使用$字符，它只用在Java编译器或其它工具生成的名字中。 建议逐一声明（各一行）可以提高程序的可读性。 变量名建议小写字母，多个单词组成的变量名从第二个单词开始首字母大写。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:5:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"变量初始化 声明变量后，必须使用赋值语句对变量显式初始化。 变量的声明尽可能地靠近变量第一次使用的地方。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:5:1","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"常量 利用关键字final指示常量。eg: final int MAX_SIZE = 25; 关键字static final可以设置一个类常量，允许一个类中的多个方法使用,常量还被声明为public， 其它的类也可以使用这个类常量： public static final int MAX_SIZE = 25; 被赋值后不能再更改。 建议常量名使用全大写。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:5:2","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"运算符 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:6:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"算术运算符 符号 含义 使用 例子 + 加 - 减 * 乘 / 除 操作数都是整数时，表示整数除法，否则表示浮点数除法 50/2=7, 15.0/2=7.5 % 求余(取模) 15%2=1 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:6:1","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"数学函数 double x = 4; // sqrt方法 求平方根 double y = Math.sqrt(x); // 2.0 // pow方法 指数运算 y的x次方 double p = Math.pow(y, x) //16.0 // foorMod方法 取模运算 double m = Math.floorMod(4, 3) //1.0 // 使用静态导入，调用时省略Math import static java.lang.Math; System.out.println(PI); double s = sin(toRadians(30)); System.out.println(PI); ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:6:2","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"类型转换 虚箭头转换可能会有精度损失 两个操作数，需要转换为同一类型才能运算。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:6:3","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"强制类型转换 使用圆括号()包裹要转换的目标类型，后面紧跟需要变换的变量名。 double x = 6.66; int nv = (int) x; // 6 截断小数部分变为整型。 int rv = (int) Math.round(x); // 7 使用round 进行舍入运算，round返回类型为long int x = 0; x += 3.5; // 3 // 会执行强制转换，实际为(int)（x + 3.5） ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:6:4","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"自增运算符 “后缀”形式 int n = 2; int b = 2 * m++; // n is 3, b is 4; “前缀”形式, 先加1。 int m = 2; int a = 2 * ++m; // m is 3, a is 6 建议不在表达式中使用++，会让人迷惑。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:6:5","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"关系和布尔运算符 符号 含义 举例 == 相等 != 不相等 \u003c 小于 \u003e 大于 \u003c= 小于等于 \u003e= 大于等于 \u0026\u0026 逻辑与 ` ` ? : 三元操作符 condition ? expression1 : expression2 \u0026\u0026与|| 按照短路方式来求值 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:6:6","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"位运算符 符号 含义 举例 \u0026 and ` ` or ^ xor ~ not \u003e\u003e 左移 \u003c\u003c 右移 \u0026与| 不按照短路方式来求值 使用掩码技术可以得到整数中的各个位。 int n = 0b10000; int fourthBitFromRight = (n \u0026 0b1000) / 0b1000; // 0 int n = 0b11000; int fourthBitFromRight = (n \u0026 0b1000) / 0b1000; // 1 int n = 0b10000; int fourthBitFromRight = (n \u0026 (1\u003c\u003c3)) \u003e\u003e3; // 0 int n = 0b11000; int fourthBitFromRight = (n \u0026 (1\u003c\u003c3)) \u003e\u003e3; // 1 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:6:7","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"括号与运算符级别 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:6:8","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"枚举类型 enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE}; Size s = Size.MEIUM; ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:6:9","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"字符串 Java字符串就是Unicode字符序列。 JAVA没有内置的字符串类型，而是使用标准库中的一个预定义类。 每个由双引号括起来的字符串都是String类的一个序列。 String name = \"Spaceack\"; ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:7:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"子串 使用substring方法提取子串 String name = \"Spaceack\"; String subs = name.substring(0,5); //\"Space\" - 子串长度 即 5-0 = 5 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:7:1","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"拼接 使用+号 拼接两个字符串 多个字符串使用某个定界符连接，可以使用join静态方法 String all = String.join(\"-\", \"2016\", \"10\", \"01\"); //2016-10-01 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:7:2","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"不可变字符串 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:7:3","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"检测字符串相等 不要使用== 检测字符串相等。 使用equals方法s.equals(t), 相等返回true, 否则返回false equalsIgnoreCase方法，不区分大小写。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:7:4","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"空串与Null串 空串是长度为0的字符串。 使用 if (str.length() == 0) 或 str.equals(\"\")检测。 使用if (str == null)检测Null串 使用if (str != null \u0026\u0026 str.length() != 0 ) 检测字符串既不是null, 也不为空串。 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:7:5","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"码点与代码单元 length方法返回采用UTF-16编码表示的给定字符串所需要的代码单元数量 String name = \"Spaceack👽\"; int n = name.length();// 10 获取实际长度，即码点数量，可调用： int cpCount = name.codePointCount(0, name.length()); // 9 s.charAt(n) 返回位置n的代码单元，n介于0~s.length() - 1 之间 char first = name.charAt(0); // S char last = name.charAt(9); // ? 得到第i个码点，可调用： int i = 8; int index = name.offsetByCodePoints(0, i); int cp = name.codePointAt(index); // 8128125 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:7:6","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"输入输出 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:8:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"控制流程 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:9:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"大数值 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:10:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"数组 ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:11:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"术语 码点（code point）: 指与一个编码表中的某个字符对应的代码值。 面向对象程序设计（Object-Oriented Programming, OOP） lambda表达式（lambda expression） 异常处理（excepion handling） 抽象窗口工具包（abstract window toolkit, AWT） ","date":"2016-09-03","objectID":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/:12:0","tags":["Java"],"title":"Java学习笔记-基本程序设计结构","uri":"/20160903-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"后台管理改为中文 # 将 setting.py 配置选项设置为中文 LANGUAGE_CODE = 'en-us' TIME_ZONE = 'UTC' LANGUAGE_CODE = 'zh-Hans' TIME_ZONE = 'Asia/Shanghai' ","date":"2016-03-05","objectID":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/:1:0","tags":["Django"],"title":"Django-通过示例定制admin后台管理","uri":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"更改后台标题和名称（title/header） # admin.py 文件添加 修改网页title和站点header admin.site.site_header = 'XXX平台-管理系统' admin.site.site_title = 'XXX平台' ","date":"2016-03-05","objectID":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/:2:0","tags":["Django"],"title":"Django-通过示例定制admin后台管理","uri":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"创建Admin 超级管理员账号 python manage.py createsuperuser ","date":"2016-03-05","objectID":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/:3:0","tags":["Django"],"title":"Django-通过示例定制admin后台管理","uri":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"将数据表添加到站点管理 在settings.py文件,INSTALLED_APPS 加入该app. 定义模型写入models.py from django.db import models lass Question(models.Model): question_text = models.CharField('问题描述',max_length=200) pub_date = models.DateTimeField('发布日期') 在该app目录的admin.py文件下注册 from django.contrib import admin from .models import Question class QuestionAdmin(admin.ModelAdmin): pass admin.site.register(Question, QuestionAdmin) ","date":"2016-03-05","objectID":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/:4:0","tags":["Django"],"title":"Django-通过示例定制admin后台管理","uri":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"更改APP的名称 写入该app的__init__文件,更改默认配置。 from django.apps import AppConfig default_app_config = 'polls.PollsConfig' class PollsConfig(AppConfig): name = 'polls' verbose_name='投票' ","date":"2016-03-05","objectID":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/:5:0","tags":["Django"],"title":"Django-通过示例定制admin后台管理","uri":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"更改Model模型名称 class Question(models.Model): # 在该模型定义加入内嵌类定义元数据👇 class Meta: verbose_name = '问题' verbose_name_plural = verbose_name question_text = models.CharField('问题描述',max_length=200) pub_date = models.DateTimeField('发布日期') ","date":"2016-03-05","objectID":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/:6:0","tags":["Django"],"title":"Django-通过示例定制admin后台管理","uri":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"数据记录对象以字段显示 写入 admin.py 下的 QuestionAdmin类： list_display = ('question_text', 'pub_date') ","date":"2016-03-05","objectID":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/:7:0","tags":["Django"],"title":"Django-通过示例定制admin后台管理","uri":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"增加按照时间的过滤器 list_filter = ['pub_date'] ","date":"2016-03-05","objectID":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/:8:0","tags":["Django"],"title":"Django-通过示例定制admin后台管理","uri":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"增加按照问题描述的模糊搜索 search_fields = ['question_text'] ","date":"2016-03-05","objectID":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/:9:0","tags":["Django"],"title":"Django-通过示例定制admin后台管理","uri":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"增加显示详细日期的筛选模块 date_hierarchy = 'pub_date' ","date":"2016-03-05","objectID":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/:10:0","tags":["Django"],"title":"Django-通过示例定制admin后台管理","uri":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"图像预览显示 ","date":"2016-03-05","objectID":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/:11:0","tags":["Django"],"title":"Django-通过示例定制admin后台管理","uri":"/20160305-djangoadmin%E6%89%A9%E5%B1%95/"},{"categories":["Python"],"content":"DATABASES 模板 ## DATABASES ### sqlite3 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), } } ### mysql DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'mydb', #数据库名称(需要先创建) 'USER': 'root', # 数据库用户名 'PASSWORD': '123456', # 数据库密码 'HOST': '', # 数据库主机，留空默认为localhost 'PORT': '3306', # 数据库端口 } } ### Postgresql DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'mydb', # 数据库名字(需要先创建) 'USER': 'postgres', # 登录用户名 'PASSWORD': '123456', # 密码 'HOST': '', # 数据库IP地址,留空默认为localhost 'PORT': '5432', # 端口 } } ","date":"2016-03-02","objectID":"/20160302-django%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:1:0","tags":["Django"],"title":"Django常用配置-setting.py 模板","uri":"/20160302-django%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["Python"],"content":"Internationalization 模板 LANGUAGE_CODE = 'zh-Hans' TIME_ZONE = 'Asia/Shanghai' ","date":"2016-03-02","objectID":"/20160302-django%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:2:0","tags":["Django"],"title":"Django常用配置-setting.py 模板","uri":"/20160302-django%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["Python"],"content":"Static files 配置模板 STATIC_URL = '/static/' MEDIA_URL = '/media/' MEDIA_ROOT = os.path.join(BASE_DIR, \"media\") ","date":"2016-03-02","objectID":"/20160302-django%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:3:0","tags":["Django"],"title":"Django常用配置-setting.py 模板","uri":"/20160302-django%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["Python"],"content":"LOGGING 模板 BASE_LOG_DIR = os.path.join(BASE_DIR, \"log\") LOGGING = { 'version': 1, # 保留字 'disable_existing_loggers': False, # 禁用已经存在的logger实例 # 日志文件的格式 'formatters': { # 详细的日志格式 'standard': { 'format': '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' '[%(levelname)s][%(message)s]' }, # 简单的日志格式 'simple': { 'format': '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s' }, # 定义一个特殊的日志格式 'collect': { 'format': '%(message)s' } }, # 过滤器 'filters': { 'require_debug_true': { '()': 'django.utils.log.RequireDebugTrue', }, }, # 处理器 'handlers': { # 在终端打印 'console': { 'level': 'DEBUG', 'filters': ['require_debug_true'], # 只有在Django debug为True时才在屏幕打印日志 'class': 'logging.StreamHandler', # 'formatter': 'simple' }, # 默认的 'default': { 'level': 'INFO', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件，自动切 'filename': os.path.join(BASE_LOG_DIR, \"xxx_info.log\"), # 日志文件 'maxBytes': 1024 * 1024 * 50, # 日志大小 50M 'backupCount': 3, # 最多备份几个 'formatter': 'standard', 'encoding': 'utf-8', }, # 专门用来记错误日志 'error': { 'level': 'ERROR', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件，自动切 'filename': os.path.join(BASE_LOG_DIR, \"xxx_err.log\"), # 日志文件 'maxBytes': 1024 * 1024 * 50, # 日志大小 50M 'backupCount': 5, 'formatter': 'standard', 'encoding': 'utf-8', }, # 专门定义一个收集特定信息的日志 'collect': { 'level': 'INFO', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件，自动切 'filename': os.path.join(BASE_LOG_DIR, \"xxx_collect.log\"), 'maxBytes': 1024 * 1024 * 50, # 日志大小 50M 'backupCount': 5, 'formatter': 'collect', 'encoding': \"utf-8\" } }, 'loggers': { # 默认的logger应用如下配置 '': { 'handlers': ['default', 'console', 'error'], # 上线之后可以把'console'移除 'level': 'DEBUG', 'propagate': True, # 向不向更高级别的logger传递 }, # 名为 'collect'的logger还单独处理 'collect': { 'handlers': ['console', 'collect'], 'level': 'INFO', } }, } ","date":"2016-03-02","objectID":"/20160302-django%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:4:0","tags":["Django"],"title":"Django常用配置-setting.py 模板","uri":"/20160302-django%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["Python"],"content":"CKEDITOR_5 模板 CKEDITOR_5_CUSTOM_CSS = 'path_to.css' # optional CKEDITOR_5_CONFIGS = { 'default': { 'toolbar': ['heading', '|', 'bold', 'italic', 'link', 'bulletedList', 'numberedList', 'blockQuote', 'imageUpload', ], }, 'extends': { 'blockToolbar': [ 'paragraph', 'heading1', 'heading2', 'heading3', '|', 'bulletedList', 'numberedList', '|', 'blockQuote', 'imageUpload' ], 'toolbar': ['heading', '|', 'outdent', 'indent', '|', 'bold', 'italic', 'link', 'underline', 'strikethrough', 'code', 'subscript', 'superscript', 'highlight', '|', 'bulletedList', 'numberedList', 'todoList', '|', 'blockQuote', 'imageUpload', '|', 'fontSize', 'fontFamily', 'fontColor', 'fontBackgroundColor', 'mediaEmbed', 'removeFormat', 'insertTable', ], 'image': { 'toolbar': ['imageTextAlternative', 'imageTitle', '|', 'imageStyle:alignLeft', 'imageStyle:full', 'imageStyle:alignRight', 'imageStyle:alignCenter', 'imageStyle:side', '|'], 'styles': [ 'full', 'side', 'alignLeft', 'alignRight', 'alignCenter', ] }, 'table': { 'contentToolbar': ['tableColumn', 'tableRow', 'mergeTableCells'] }, 'heading': { 'options': [ {'model': 'paragraph', 'title': 'Paragraph', 'class': 'ck-heading_paragraph'}, {'model': 'heading1', 'view': 'h1', 'title': 'Heading 1', 'class': 'ck-heading_heading1'}, {'model': 'heading2', 'view': 'h2', 'title': 'Heading 2', 'class': 'ck-heading_heading2'}, {'model': 'heading3', 'view': 'h3', 'title': 'Heading 3', 'class': 'ck-heading_heading3'} ] } } } ","date":"2016-03-02","objectID":"/20160302-django%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/:5:0","tags":["Django"],"title":"Django常用配置-setting.py 模板","uri":"/20160302-django%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"categories":["Linux"],"content":"centos系 网卡配置路径 `/etc/sysconfig/network-scripts/` 配置示列 ifcfg-enp0s3 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=enp0s3 UUID=xxxxxx-xxxx-xxxx-xxxx-xxxxxxx DEVICE=enp0s3 ONBOOT=yes IPADDR=192.168.0.200 PREFIX=24 GATEWAY=192.168.0.1 DNS1=8.8.8.8 IPV6_PRIVACY=no BOOTPROTO 静态IP(static) or 动态IP(dhcp) ONBOOT 网卡随系统启动激活 PREFIX 新版本Linux 配置子网掩码的参数 等价于 NETMASK NETMASK=255.255.255.0 重启网络服务 systemctl restart network ","date":"2015-03-03","objectID":"/20150303-linux%E7%BD%91%E7%BB%9C/:0:1","tags":["Linux","网络"],"title":"Linux 网络","uri":"/20150303-linux%E7%BD%91%E7%BB%9C/"},{"categories":["Linux"],"content":"ubuntu系 网卡配置路径 17.10 后 废弃 /etc/network/interfaces 桌面版 NetworkManager /etc/NetworkManager/system-connections Netplan configuration netplan examples /etc/netplan/config.yaml ","date":"2015-03-03","objectID":"/20150303-linux%E7%BD%91%E7%BB%9C/:0:2","tags":["Linux","网络"],"title":"Linux 网络","uri":"/20150303-linux%E7%BD%91%E7%BB%9C/"},{"categories":["Java"],"content":" 安装多个jdk版本 sudo yum install java-1.8.0-openjdk-devel sudo yum install java-11-openjdk-devel 查看当前默认版本 java -version 切换默认版本 sudo alternatives --config java ","date":"2015-03-02","objectID":"/20150302-linux%E5%88%87%E6%8D%A2jdk%E7%89%88%E6%9C%AC/:0:0","tags":["Java"],"title":"Linux切换jdk默认版本","uri":"/20150302-linux%E5%88%87%E6%8D%A2jdk%E7%89%88%E6%9C%AC/"},{"categories":["Linux"],"content":"apt 错误 ：“subprocess installed post-installation script returned error exit status 1” 故障排除： apt-get autoclean apt-get autoremove apt-get update apt-get upgrade ","date":"2014-10-12","objectID":"/20141012-ubuntu%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:1:0","tags":["Linux"],"title":"Linux 错误修复笔记","uri":"/20141012-ubuntu%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["Linux"],"content":"系统篇 # 查看LBS 发行版本 cat /etc/lsb-release DISTRIB_ID=Ubuntu DISTRIB_RELEASE=18.04 DISTRIB_CODENAME=bionic DISTRIB_DESCRIPTION=\"Ubuntu 18.04.5 LTS\" # 查看系统有哪些shell cat /etc/shell # 创建用户spaceack; 生成home目录 /home/spaceack ; 指定默认使用zsh sudo adduser --home /home/spaceack --shell /usr/bin/zsh spaceack # 用户给予sudo权限, 直接加入sudo组 sudo usermod -aG sudo spaceack # 其它实现方法 sudo useradd -d /home/spaceack -s /bash/zsh spaceack ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"linux 查询进程所在目录 # 找到进程id ps -aux | grep xxx ll /proc/进程pid lsof -p 进程pid ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:1","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"CPU lscpu cat /proc/cpuinfo # 查看CPU架构 uname -a | awk '{print $12}' ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:2","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"内存 # 查看主板内存插槽数及使用情况 dmidecode|grep -P -A 5 \"Memory\\s+Device\" | grep Size|grep -v Range # 查看主板支持最大内存 sudo dmidecode | grep -P 'Maximum\\s+Capacity' # 查看内存频率 sudo dmidecode | grep -A16 \"Memory Device\"|grep 'Speed' # 查看内存及交换空间使用情况 # -h 以 Gibibytes为单位查看. free -m ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:3","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"磁盘 df # 查看目录的剩余空间, 本质是查看该目录挂载的磁盘的剩余空间。 默认是千字节。 ubuntu@primary:~$ df /tmp Filesystem 1K-blocks Used Available Use% Mounted on /dev/sda1 4911436 2261092 2633960 47% / # -T显示磁盘分区类型 ubuntu@primary:~$ df -T /tmp Filesystem Type 1K-blocks Used Available Use% Mounted on /dev/sda1 ext4 4911436 2265444 2629608 47% / # 配合管道命令 sed awk。 提取 某个数值，如可用空间（Available） ubuntu@primary:~$ df /tmp| sed '1d' | awk '{print $4}' 2629608 # -i 查看 inode 的使用情况 ubuntu@primary:~$ df -i /tmp Filesystem Inodes IUsed IFree IUse% Mounted on /dev/sda1 648320 137952 510368 22% / 交换分区 查看类型为 swap 的 交换分区名称 sudo fdisk -l | grep swap 查看已存在的交换分区名称 swapon -s 临时关闭交换分区 关闭交换分区时, 会把交换分区的数据转移到内存(需确保可用内存 大于 交换分区的已用空间.) sudo swapoff /dev/sda5 开启交换分区 sudo swapon /dev/sda5 ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:4","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"硬件设备 # 查看硬件设备 lshw # PCI 设备列表 lspci # 列出区块设备 lsblk # 列出分区表 fdisk -l ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:5","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"网络 # 改ip sudo ifconfig down sudo ifconfig eth0 192.168.0.200 netmask 255.255.255.0 up # 免sudo密码交互 echo 'password' | sudo -S ifconfig eth0 192.168.0.200 netmask 255.255.255.0 up sudo /etc/init.d/networking restart ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:6","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"传输篇 ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"scp # 使用scp 传输文件 将本地文件data.zip 传到服务器 /data 目录 - # P ssh端口号 scp -P 22 /data/data.zip root@spaceack.com:/data # 使用scp 传输文件 将远程目录 remote_path 传到本地当前目录 scp remote_username@remote_ip:/remote_path/* . ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:1","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"使用rsync断点续传备份包含大量数据的资源目录! rsync -vrtP --rsh='ssh -p 10050' root@66.6.66.666:/data/* /data/backup -v, –verbose 详细模式输出. -r, –recursive 子目录递归处理. -t, –times 保持文件时间信息. -P,–partial 断点续传, –progress 显示传输过程. –rsh=COMMAND 指定使用rsh、ssh方式进行数据同步, rsh为明文传输. -u, 只进行更新，防止本地新文件被重写(不覆盖更新的文件). –ignore-existing, 跳过接收端已存在的文件,目录增量备份会用到. ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:2","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"curl # 下载文件 curl -O http://spaceack.com/data.zip # 上传文件 curl -F \"file=@/data/data.zip\" http://spaceack.com/upload # https忽略证书验证 -k 参数 curl -k https://spaceack.com ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:3","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"其它 # 查看主机 ssh 连接数 w | grep pts |wc -l # 文件批量重命名 apt install rename # 制作U盘启动盘（Centos7） pv -cN source \u003c CentOS-7-x86_64-DVD-1804.iso | sudo dd of=/dev/sdc ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"选择时区 tzselect tzselect # 查看时间 date ","date":"2014-09-10","objectID":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:1","tags":["Linux"],"title":"Linux 常用命令","uri":"/20140910-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Windows"],"content":" 查看MAC地址 ipconfig /all 查看硬盘序列号 开始-运行-cmd-diskpart list disk 查看硬盘数 select disk 0 选择0号磁盘，即当前磁盘 detail disk 查看磁盘详细信息，第二行的磁盘ID， 即该硬盘序列号 ","date":"2010-08-18","objectID":"/20100818-windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["cmd"],"title":"windows操作系统常用命令","uri":"/20100818-windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["生活"],"content":"渔家傲 夜思语 今宵慢慢静无息，苦茶灯下无倦意。思绪悠悠漫天际，在千里，看路漫漫已无力。 长征遥遥仍有期，鸿鹄之志铭心记。疯狂大陆都无语，看东方，一轮红日已升起。 ","date":"2010-06-18","objectID":"/20100618-%E8%AF%97%E8%AF%8D%E4%B8%89%E9%A6%96/:0:1","tags":["poem","情感"],"title":"诗词三首","uri":"/20100618-%E8%AF%97%E8%AF%8D%E4%B8%89%E9%A6%96/"},{"categories":["生活"],"content":"诉秋 晨空破晓雁南飞，星天紫夜寒虫催。 孤灯独鸣漏长深，不食人间烟火味。 ","date":"2010-06-18","objectID":"/20100618-%E8%AF%97%E8%AF%8D%E4%B8%89%E9%A6%96/:0:2","tags":["poem","情感"],"title":"诗词三首","uri":"/20100618-%E8%AF%97%E8%AF%8D%E4%B8%89%E9%A6%96/"},{"categories":["生活"],"content":"军炼行 军训一程行千里 行道草树皆葱茏 道疏人稀心亦远 烈日弥阳心迷灯 百锻瞬息满心倦 百毒神香催人梦 子夜玉铃惊人醒 清风醒神益神功 ","date":"2010-06-18","objectID":"/20100618-%E8%AF%97%E8%AF%8D%E4%B8%89%E9%A6%96/:0:3","tags":["poem","情感"],"title":"诗词三首","uri":"/20100618-%E8%AF%97%E8%AF%8D%E4%B8%89%E9%A6%96/"}]